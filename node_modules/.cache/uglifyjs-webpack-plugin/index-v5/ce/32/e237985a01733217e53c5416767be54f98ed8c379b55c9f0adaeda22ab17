
2d0b1602a3148dfb71554b2e9b689ff8417bccab	{"key":"{\"uglify-es\":\"3.2.2\",\"uglifyjs-webpack-plugin\":\"1.1.5\",\"uglifyjs-webpack-plugin-options\":{\"test\":/\\.js$/i,\"warningsFilter\":function () {\n      return true;\n    },\"extractComments\":false,\"sourceMap\":false,\"cache\":true,\"parallel\":true,\"uglifyOptions\":{\"output\":{\"comments\":false},\"ie8\":false,\"ecma\":5,\"compress\":{\"keep_fnames\":true,\"warnings\":false},\"mangle\":{\"keep_fnames\":true}}},\"path\":\"\\u002FUsers\\u002Fsofiamatulis\\u002FDesktop\\u002Fpublic-mobile-styleguide\\u002Fstyleguide\\u002Fbuild\\u002F0.4a3876a7.js\",\"input\":\"webpackJsonp([0],{\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.js\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F CodeMirror, copyright (c) by Marijn Haverbeke and others\\n\\u002F\\u002F Distributed under an MIT license: http:\\u002F\\u002Fcodemirror.net\\u002FLICENSE\\n\\n\\u002F\\u002F This is CodeMirror (http:\\u002F\\u002Fcodemirror.net), a code editor\\n\\u002F\\u002F implemented in JavaScript on top of the browser's DOM.\\n\\u002F\\u002F\\n\\u002F\\u002F You can find some technical background for some of the code below\\n\\u002F\\u002F at http:\\u002F\\u002Fmarijnhaverbeke.nl\\u002Fblog\\u002F#cm-internals .\\n\\n(function (global, factory) {\\n\\t true ? module.exports = factory() :\\n\\ttypeof define === 'function' && define.amd ? define(factory) :\\n\\t(global.CodeMirror = factory());\\n}(this, (function () { 'use strict';\\n\\n\\u002F\\u002F Kludges for bugs and behavior differences that can't be feature\\n\\u002F\\u002F detected are enabled based on userAgent etc sniffing.\\nvar userAgent = navigator.userAgent;\\nvar platform = navigator.platform;\\n\\nvar gecko = \\u002Fgecko\\\\\\u002F\\\\d\\u002Fi.test(userAgent);\\nvar ie_upto10 = \\u002FMSIE \\\\d\\u002F.test(userAgent);\\nvar ie_11up = \\u002FTrident\\\\\\u002F(?:[7-9]|\\\\d{2,})\\\\..*rv:(\\\\d+)\\u002F.exec(userAgent);\\nvar edge = \\u002FEdge\\\\\\u002F(\\\\d+)\\u002F.exec(userAgent);\\nvar ie = ie_upto10 || ie_11up || edge;\\nvar ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\\nvar webkit = !edge && \\u002FWebKit\\\\\\u002F\\u002F.test(userAgent);\\nvar qtwebkit = webkit && \\u002FQt\\\\\\u002F\\\\d+\\\\.\\\\d+\\u002F.test(userAgent);\\nvar chrome = !edge && \\u002FChrome\\\\\\u002F\\u002F.test(userAgent);\\nvar presto = \\u002FOpera\\\\\\u002F\\u002F.test(userAgent);\\nvar safari = \\u002FApple Computer\\u002F.test(navigator.vendor);\\nvar mac_geMountainLion = \\u002FMac OS X 1\\\\d\\\\D([8-9]|\\\\d\\\\d)\\\\D\\u002F.test(userAgent);\\nvar phantom = \\u002FPhantomJS\\u002F.test(userAgent);\\n\\nvar ios = !edge && \\u002FAppleWebKit\\u002F.test(userAgent) && \\u002FMobile\\\\\\u002F\\\\w+\\u002F.test(userAgent);\\nvar android = \\u002FAndroid\\u002F.test(userAgent);\\n\\u002F\\u002F This is woefully incomplete. Suggestions for alternative methods welcome.\\nvar mobile = ios || android || \\u002FwebOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile\\u002Fi.test(userAgent);\\nvar mac = ios || \\u002FMac\\u002F.test(platform);\\nvar chromeOS = \\u002F\\\\bCrOS\\\\b\\u002F.test(userAgent);\\nvar windows = \\u002Fwin\\u002Fi.test(platform);\\n\\nvar presto_version = presto && userAgent.match(\\u002FVersion\\\\\\u002F(\\\\d*\\\\.\\\\d*)\\u002F);\\nif (presto_version) { presto_version = Number(presto_version[1]); }\\nif (presto_version && presto_version \\u003E= 15) { presto = false; webkit = true; }\\n\\u002F\\u002F Some browsers use the wrong event properties to signal cmd\\u002Fctrl on OS X\\nvar flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version \\u003C 12.11));\\nvar captureRightClick = gecko || (ie && ie_version \\u003E= 9);\\n\\nfunction classTest(cls) { return new RegExp(\\\"(^|\\\\\\\\s)\\\" + cls + \\\"(?:$|\\\\\\\\s)\\\\\\\\s*\\\") }\\n\\nvar rmClass = function(node, cls) {\\n  var current = node.className;\\n  var match = classTest(cls).exec(current);\\n  if (match) {\\n    var after = current.slice(match.index + match[0].length);\\n    node.className = current.slice(0, match.index) + (after ? match[1] + after : \\\"\\\");\\n  }\\n};\\n\\nfunction removeChildren(e) {\\n  for (var count = e.childNodes.length; count \\u003E 0; --count)\\n    { e.removeChild(e.firstChild); }\\n  return e\\n}\\n\\nfunction removeChildrenAndAdd(parent, e) {\\n  return removeChildren(parent).appendChild(e)\\n}\\n\\nfunction elt(tag, content, className, style) {\\n  var e = document.createElement(tag);\\n  if (className) { e.className = className; }\\n  if (style) { e.style.cssText = style; }\\n  if (typeof content == \\\"string\\\") { e.appendChild(document.createTextNode(content)); }\\n  else if (content) { for (var i = 0; i \\u003C content.length; ++i) { e.appendChild(content[i]); } }\\n  return e\\n}\\n\\u002F\\u002F wrapper for elt, which removes the elt from the accessibility tree\\nfunction eltP(tag, content, className, style) {\\n  var e = elt(tag, content, className, style);\\n  e.setAttribute(\\\"role\\\", \\\"presentation\\\");\\n  return e\\n}\\n\\nvar range;\\nif (document.createRange) { range = function(node, start, end, endNode) {\\n  var r = document.createRange();\\n  r.setEnd(endNode || node, end);\\n  r.setStart(node, start);\\n  return r\\n}; }\\nelse { range = function(node, start, end) {\\n  var r = document.body.createTextRange();\\n  try { r.moveToElementText(node.parentNode); }\\n  catch(e) { return r }\\n  r.collapse(true);\\n  r.moveEnd(\\\"character\\\", end);\\n  r.moveStart(\\\"character\\\", start);\\n  return r\\n}; }\\n\\nfunction contains(parent, child) {\\n  if (child.nodeType == 3) \\u002F\\u002F Android browser always returns false when child is a textnode\\n    { child = child.parentNode; }\\n  if (parent.contains)\\n    { return parent.contains(child) }\\n  do {\\n    if (child.nodeType == 11) { child = child.host; }\\n    if (child == parent) { return true }\\n  } while (child = child.parentNode)\\n}\\n\\nfunction activeElt() {\\n  \\u002F\\u002F IE and Edge may throw an \\\"Unspecified Error\\\" when accessing document.activeElement.\\n  \\u002F\\u002F IE \\u003C 10 will throw when accessed while the page is loading or in an iframe.\\n  \\u002F\\u002F IE \\u003E 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\\n  var activeElement;\\n  try {\\n    activeElement = document.activeElement;\\n  } catch(e) {\\n    activeElement = document.body || null;\\n  }\\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\\n    { activeElement = activeElement.shadowRoot.activeElement; }\\n  return activeElement\\n}\\n\\nfunction addClass(node, cls) {\\n  var current = node.className;\\n  if (!classTest(cls).test(current)) { node.className += (current ? \\\" \\\" : \\\"\\\") + cls; }\\n}\\nfunction joinClasses(a, b) {\\n  var as = a.split(\\\" \\\");\\n  for (var i = 0; i \\u003C as.length; i++)\\n    { if (as[i] && !classTest(as[i]).test(b)) { b += \\\" \\\" + as[i]; } }\\n  return b\\n}\\n\\nvar selectInput = function(node) { node.select(); };\\nif (ios) \\u002F\\u002F Mobile Safari apparently has a bug where select() is broken.\\n  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\\nelse if (ie) \\u002F\\u002F Suppress mysterious IE10 errors\\n  { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\\n\\nfunction bind(f) {\\n  var args = Array.prototype.slice.call(arguments, 1);\\n  return function(){return f.apply(null, args)}\\n}\\n\\nfunction copyObj(obj, target, overwrite) {\\n  if (!target) { target = {}; }\\n  for (var prop in obj)\\n    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\\n      { target[prop] = obj[prop]; } }\\n  return target\\n}\\n\\n\\u002F\\u002F Counts the column offset in a string, taking tabs into account.\\n\\u002F\\u002F Used mostly to find indentation.\\nfunction countColumn(string, end, tabSize, startIndex, startValue) {\\n  if (end == null) {\\n    end = string.search(\\u002F[^\\\\s\\\\u00a0]\\u002F);\\n    if (end == -1) { end = string.length; }\\n  }\\n  for (var i = startIndex || 0, n = startValue || 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", i);\\n    if (nextTab \\u003C 0 || nextTab \\u003E= end)\\n      { return n + (end - i) }\\n    n += nextTab - i;\\n    n += tabSize - (n % tabSize);\\n    i = nextTab + 1;\\n  }\\n}\\n\\nvar Delayed = function() {this.id = null;};\\nDelayed.prototype.set = function (ms, f) {\\n  clearTimeout(this.id);\\n  this.id = setTimeout(f, ms);\\n};\\n\\nfunction indexOf(array, elt) {\\n  for (var i = 0; i \\u003C array.length; ++i)\\n    { if (array[i] == elt) { return i } }\\n  return -1\\n}\\n\\n\\u002F\\u002F Number of pixels added to scroller and sizer to hide scrollbar\\nvar scrollerGap = 30;\\n\\n\\u002F\\u002F Returned or thrown by various protocols to signal 'I'm not\\n\\u002F\\u002F handling this'.\\nvar Pass = {toString: function(){return \\\"CodeMirror.Pass\\\"}};\\n\\n\\u002F\\u002F Reused option objects for setSelection & friends\\nvar sel_dontScroll = {scroll: false};\\nvar sel_mouse = {origin: \\\"*mouse\\\"};\\nvar sel_move = {origin: \\\"+move\\\"};\\n\\n\\u002F\\u002F The inverse of countColumn -- find the offset that corresponds to\\n\\u002F\\u002F a particular column.\\nfunction findColumn(string, goal, tabSize) {\\n  for (var pos = 0, col = 0;;) {\\n    var nextTab = string.indexOf(\\\"\\\\t\\\", pos);\\n    if (nextTab == -1) { nextTab = string.length; }\\n    var skipped = nextTab - pos;\\n    if (nextTab == string.length || col + skipped \\u003E= goal)\\n      { return pos + Math.min(skipped, goal - col) }\\n    col += nextTab - pos;\\n    col += tabSize - (col % tabSize);\\n    pos = nextTab + 1;\\n    if (col \\u003E= goal) { return pos }\\n  }\\n}\\n\\nvar spaceStrs = [\\\"\\\"];\\nfunction spaceStr(n) {\\n  while (spaceStrs.length \\u003C= n)\\n    { spaceStrs.push(lst(spaceStrs) + \\\" \\\"); }\\n  return spaceStrs[n]\\n}\\n\\nfunction lst(arr) { return arr[arr.length-1] }\\n\\nfunction map(array, f) {\\n  var out = [];\\n  for (var i = 0; i \\u003C array.length; i++) { out[i] = f(array[i], i); }\\n  return out\\n}\\n\\nfunction insertSorted(array, value, score) {\\n  var pos = 0, priority = score(value);\\n  while (pos \\u003C array.length && score(array[pos]) \\u003C= priority) { pos++; }\\n  array.splice(pos, 0, value);\\n}\\n\\nfunction nothing() {}\\n\\nfunction createObj(base, props) {\\n  var inst;\\n  if (Object.create) {\\n    inst = Object.create(base);\\n  } else {\\n    nothing.prototype = base;\\n    inst = new nothing();\\n  }\\n  if (props) { copyObj(props, inst); }\\n  return inst\\n}\\n\\nvar nonASCIISingleCaseWordChar = \\u002F[\\\\u00df\\\\u0587\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u3040-\\\\u309f\\\\u30a0-\\\\u30ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fcc\\\\uac00-\\\\ud7af]\\u002F;\\nfunction isWordCharBasic(ch) {\\n  return \\u002F\\\\w\\u002F.test(ch) || ch \\u003E \\\"\\\\x80\\\" &&\\n    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\\n}\\nfunction isWordChar(ch, helper) {\\n  if (!helper) { return isWordCharBasic(ch) }\\n  if (helper.source.indexOf(\\\"\\\\\\\\w\\\") \\u003E -1 && isWordCharBasic(ch)) { return true }\\n  return helper.test(ch)\\n}\\n\\nfunction isEmpty(obj) {\\n  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\\n  return true\\n}\\n\\n\\u002F\\u002F Extending unicode characters. A series of a non-extending char +\\n\\u002F\\u002F any number of extending chars is treated as a single unit as far\\n\\u002F\\u002F as editing and measuring is concerned. This is not fully correct,\\n\\u002F\\u002F since some scripts\\u002Ffonts\\u002Fbrowsers also treat other configurations\\n\\u002F\\u002F of code points as a group.\\nvar extendingChars = \\u002F[\\\\u0300-\\\\u036f\\\\u0483-\\\\u0489\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u065e\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06de-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07eb-\\\\u07f3\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0900-\\\\u0902\\\\u093c\\\\u0941-\\\\u0948\\\\u094d\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09bc\\\\u09be\\\\u09c1-\\\\u09c4\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u0a01\\\\u0a02\\\\u0a3c\\\\u0a41\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a70\\\\u0a71\\\\u0a75\\\\u0a81\\\\u0a82\\\\u0abc\\\\u0ac1-\\\\u0ac5\\\\u0ac7\\\\u0ac8\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0b01\\\\u0b3c\\\\u0b3e\\\\u0b3f\\\\u0b41-\\\\u0b44\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b82\\\\u0bbe\\\\u0bc0\\\\u0bcd\\\\u0bd7\\\\u0c3e-\\\\u0c40\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0cbc\\\\u0cbf\\\\u0cc2\\\\u0cc6\\\\u0ccc\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0d3e\\\\u0d41-\\\\u0d44\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0dca\\\\u0dcf\\\\u0dd2-\\\\u0dd4\\\\u0dd6\\\\u0ddf\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0eb1\\\\u0eb4-\\\\u0eb9\\\\u0ebb\\\\u0ebc\\\\u0ec8-\\\\u0ecd\\\\u0f18\\\\u0f19\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f71-\\\\u0f7e\\\\u0f80-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f90-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102d-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103a\\\\u103d\\\\u103e\\\\u1058\\\\u1059\\\\u105e-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108d\\\\u109d\\\\u135f\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b7-\\\\u17bd\\\\u17c6\\\\u17c9-\\\\u17d3\\\\u17dd\\\\u180b-\\\\u180d\\\\u18a9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193b\\\\u1a17\\\\u1a18\\\\u1a56\\\\u1a58-\\\\u1a5e\\\\u1a60\\\\u1a62\\\\u1a65-\\\\u1a6c\\\\u1a73-\\\\u1a7c\\\\u1a7f\\\\u1b00-\\\\u1b03\\\\u1b34\\\\u1b36-\\\\u1b3a\\\\u1b3c\\\\u1b42\\\\u1b6b-\\\\u1b73\\\\u1b80\\\\u1b81\\\\u1ba2-\\\\u1ba5\\\\u1ba8\\\\u1ba9\\\\u1c2c-\\\\u1c33\\\\u1c36\\\\u1c37\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce0\\\\u1ce2-\\\\u1ce8\\\\u1ced\\\\u1dc0-\\\\u1de6\\\\u1dfd-\\\\u1dff\\\\u200c\\\\u200d\\\\u20d0-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\ua66f-\\\\ua672\\\\ua67c\\\\ua67d\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua825\\\\ua826\\\\ua8c4\\\\ua8e0-\\\\ua8f1\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua951\\\\ua980-\\\\ua982\\\\ua9b3\\\\ua9b6-\\\\ua9b9\\\\ua9bc\\\\uaa29-\\\\uaa2e\\\\uaa31\\\\uaa32\\\\uaa35\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uabe5\\\\uabe8\\\\uabed\\\\udc00-\\\\udfff\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe26\\\\uff9e\\\\uff9f]\\u002F;\\nfunction isExtendingChar(ch) { return ch.charCodeAt(0) \\u003E= 768 && extendingChars.test(ch) }\\n\\n\\u002F\\u002F Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\\nfunction skipExtendingChars(str, pos, dir) {\\n  while ((dir \\u003C 0 ? pos \\u003E 0 : pos \\u003C str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\\n  return pos\\n}\\n\\n\\u002F\\u002F Returns the value from the range [`from`; `to`] that satisfies\\n\\u002F\\u002F `pred` and is closest to `from`. Assumes that at least `to`\\n\\u002F\\u002F satisfies `pred`. Supports `from` being greater than `to`.\\nfunction findFirst(pred, from, to) {\\n  \\u002F\\u002F At any point we are certain `to` satisfies `pred`, don't know\\n  \\u002F\\u002F whether `from` does.\\n  var dir = from \\u003E to ? -1 : 1;\\n  for (;;) {\\n    if (from == to) { return from }\\n    var midF = (from + to) \\u002F 2, mid = dir \\u003C 0 ? Math.ceil(midF) : Math.floor(midF);\\n    if (mid == from) { return pred(mid) ? from : to }\\n    if (pred(mid)) { to = mid; }\\n    else { from = mid + dir; }\\n  }\\n}\\n\\n\\u002F\\u002F The display handles the DOM integration, both for input reading\\n\\u002F\\u002F and content drawing. It holds references to DOM nodes and\\n\\u002F\\u002F display-related state.\\n\\nfunction Display(place, doc, input) {\\n  var d = this;\\n  this.input = input;\\n\\n  \\u002F\\u002F Covers bottom-right square when both scrollbars are present.\\n  d.scrollbarFiller = elt(\\\"div\\\", null, \\\"CodeMirror-scrollbar-filler\\\");\\n  d.scrollbarFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n  \\u002F\\u002F Covers bottom of gutter when coverGutterNextToScrollbar is on\\n  \\u002F\\u002F and h scrollbar is present.\\n  d.gutterFiller = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-filler\\\");\\n  d.gutterFiller.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n  \\u002F\\u002F Will contain the actual code, positioned to cover the viewport.\\n  d.lineDiv = eltP(\\\"div\\\", null, \\\"CodeMirror-code\\\");\\n  \\u002F\\u002F Elements are added to these to represent selection and cursors.\\n  d.selectionDiv = elt(\\\"div\\\", null, null, \\\"position: relative; z-index: 1\\\");\\n  d.cursorDiv = elt(\\\"div\\\", null, \\\"CodeMirror-cursors\\\");\\n  \\u002F\\u002F A visibility: hidden element used to find the size of things.\\n  d.measure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\");\\n  \\u002F\\u002F When lines outside of the viewport are measured, they are drawn in this.\\n  d.lineMeasure = elt(\\\"div\\\", null, \\\"CodeMirror-measure\\\");\\n  \\u002F\\u002F Wraps everything that needs to exist inside the vertically-padded coordinate system\\n  d.lineSpace = eltP(\\\"div\\\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\\n                    null, \\\"position: relative; outline: none\\\");\\n  var lines = eltP(\\\"div\\\", [d.lineSpace], \\\"CodeMirror-lines\\\");\\n  \\u002F\\u002F Moved around its parent to cover visible view.\\n  d.mover = elt(\\\"div\\\", [lines], null, \\\"position: relative\\\");\\n  \\u002F\\u002F Set to the height of the document, allowing scrolling.\\n  d.sizer = elt(\\\"div\\\", [d.mover], \\\"CodeMirror-sizer\\\");\\n  d.sizerWidth = null;\\n  \\u002F\\u002F Behavior of elts with overflow: auto and padding is\\n  \\u002F\\u002F inconsistent across browsers. This is used to ensure the\\n  \\u002F\\u002F scrollable area is big enough.\\n  d.heightForcer = elt(\\\"div\\\", null, null, \\\"position: absolute; height: \\\" + scrollerGap + \\\"px; width: 1px;\\\");\\n  \\u002F\\u002F Will contain the gutters, if any.\\n  d.gutters = elt(\\\"div\\\", null, \\\"CodeMirror-gutters\\\");\\n  d.lineGutter = null;\\n  \\u002F\\u002F Actual scrollable element.\\n  d.scroller = elt(\\\"div\\\", [d.sizer, d.heightForcer, d.gutters], \\\"CodeMirror-scroll\\\");\\n  d.scroller.setAttribute(\\\"tabIndex\\\", \\\"-1\\\");\\n  \\u002F\\u002F The element in which the editor lives.\\n  d.wrapper = elt(\\\"div\\\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \\\"CodeMirror\\\");\\n\\n  \\u002F\\u002F Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\\n  if (ie && ie_version \\u003C 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\\n  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\\n\\n  if (place) {\\n    if (place.appendChild) { place.appendChild(d.wrapper); }\\n    else { place(d.wrapper); }\\n  }\\n\\n  \\u002F\\u002F Current rendered range (may be bigger than the view window).\\n  d.viewFrom = d.viewTo = doc.first;\\n  d.reportedViewFrom = d.reportedViewTo = doc.first;\\n  \\u002F\\u002F Information about the rendered lines.\\n  d.view = [];\\n  d.renderedView = null;\\n  \\u002F\\u002F Holds info about a single rendered line when it was rendered\\n  \\u002F\\u002F for measurement, while not in view.\\n  d.externalMeasured = null;\\n  \\u002F\\u002F Empty space (in pixels) above the view\\n  d.viewOffset = 0;\\n  d.lastWrapHeight = d.lastWrapWidth = 0;\\n  d.updateLineNumbers = null;\\n\\n  d.nativeBarWidth = d.barHeight = d.barWidth = 0;\\n  d.scrollbarsClipped = false;\\n\\n  \\u002F\\u002F Used to only resize the line number gutter when necessary (when\\n  \\u002F\\u002F the amount of lines crosses a boundary that makes its width change)\\n  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\\n  \\u002F\\u002F Set to true when a non-horizontal-scrolling line widget is\\n  \\u002F\\u002F added. As an optimization, line widget aligning is skipped when\\n  \\u002F\\u002F this is false.\\n  d.alignWidgets = false;\\n\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\\n\\n  \\u002F\\u002F Tracks the maximum line length so that the horizontal scrollbar\\n  \\u002F\\u002F can be kept static when scrolling.\\n  d.maxLine = null;\\n  d.maxLineLength = 0;\\n  d.maxLineChanged = false;\\n\\n  \\u002F\\u002F Used for measuring wheel scrolling granularity\\n  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\\n\\n  \\u002F\\u002F True when shift is held down.\\n  d.shift = false;\\n\\n  \\u002F\\u002F Used to track whether anything happened since the context menu\\n  \\u002F\\u002F was opened.\\n  d.selForContextMenu = null;\\n\\n  d.activeTouch = null;\\n\\n  input.init(d);\\n}\\n\\n\\u002F\\u002F Find the line object corresponding to the given line number.\\nfunction getLine(doc, n) {\\n  n -= doc.first;\\n  if (n \\u003C 0 || n \\u003E= doc.size) { throw new Error(\\\"There is no line \\\" + (n + doc.first) + \\\" in the document.\\\") }\\n  var chunk = doc;\\n  while (!chunk.lines) {\\n    for (var i = 0;; ++i) {\\n      var child = chunk.children[i], sz = child.chunkSize();\\n      if (n \\u003C sz) { chunk = child; break }\\n      n -= sz;\\n    }\\n  }\\n  return chunk.lines[n]\\n}\\n\\n\\u002F\\u002F Get the part of a document between two positions, as an array of\\n\\u002F\\u002F strings.\\nfunction getBetween(doc, start, end) {\\n  var out = [], n = start.line;\\n  doc.iter(start.line, end.line + 1, function (line) {\\n    var text = line.text;\\n    if (n == end.line) { text = text.slice(0, end.ch); }\\n    if (n == start.line) { text = text.slice(start.ch); }\\n    out.push(text);\\n    ++n;\\n  });\\n  return out\\n}\\n\\u002F\\u002F Get the lines between from and to, as array of strings.\\nfunction getLines(doc, from, to) {\\n  var out = [];\\n  doc.iter(from, to, function (line) { out.push(line.text); }); \\u002F\\u002F iter aborts when callback returns truthy value\\n  return out\\n}\\n\\n\\u002F\\u002F Update the height of a line, propagating the height change\\n\\u002F\\u002F upwards to parent nodes.\\nfunction updateLineHeight(line, height) {\\n  var diff = height - line.height;\\n  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\\n}\\n\\n\\u002F\\u002F Given a line object, find its line number by walking up through\\n\\u002F\\u002F its parent links.\\nfunction lineNo(line) {\\n  if (line.parent == null) { return null }\\n  var cur = line.parent, no = indexOf(cur.lines, line);\\n  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\\n    for (var i = 0;; ++i) {\\n      if (chunk.children[i] == cur) { break }\\n      no += chunk.children[i].chunkSize();\\n    }\\n  }\\n  return no + cur.first\\n}\\n\\n\\u002F\\u002F Find the line at the given vertical position, using the height\\n\\u002F\\u002F information in the document tree.\\nfunction lineAtHeight(chunk, h) {\\n  var n = chunk.first;\\n  outer: do {\\n    for (var i$1 = 0; i$1 \\u003C chunk.children.length; ++i$1) {\\n      var child = chunk.children[i$1], ch = child.height;\\n      if (h \\u003C ch) { chunk = child; continue outer }\\n      h -= ch;\\n      n += child.chunkSize();\\n    }\\n    return n\\n  } while (!chunk.lines)\\n  var i = 0;\\n  for (; i \\u003C chunk.lines.length; ++i) {\\n    var line = chunk.lines[i], lh = line.height;\\n    if (h \\u003C lh) { break }\\n    h -= lh;\\n  }\\n  return n + i\\n}\\n\\nfunction isLine(doc, l) {return l \\u003E= doc.first && l \\u003C doc.first + doc.size}\\n\\nfunction lineNumberFor(options, i) {\\n  return String(options.lineNumberFormatter(i + options.firstLineNumber))\\n}\\n\\n\\u002F\\u002F A Pos instance represents a position within the text.\\nfunction Pos(line, ch, sticky) {\\n  if ( sticky === void 0 ) sticky = null;\\n\\n  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\\n  this.line = line;\\n  this.ch = ch;\\n  this.sticky = sticky;\\n}\\n\\n\\u002F\\u002F Compare two positions, return 0 if they are the same, a negative\\n\\u002F\\u002F number when a is less, and a positive number otherwise.\\nfunction cmp(a, b) { return a.line - b.line || a.ch - b.ch }\\n\\nfunction equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\\n\\nfunction copyPos(x) {return Pos(x.line, x.ch)}\\nfunction maxPos(a, b) { return cmp(a, b) \\u003C 0 ? b : a }\\nfunction minPos(a, b) { return cmp(a, b) \\u003C 0 ? a : b }\\n\\n\\u002F\\u002F Most of the external API clips given positions to make sure they\\n\\u002F\\u002F actually exist within the document.\\nfunction clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\\nfunction clipPos(doc, pos) {\\n  if (pos.line \\u003C doc.first) { return Pos(doc.first, 0) }\\n  var last = doc.first + doc.size - 1;\\n  if (pos.line \\u003E last) { return Pos(last, getLine(doc, last).text.length) }\\n  return clipToLen(pos, getLine(doc, pos.line).text.length)\\n}\\nfunction clipToLen(pos, linelen) {\\n  var ch = pos.ch;\\n  if (ch == null || ch \\u003E linelen) { return Pos(pos.line, linelen) }\\n  else if (ch \\u003C 0) { return Pos(pos.line, 0) }\\n  else { return pos }\\n}\\nfunction clipPosArray(doc, array) {\\n  var out = [];\\n  for (var i = 0; i \\u003C array.length; i++) { out[i] = clipPos(doc, array[i]); }\\n  return out\\n}\\n\\n\\u002F\\u002F Optimize some code when these features are not used.\\nvar sawReadOnlySpans = false;\\nvar sawCollapsedSpans = false;\\n\\nfunction seeReadOnlySpans() {\\n  sawReadOnlySpans = true;\\n}\\n\\nfunction seeCollapsedSpans() {\\n  sawCollapsedSpans = true;\\n}\\n\\n\\u002F\\u002F TEXTMARKER SPANS\\n\\nfunction MarkedSpan(marker, from, to) {\\n  this.marker = marker;\\n  this.from = from; this.to = to;\\n}\\n\\n\\u002F\\u002F Search an array of spans for a span matching the given marker.\\nfunction getMarkedSpanFor(spans, marker) {\\n  if (spans) { for (var i = 0; i \\u003C spans.length; ++i) {\\n    var span = spans[i];\\n    if (span.marker == marker) { return span }\\n  } }\\n}\\n\\u002F\\u002F Remove a span from an array, returning undefined if no spans are\\n\\u002F\\u002F left (we don't store arrays for lines without spans).\\nfunction removeMarkedSpan(spans, span) {\\n  var r;\\n  for (var i = 0; i \\u003C spans.length; ++i)\\n    { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\\n  return r\\n}\\n\\u002F\\u002F Add a span to a line.\\nfunction addMarkedSpan(line, span) {\\n  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\\n  span.marker.attachLine(line);\\n}\\n\\n\\u002F\\u002F Used for the algorithm that adjusts markers for a change in the\\n\\u002F\\u002F document. These functions cut an array of spans at a given\\n\\u002F\\u002F character position, returning an array of remaining chunks (or\\n\\u002F\\u002F undefined if nothing remains).\\nfunction markedSpansBefore(old, startCh, isInsert) {\\n  var nw;\\n  if (old) { for (var i = 0; i \\u003C old.length; ++i) {\\n    var span = old[i], marker = span.marker;\\n    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from \\u003C= startCh : span.from \\u003C startCh);\\n    if (startsBefore || span.from == startCh && marker.type == \\\"bookmark\\\" && (!isInsert || !span.marker.insertLeft)) {\\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to \\u003E= startCh : span.to \\u003E startCh);(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\\n    }\\n  } }\\n  return nw\\n}\\nfunction markedSpansAfter(old, endCh, isInsert) {\\n  var nw;\\n  if (old) { for (var i = 0; i \\u003C old.length; ++i) {\\n    var span = old[i], marker = span.marker;\\n    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to \\u003E= endCh : span.to \\u003E endCh);\\n    if (endsAfter || span.from == endCh && marker.type == \\\"bookmark\\\" && (!isInsert || span.marker.insertLeft)) {\\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from \\u003C= endCh : span.from \\u003C endCh);(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\\n                                            span.to == null ? null : span.to - endCh));\\n    }\\n  } }\\n  return nw\\n}\\n\\n\\u002F\\u002F Given a change object, compute the new set of marker spans that\\n\\u002F\\u002F cover the line in which the change took place. Removes spans\\n\\u002F\\u002F entirely within the change, reconnects spans belonging to the\\n\\u002F\\u002F same marker that appear on both sides of the change, and cuts off\\n\\u002F\\u002F spans partially within the change. Returns an array of span\\n\\u002F\\u002F arrays with one element for each line in (after) the change.\\nfunction stretchSpansOverChange(doc, change) {\\n  if (change.full) { return null }\\n  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\\n  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\\n  if (!oldFirst && !oldLast) { return null }\\n\\n  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\\n  \\u002F\\u002F Get the spans that 'stick out' on both sides\\n  var first = markedSpansBefore(oldFirst, startCh, isInsert);\\n  var last = markedSpansAfter(oldLast, endCh, isInsert);\\n\\n  \\u002F\\u002F Next, merge those two ends\\n  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\\n  if (first) {\\n    \\u002F\\u002F Fix up .to properties of first\\n    for (var i = 0; i \\u003C first.length; ++i) {\\n      var span = first[i];\\n      if (span.to == null) {\\n        var found = getMarkedSpanFor(last, span.marker);\\n        if (!found) { span.to = startCh; }\\n        else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\\n      }\\n    }\\n  }\\n  if (last) {\\n    \\u002F\\u002F Fix up .from in last (or move them into first in case of sameLine)\\n    for (var i$1 = 0; i$1 \\u003C last.length; ++i$1) {\\n      var span$1 = last[i$1];\\n      if (span$1.to != null) { span$1.to += offset; }\\n      if (span$1.from == null) {\\n        var found$1 = getMarkedSpanFor(first, span$1.marker);\\n        if (!found$1) {\\n          span$1.from = offset;\\n          if (sameLine) { (first || (first = [])).push(span$1); }\\n        }\\n      } else {\\n        span$1.from += offset;\\n        if (sameLine) { (first || (first = [])).push(span$1); }\\n      }\\n    }\\n  }\\n  \\u002F\\u002F Make sure we didn't create any zero-length spans\\n  if (first) { first = clearEmptySpans(first); }\\n  if (last && last != first) { last = clearEmptySpans(last); }\\n\\n  var newMarkers = [first];\\n  if (!sameLine) {\\n    \\u002F\\u002F Fill gap with whole-line-spans\\n    var gap = change.text.length - 2, gapMarkers;\\n    if (gap \\u003E 0 && first)\\n      { for (var i$2 = 0; i$2 \\u003C first.length; ++i$2)\\n        { if (first[i$2].to == null)\\n          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\\n    for (var i$3 = 0; i$3 \\u003C gap; ++i$3)\\n      { newMarkers.push(gapMarkers); }\\n    newMarkers.push(last);\\n  }\\n  return newMarkers\\n}\\n\\n\\u002F\\u002F Remove spans that are empty and don't have a clearWhenEmpty\\n\\u002F\\u002F option of false.\\nfunction clearEmptySpans(spans) {\\n  for (var i = 0; i \\u003C spans.length; ++i) {\\n    var span = spans[i];\\n    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\\n      { spans.splice(i--, 1); }\\n  }\\n  if (!spans.length) { return null }\\n  return spans\\n}\\n\\n\\u002F\\u002F Used to 'clip' out readOnly ranges when making a change.\\nfunction removeReadOnlyRanges(doc, from, to) {\\n  var markers = null;\\n  doc.iter(from.line, to.line + 1, function (line) {\\n    if (line.markedSpans) { for (var i = 0; i \\u003C line.markedSpans.length; ++i) {\\n      var mark = line.markedSpans[i].marker;\\n      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\\n        { (markers || (markers = [])).push(mark); }\\n    } }\\n  });\\n  if (!markers) { return null }\\n  var parts = [{from: from, to: to}];\\n  for (var i = 0; i \\u003C markers.length; ++i) {\\n    var mk = markers[i], m = mk.find(0);\\n    for (var j = 0; j \\u003C parts.length; ++j) {\\n      var p = parts[j];\\n      if (cmp(p.to, m.from) \\u003C 0 || cmp(p.from, m.to) \\u003E 0) { continue }\\n      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\\n      if (dfrom \\u003C 0 || !mk.inclusiveLeft && !dfrom)\\n        { newParts.push({from: p.from, to: m.from}); }\\n      if (dto \\u003E 0 || !mk.inclusiveRight && !dto)\\n        { newParts.push({from: m.to, to: p.to}); }\\n      parts.splice.apply(parts, newParts);\\n      j += newParts.length - 3;\\n    }\\n  }\\n  return parts\\n}\\n\\n\\u002F\\u002F Connect or disconnect spans from a line.\\nfunction detachMarkedSpans(line) {\\n  var spans = line.markedSpans;\\n  if (!spans) { return }\\n  for (var i = 0; i \\u003C spans.length; ++i)\\n    { spans[i].marker.detachLine(line); }\\n  line.markedSpans = null;\\n}\\nfunction attachMarkedSpans(line, spans) {\\n  if (!spans) { return }\\n  for (var i = 0; i \\u003C spans.length; ++i)\\n    { spans[i].marker.attachLine(line); }\\n  line.markedSpans = spans;\\n}\\n\\n\\u002F\\u002F Helpers used when computing which overlapping collapsed span\\n\\u002F\\u002F counts as the larger one.\\nfunction extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\\nfunction extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\\n\\n\\u002F\\u002F Returns a number indicating which of two overlapping collapsed\\n\\u002F\\u002F spans is larger (and thus includes the other). Falls back to\\n\\u002F\\u002F comparing ids when the spans cover exactly the same range.\\nfunction compareCollapsedMarkers(a, b) {\\n  var lenDiff = a.lines.length - b.lines.length;\\n  if (lenDiff != 0) { return lenDiff }\\n  var aPos = a.find(), bPos = b.find();\\n  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\\n  if (fromCmp) { return -fromCmp }\\n  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\\n  if (toCmp) { return toCmp }\\n  return b.id - a.id\\n}\\n\\n\\u002F\\u002F Find out whether a line ends or starts in a collapsed span. If\\n\\u002F\\u002F so, return the marker for that span.\\nfunction collapsedSpanAtSide(line, start) {\\n  var sps = sawCollapsedSpans && line.markedSpans, found;\\n  if (sps) { for (var sp = (void 0), i = 0; i \\u003C sps.length; ++i) {\\n    sp = sps[i];\\n    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\\n        (!found || compareCollapsedMarkers(found, sp.marker) \\u003C 0))\\n      { found = sp.marker; }\\n  } }\\n  return found\\n}\\nfunction collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\\nfunction collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\\n\\n\\u002F\\u002F Test whether there exists a collapsed span that partially\\n\\u002F\\u002F overlaps (covers the start or end, but not both) of a new span.\\n\\u002F\\u002F Such overlap is not allowed.\\nfunction conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\\n  var line = getLine(doc, lineNo$$1);\\n  var sps = sawCollapsedSpans && line.markedSpans;\\n  if (sps) { for (var i = 0; i \\u003C sps.length; ++i) {\\n    var sp = sps[i];\\n    if (!sp.marker.collapsed) { continue }\\n    var found = sp.marker.find(0);\\n    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\\n    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\\n    if (fromCmp \\u003E= 0 && toCmp \\u003C= 0 || fromCmp \\u003C= 0 && toCmp \\u003E= 0) { continue }\\n    if (fromCmp \\u003C= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) \\u003E= 0 : cmp(found.to, from) \\u003E 0) ||\\n        fromCmp \\u003E= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) \\u003C= 0 : cmp(found.from, to) \\u003C 0))\\n      { return true }\\n  } }\\n}\\n\\n\\u002F\\u002F A visual line is a line as drawn on the screen. Folding, for\\n\\u002F\\u002F example, can cause multiple logical lines to appear on the same\\n\\u002F\\u002F visual line. This finds the start of the visual line that the\\n\\u002F\\u002F given line is part of (usually that is the line itself).\\nfunction visualLine(line) {\\n  var merged;\\n  while (merged = collapsedSpanAtStart(line))\\n    { line = merged.find(-1, true).line; }\\n  return line\\n}\\n\\nfunction visualLineEnd(line) {\\n  var merged;\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line; }\\n  return line\\n}\\n\\n\\u002F\\u002F Returns an array of logical lines that continue the visual line\\n\\u002F\\u002F started by the argument, or undefined if there are no such lines.\\nfunction visualLineContinued(line) {\\n  var merged, lines;\\n  while (merged = collapsedSpanAtEnd(line)) {\\n    line = merged.find(1, true).line\\n    ;(lines || (lines = [])).push(line);\\n  }\\n  return lines\\n}\\n\\n\\u002F\\u002F Get the line number of the start of the visual line that the\\n\\u002F\\u002F given line number is part of.\\nfunction visualLineNo(doc, lineN) {\\n  var line = getLine(doc, lineN), vis = visualLine(line);\\n  if (line == vis) { return lineN }\\n  return lineNo(vis)\\n}\\n\\n\\u002F\\u002F Get the line number of the start of the next visual line after\\n\\u002F\\u002F the given line.\\nfunction visualLineEndNo(doc, lineN) {\\n  if (lineN \\u003E doc.lastLine()) { return lineN }\\n  var line = getLine(doc, lineN), merged;\\n  if (!lineIsHidden(doc, line)) { return lineN }\\n  while (merged = collapsedSpanAtEnd(line))\\n    { line = merged.find(1, true).line; }\\n  return lineNo(line) + 1\\n}\\n\\n\\u002F\\u002F Compute whether a line is hidden. Lines count as hidden when they\\n\\u002F\\u002F are part of a visual line that starts with another line, or when\\n\\u002F\\u002F they are entirely covered by collapsed, non-widget span.\\nfunction lineIsHidden(doc, line) {\\n  var sps = sawCollapsedSpans && line.markedSpans;\\n  if (sps) { for (var sp = (void 0), i = 0; i \\u003C sps.length; ++i) {\\n    sp = sps[i];\\n    if (!sp.marker.collapsed) { continue }\\n    if (sp.from == null) { return true }\\n    if (sp.marker.widgetNode) { continue }\\n    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\\n      { return true }\\n  } }\\n}\\nfunction lineIsHiddenInner(doc, line, span) {\\n  if (span.to == null) {\\n    var end = span.marker.find(1, true);\\n    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\\n  }\\n  if (span.marker.inclusiveRight && span.to == line.text.length)\\n    { return true }\\n  for (var sp = (void 0), i = 0; i \\u003C line.markedSpans.length; ++i) {\\n    sp = line.markedSpans[i];\\n    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\\n        (sp.to == null || sp.to != span.from) &&\\n        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\\n        lineIsHiddenInner(doc, line, sp)) { return true }\\n  }\\n}\\n\\n\\u002F\\u002F Find the height above the given line.\\nfunction heightAtLine(lineObj) {\\n  lineObj = visualLine(lineObj);\\n\\n  var h = 0, chunk = lineObj.parent;\\n  for (var i = 0; i \\u003C chunk.lines.length; ++i) {\\n    var line = chunk.lines[i];\\n    if (line == lineObj) { break }\\n    else { h += line.height; }\\n  }\\n  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\\n    for (var i$1 = 0; i$1 \\u003C p.children.length; ++i$1) {\\n      var cur = p.children[i$1];\\n      if (cur == chunk) { break }\\n      else { h += cur.height; }\\n    }\\n  }\\n  return h\\n}\\n\\n\\u002F\\u002F Compute the character length of a line, taking into account\\n\\u002F\\u002F collapsed ranges (see markText) that might hide parts, and join\\n\\u002F\\u002F other lines onto it.\\nfunction lineLength(line) {\\n  if (line.height == 0) { return 0 }\\n  var len = line.text.length, merged, cur = line;\\n  while (merged = collapsedSpanAtStart(cur)) {\\n    var found = merged.find(0, true);\\n    cur = found.from.line;\\n    len += found.from.ch - found.to.ch;\\n  }\\n  cur = line;\\n  while (merged = collapsedSpanAtEnd(cur)) {\\n    var found$1 = merged.find(0, true);\\n    len -= cur.text.length - found$1.from.ch;\\n    cur = found$1.to.line;\\n    len += cur.text.length - found$1.to.ch;\\n  }\\n  return len\\n}\\n\\n\\u002F\\u002F Find the longest line in the document.\\nfunction findMaxLine(cm) {\\n  var d = cm.display, doc = cm.doc;\\n  d.maxLine = getLine(doc, doc.first);\\n  d.maxLineLength = lineLength(d.maxLine);\\n  d.maxLineChanged = true;\\n  doc.iter(function (line) {\\n    var len = lineLength(line);\\n    if (len \\u003E d.maxLineLength) {\\n      d.maxLineLength = len;\\n      d.maxLine = line;\\n    }\\n  });\\n}\\n\\n\\u002F\\u002F BIDI HELPERS\\n\\nfunction iterateBidiSections(order, from, to, f) {\\n  if (!order) { return f(from, to, \\\"ltr\\\", 0) }\\n  var found = false;\\n  for (var i = 0; i \\u003C order.length; ++i) {\\n    var part = order[i];\\n    if (part.from \\u003C to && part.to \\u003E from || from == to && part.to == from) {\\n      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \\\"rtl\\\" : \\\"ltr\\\", i);\\n      found = true;\\n    }\\n  }\\n  if (!found) { f(from, to, \\\"ltr\\\"); }\\n}\\n\\nvar bidiOther = null;\\nfunction getBidiPartAt(order, ch, sticky) {\\n  var found;\\n  bidiOther = null;\\n  for (var i = 0; i \\u003C order.length; ++i) {\\n    var cur = order[i];\\n    if (cur.from \\u003C ch && cur.to \\u003E ch) { return i }\\n    if (cur.to == ch) {\\n      if (cur.from != cur.to && sticky == \\\"before\\\") { found = i; }\\n      else { bidiOther = i; }\\n    }\\n    if (cur.from == ch) {\\n      if (cur.from != cur.to && sticky != \\\"before\\\") { found = i; }\\n      else { bidiOther = i; }\\n    }\\n  }\\n  return found != null ? found : bidiOther\\n}\\n\\n\\u002F\\u002F Bidirectional ordering algorithm\\n\\u002F\\u002F See http:\\u002F\\u002Funicode.org\\u002Freports\\u002Ftr9\\u002Ftr9-13.html for the algorithm\\n\\u002F\\u002F that this (partially) implements.\\n\\n\\u002F\\u002F One-char codes used for character types:\\n\\u002F\\u002F L (L):   Left-to-Right\\n\\u002F\\u002F R (R):   Right-to-Left\\n\\u002F\\u002F r (AL):  Right-to-Left Arabic\\n\\u002F\\u002F 1 (EN):  European Number\\n\\u002F\\u002F + (ES):  European Number Separator\\n\\u002F\\u002F % (ET):  European Number Terminator\\n\\u002F\\u002F n (AN):  Arabic Number\\n\\u002F\\u002F , (CS):  Common Number Separator\\n\\u002F\\u002F m (NSM): Non-Spacing Mark\\n\\u002F\\u002F b (BN):  Boundary Neutral\\n\\u002F\\u002F s (B):   Paragraph Separator\\n\\u002F\\u002F t (S):   Segment Separator\\n\\u002F\\u002F w (WS):  Whitespace\\n\\u002F\\u002F N (ON):  Other Neutrals\\n\\n\\u002F\\u002F Returns null if characters are ordered as they appear\\n\\u002F\\u002F (left-to-right), or an array of sections ({from, to, level}\\n\\u002F\\u002F objects) in the order in which they occur visually.\\nvar bidiOrdering = (function() {\\n  \\u002F\\u002F Character types for codepoints 0 to 0xff\\n  var lowTypes = \\\"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\\\";\\n  \\u002F\\u002F Character types for codepoints 0x600 to 0x6f9\\n  var arabicTypes = \\\"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\\\";\\n  function charType(code) {\\n    if (code \\u003C= 0xf7) { return lowTypes.charAt(code) }\\n    else if (0x590 \\u003C= code && code \\u003C= 0x5f4) { return \\\"R\\\" }\\n    else if (0x600 \\u003C= code && code \\u003C= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\\n    else if (0x6ee \\u003C= code && code \\u003C= 0x8ac) { return \\\"r\\\" }\\n    else if (0x2000 \\u003C= code && code \\u003C= 0x200b) { return \\\"w\\\" }\\n    else if (code == 0x200c) { return \\\"b\\\" }\\n    else { return \\\"L\\\" }\\n  }\\n\\n  var bidiRE = \\u002F[\\\\u0590-\\\\u05f4\\\\u0600-\\\\u06ff\\\\u0700-\\\\u08ac]\\u002F;\\n  var isNeutral = \\u002F[stwN]\\u002F, isStrong = \\u002F[LRr]\\u002F, countsAsLeft = \\u002F[Lb1n]\\u002F, countsAsNum = \\u002F[1n]\\u002F;\\n\\n  function BidiSpan(level, from, to) {\\n    this.level = level;\\n    this.from = from; this.to = to;\\n  }\\n\\n  return function(str, direction) {\\n    var outerType = direction == \\\"ltr\\\" ? \\\"L\\\" : \\\"R\\\";\\n\\n    if (str.length == 0 || direction == \\\"ltr\\\" && !bidiRE.test(str)) { return false }\\n    var len = str.length, types = [];\\n    for (var i = 0; i \\u003C len; ++i)\\n      { types.push(charType(str.charCodeAt(i))); }\\n\\n    \\u002F\\u002F W1. Examine each non-spacing mark (NSM) in the level run, and\\n    \\u002F\\u002F change the type of the NSM to the type of the previous\\n    \\u002F\\u002F character. If the NSM is at the start of the level run, it will\\n    \\u002F\\u002F get the type of sor.\\n    for (var i$1 = 0, prev = outerType; i$1 \\u003C len; ++i$1) {\\n      var type = types[i$1];\\n      if (type == \\\"m\\\") { types[i$1] = prev; }\\n      else { prev = type; }\\n    }\\n\\n    \\u002F\\u002F W2. Search backwards from each instance of a European number\\n    \\u002F\\u002F until the first strong type (R, L, AL, or sor) is found. If an\\n    \\u002F\\u002F AL is found, change the type of the European number to Arabic\\n    \\u002F\\u002F number.\\n    \\u002F\\u002F W3. Change all ALs to R.\\n    for (var i$2 = 0, cur = outerType; i$2 \\u003C len; ++i$2) {\\n      var type$1 = types[i$2];\\n      if (type$1 == \\\"1\\\" && cur == \\\"r\\\") { types[i$2] = \\\"n\\\"; }\\n      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \\\"r\\\") { types[i$2] = \\\"R\\\"; } }\\n    }\\n\\n    \\u002F\\u002F W4. A single European separator between two European numbers\\n    \\u002F\\u002F changes to a European number. A single common separator between\\n    \\u002F\\u002F two numbers of the same type changes to that type.\\n    for (var i$3 = 1, prev$1 = types[0]; i$3 \\u003C len - 1; ++i$3) {\\n      var type$2 = types[i$3];\\n      if (type$2 == \\\"+\\\" && prev$1 == \\\"1\\\" && types[i$3+1] == \\\"1\\\") { types[i$3] = \\\"1\\\"; }\\n      else if (type$2 == \\\",\\\" && prev$1 == types[i$3+1] &&\\n               (prev$1 == \\\"1\\\" || prev$1 == \\\"n\\\")) { types[i$3] = prev$1; }\\n      prev$1 = type$2;\\n    }\\n\\n    \\u002F\\u002F W5. A sequence of European terminators adjacent to European\\n    \\u002F\\u002F numbers changes to all European numbers.\\n    \\u002F\\u002F W6. Otherwise, separators and terminators change to Other\\n    \\u002F\\u002F Neutral.\\n    for (var i$4 = 0; i$4 \\u003C len; ++i$4) {\\n      var type$3 = types[i$4];\\n      if (type$3 == \\\",\\\") { types[i$4] = \\\"N\\\"; }\\n      else if (type$3 == \\\"%\\\") {\\n        var end = (void 0);\\n        for (end = i$4 + 1; end \\u003C len && types[end] == \\\"%\\\"; ++end) {}\\n        var replace = (i$4 && types[i$4-1] == \\\"!\\\") || (end \\u003C len && types[end] == \\\"1\\\") ? \\\"1\\\" : \\\"N\\\";\\n        for (var j = i$4; j \\u003C end; ++j) { types[j] = replace; }\\n        i$4 = end - 1;\\n      }\\n    }\\n\\n    \\u002F\\u002F W7. Search backwards from each instance of a European number\\n    \\u002F\\u002F until the first strong type (R, L, or sor) is found. If an L is\\n    \\u002F\\u002F found, then change the type of the European number to L.\\n    for (var i$5 = 0, cur$1 = outerType; i$5 \\u003C len; ++i$5) {\\n      var type$4 = types[i$5];\\n      if (cur$1 == \\\"L\\\" && type$4 == \\\"1\\\") { types[i$5] = \\\"L\\\"; }\\n      else if (isStrong.test(type$4)) { cur$1 = type$4; }\\n    }\\n\\n    \\u002F\\u002F N1. A sequence of neutrals takes the direction of the\\n    \\u002F\\u002F surrounding strong text if the text on both sides has the same\\n    \\u002F\\u002F direction. European and Arabic numbers act as if they were R in\\n    \\u002F\\u002F terms of their influence on neutrals. Start-of-level-run (sor)\\n    \\u002F\\u002F and end-of-level-run (eor) are used at level run boundaries.\\n    \\u002F\\u002F N2. Any remaining neutrals take the embedding direction.\\n    for (var i$6 = 0; i$6 \\u003C len; ++i$6) {\\n      if (isNeutral.test(types[i$6])) {\\n        var end$1 = (void 0);\\n        for (end$1 = i$6 + 1; end$1 \\u003C len && isNeutral.test(types[end$1]); ++end$1) {}\\n        var before = (i$6 ? types[i$6-1] : outerType) == \\\"L\\\";\\n        var after = (end$1 \\u003C len ? types[end$1] : outerType) == \\\"L\\\";\\n        var replace$1 = before == after ? (before ? \\\"L\\\" : \\\"R\\\") : outerType;\\n        for (var j$1 = i$6; j$1 \\u003C end$1; ++j$1) { types[j$1] = replace$1; }\\n        i$6 = end$1 - 1;\\n      }\\n    }\\n\\n    \\u002F\\u002F Here we depart from the documented algorithm, in order to avoid\\n    \\u002F\\u002F building up an actual levels array. Since there are only three\\n    \\u002F\\u002F levels (0, 1, 2) in an implementation that doesn't take\\n    \\u002F\\u002F explicit embedding into account, we can build up the order on\\n    \\u002F\\u002F the fly, without following the level-based algorithm.\\n    var order = [], m;\\n    for (var i$7 = 0; i$7 \\u003C len;) {\\n      if (countsAsLeft.test(types[i$7])) {\\n        var start = i$7;\\n        for (++i$7; i$7 \\u003C len && countsAsLeft.test(types[i$7]); ++i$7) {}\\n        order.push(new BidiSpan(0, start, i$7));\\n      } else {\\n        var pos = i$7, at = order.length;\\n        for (++i$7; i$7 \\u003C len && types[i$7] != \\\"L\\\"; ++i$7) {}\\n        for (var j$2 = pos; j$2 \\u003C i$7;) {\\n          if (countsAsNum.test(types[j$2])) {\\n            if (pos \\u003C j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\\n            var nstart = j$2;\\n            for (++j$2; j$2 \\u003C i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\\n            order.splice(at, 0, new BidiSpan(2, nstart, j$2));\\n            pos = j$2;\\n          } else { ++j$2; }\\n        }\\n        if (pos \\u003C i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\\n      }\\n    }\\n    if (direction == \\\"ltr\\\") {\\n      if (order[0].level == 1 && (m = str.match(\\u002F^\\\\s+\\u002F))) {\\n        order[0].from = m[0].length;\\n        order.unshift(new BidiSpan(0, 0, m[0].length));\\n      }\\n      if (lst(order).level == 1 && (m = str.match(\\u002F\\\\s+$\\u002F))) {\\n        lst(order).to -= m[0].length;\\n        order.push(new BidiSpan(0, len - m[0].length, len));\\n      }\\n    }\\n\\n    return direction == \\\"rtl\\\" ? order.reverse() : order\\n  }\\n})();\\n\\n\\u002F\\u002F Get the bidi ordering for the given line (and cache it). Returns\\n\\u002F\\u002F false for lines that are fully left-to-right, and an array of\\n\\u002F\\u002F BidiSpan objects otherwise.\\nfunction getOrder(line, direction) {\\n  var order = line.order;\\n  if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\\n  return order\\n}\\n\\n\\u002F\\u002F EVENT HANDLING\\n\\n\\u002F\\u002F Lightweight event framework. on\\u002Foff also work on DOM nodes,\\n\\u002F\\u002F registering native DOM handlers.\\n\\nvar noHandlers = [];\\n\\nvar on = function(emitter, type, f) {\\n  if (emitter.addEventListener) {\\n    emitter.addEventListener(type, f, false);\\n  } else if (emitter.attachEvent) {\\n    emitter.attachEvent(\\\"on\\\" + type, f);\\n  } else {\\n    var map$$1 = emitter._handlers || (emitter._handlers = {});\\n    map$$1[type] = (map$$1[type] || noHandlers).concat(f);\\n  }\\n};\\n\\nfunction getHandlers(emitter, type) {\\n  return emitter._handlers && emitter._handlers[type] || noHandlers\\n}\\n\\nfunction off(emitter, type, f) {\\n  if (emitter.removeEventListener) {\\n    emitter.removeEventListener(type, f, false);\\n  } else if (emitter.detachEvent) {\\n    emitter.detachEvent(\\\"on\\\" + type, f);\\n  } else {\\n    var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\\n    if (arr) {\\n      var index = indexOf(arr, f);\\n      if (index \\u003E -1)\\n        { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\\n    }\\n  }\\n}\\n\\nfunction signal(emitter, type \\u002F*, values...*\\u002F) {\\n  var handlers = getHandlers(emitter, type);\\n  if (!handlers.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2);\\n  for (var i = 0; i \\u003C handlers.length; ++i) { handlers[i].apply(null, args); }\\n}\\n\\n\\u002F\\u002F The DOM events that CodeMirror handles can be overridden by\\n\\u002F\\u002F registering a (non-DOM) handler on the editor for the event name,\\n\\u002F\\u002F and preventDefault-ing the event in that handler.\\nfunction signalDOMEvent(cm, e, override) {\\n  if (typeof e == \\\"string\\\")\\n    { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\\n  signal(cm, override || e.type, cm, e);\\n  return e_defaultPrevented(e) || e.codemirrorIgnore\\n}\\n\\nfunction signalCursorActivity(cm) {\\n  var arr = cm._handlers && cm._handlers.cursorActivity;\\n  if (!arr) { return }\\n  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\\n  for (var i = 0; i \\u003C arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\\n    { set.push(arr[i]); } }\\n}\\n\\nfunction hasHandler(emitter, type) {\\n  return getHandlers(emitter, type).length \\u003E 0\\n}\\n\\n\\u002F\\u002F Add on and off methods to a constructor's prototype, to make\\n\\u002F\\u002F registering events on such objects more convenient.\\nfunction eventMixin(ctor) {\\n  ctor.prototype.on = function(type, f) {on(this, type, f);};\\n  ctor.prototype.off = function(type, f) {off(this, type, f);};\\n}\\n\\n\\u002F\\u002F Due to the fact that we still support jurassic IE versions, some\\n\\u002F\\u002F compatibility wrappers are needed.\\n\\nfunction e_preventDefault(e) {\\n  if (e.preventDefault) { e.preventDefault(); }\\n  else { e.returnValue = false; }\\n}\\nfunction e_stopPropagation(e) {\\n  if (e.stopPropagation) { e.stopPropagation(); }\\n  else { e.cancelBubble = true; }\\n}\\nfunction e_defaultPrevented(e) {\\n  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\\n}\\nfunction e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\\n\\nfunction e_target(e) {return e.target || e.srcElement}\\nfunction e_button(e) {\\n  var b = e.which;\\n  if (b == null) {\\n    if (e.button & 1) { b = 1; }\\n    else if (e.button & 2) { b = 3; }\\n    else if (e.button & 4) { b = 2; }\\n  }\\n  if (mac && e.ctrlKey && b == 1) { b = 3; }\\n  return b\\n}\\n\\n\\u002F\\u002F Detect drag-and-drop\\nvar dragAndDrop = function() {\\n  \\u002F\\u002F There is *some* kind of drag-and-drop support in IE6-8, but I\\n  \\u002F\\u002F couldn't get it to work yet.\\n  if (ie && ie_version \\u003C 9) { return false }\\n  var div = elt('div');\\n  return \\\"draggable\\\" in div || \\\"dragDrop\\\" in div\\n}();\\n\\nvar zwspSupported;\\nfunction zeroWidthElement(measure) {\\n  if (zwspSupported == null) {\\n    var test = elt(\\\"span\\\", \\\"\\\\u200b\\\");\\n    removeChildrenAndAdd(measure, elt(\\\"span\\\", [test, document.createTextNode(\\\"x\\\")]));\\n    if (measure.firstChild.offsetHeight != 0)\\n      { zwspSupported = test.offsetWidth \\u003C= 1 && test.offsetHeight \\u003E 2 && !(ie && ie_version \\u003C 8); }\\n  }\\n  var node = zwspSupported ? elt(\\\"span\\\", \\\"\\\\u200b\\\") :\\n    elt(\\\"span\\\", \\\"\\\\u00a0\\\", null, \\\"display: inline-block; width: 1px; margin-right: -1px\\\");\\n  node.setAttribute(\\\"cm-text\\\", \\\"\\\");\\n  return node\\n}\\n\\n\\u002F\\u002F Feature-detect IE's crummy client rect reporting for bidi text\\nvar badBidiRects;\\nfunction hasBadBidiRects(measure) {\\n  if (badBidiRects != null) { return badBidiRects }\\n  var txt = removeChildrenAndAdd(measure, document.createTextNode(\\\"A\\\\u062eA\\\"));\\n  var r0 = range(txt, 0, 1).getBoundingClientRect();\\n  var r1 = range(txt, 1, 2).getBoundingClientRect();\\n  removeChildren(measure);\\n  if (!r0 || r0.left == r0.right) { return false } \\u002F\\u002F Safari returns null in some cases (#2780)\\n  return badBidiRects = (r1.right - r0.right \\u003C 3)\\n}\\n\\n\\u002F\\u002F See if \\\"\\\".split is the broken IE version, if so, provide an\\n\\u002F\\u002F alternative way to split lines.\\nvar splitLinesAuto = \\\"\\\\n\\\\nb\\\".split(\\u002F\\\\n\\u002F).length != 3 ? function (string) {\\n  var pos = 0, result = [], l = string.length;\\n  while (pos \\u003C= l) {\\n    var nl = string.indexOf(\\\"\\\\n\\\", pos);\\n    if (nl == -1) { nl = string.length; }\\n    var line = string.slice(pos, string.charAt(nl - 1) == \\\"\\\\r\\\" ? nl - 1 : nl);\\n    var rt = line.indexOf(\\\"\\\\r\\\");\\n    if (rt != -1) {\\n      result.push(line.slice(0, rt));\\n      pos += rt + 1;\\n    } else {\\n      result.push(line);\\n      pos = nl + 1;\\n    }\\n  }\\n  return result\\n} : function (string) { return string.split(\\u002F\\\\r\\\\n?|\\\\n\\u002F); };\\n\\nvar hasSelection = window.getSelection ? function (te) {\\n  try { return te.selectionStart != te.selectionEnd }\\n  catch(e) { return false }\\n} : function (te) {\\n  var range$$1;\\n  try {range$$1 = te.ownerDocument.selection.createRange();}\\n  catch(e) {}\\n  if (!range$$1 || range$$1.parentElement() != te) { return false }\\n  return range$$1.compareEndPoints(\\\"StartToEnd\\\", range$$1) != 0\\n};\\n\\nvar hasCopyEvent = (function () {\\n  var e = elt(\\\"div\\\");\\n  if (\\\"oncopy\\\" in e) { return true }\\n  e.setAttribute(\\\"oncopy\\\", \\\"return;\\\");\\n  return typeof e.oncopy == \\\"function\\\"\\n})();\\n\\nvar badZoomedRects = null;\\nfunction hasBadZoomedRects(measure) {\\n  if (badZoomedRects != null) { return badZoomedRects }\\n  var node = removeChildrenAndAdd(measure, elt(\\\"span\\\", \\\"x\\\"));\\n  var normal = node.getBoundingClientRect();\\n  var fromRange = range(node, 0, 1).getBoundingClientRect();\\n  return badZoomedRects = Math.abs(normal.left - fromRange.left) \\u003E 1\\n}\\n\\n\\u002F\\u002F Known modes, by name and by MIME\\nvar modes = {};\\nvar mimeModes = {};\\n\\n\\u002F\\u002F Extra arguments are stored as the mode's dependencies, which is\\n\\u002F\\u002F used by (legacy) mechanisms like loadmode.js to automatically\\n\\u002F\\u002F load a mode. (Preferred mechanism is the require\\u002Fdefine calls.)\\nfunction defineMode(name, mode) {\\n  if (arguments.length \\u003E 2)\\n    { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\\n  modes[name] = mode;\\n}\\n\\nfunction defineMIME(mime, spec) {\\n  mimeModes[mime] = spec;\\n}\\n\\n\\u002F\\u002F Given a MIME type, a {name, ...options} config object, or a name\\n\\u002F\\u002F string, return a mode config object.\\nfunction resolveMode(spec) {\\n  if (typeof spec == \\\"string\\\" && mimeModes.hasOwnProperty(spec)) {\\n    spec = mimeModes[spec];\\n  } else if (spec && typeof spec.name == \\\"string\\\" && mimeModes.hasOwnProperty(spec.name)) {\\n    var found = mimeModes[spec.name];\\n    if (typeof found == \\\"string\\\") { found = {name: found}; }\\n    spec = createObj(found, spec);\\n    spec.name = found.name;\\n  } else if (typeof spec == \\\"string\\\" && \\u002F^[\\\\w\\\\-]+\\\\\\u002F[\\\\w\\\\-]+\\\\+xml$\\u002F.test(spec)) {\\n    return resolveMode(\\\"application\\u002Fxml\\\")\\n  } else if (typeof spec == \\\"string\\\" && \\u002F^[\\\\w\\\\-]+\\\\\\u002F[\\\\w\\\\-]+\\\\+json$\\u002F.test(spec)) {\\n    return resolveMode(\\\"application\\u002Fjson\\\")\\n  }\\n  if (typeof spec == \\\"string\\\") { return {name: spec} }\\n  else { return spec || {name: \\\"null\\\"} }\\n}\\n\\n\\u002F\\u002F Given a mode spec (anything that resolveMode accepts), find and\\n\\u002F\\u002F initialize an actual mode object.\\nfunction getMode(options, spec) {\\n  spec = resolveMode(spec);\\n  var mfactory = modes[spec.name];\\n  if (!mfactory) { return getMode(options, \\\"text\\u002Fplain\\\") }\\n  var modeObj = mfactory(options, spec);\\n  if (modeExtensions.hasOwnProperty(spec.name)) {\\n    var exts = modeExtensions[spec.name];\\n    for (var prop in exts) {\\n      if (!exts.hasOwnProperty(prop)) { continue }\\n      if (modeObj.hasOwnProperty(prop)) { modeObj[\\\"_\\\" + prop] = modeObj[prop]; }\\n      modeObj[prop] = exts[prop];\\n    }\\n  }\\n  modeObj.name = spec.name;\\n  if (spec.helperType) { modeObj.helperType = spec.helperType; }\\n  if (spec.modeProps) { for (var prop$1 in spec.modeProps)\\n    { modeObj[prop$1] = spec.modeProps[prop$1]; } }\\n\\n  return modeObj\\n}\\n\\n\\u002F\\u002F This can be used to attach properties to mode objects from\\n\\u002F\\u002F outside the actual mode definition.\\nvar modeExtensions = {};\\nfunction extendMode(mode, properties) {\\n  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\\n  copyObj(properties, exts);\\n}\\n\\nfunction copyState(mode, state) {\\n  if (state === true) { return state }\\n  if (mode.copyState) { return mode.copyState(state) }\\n  var nstate = {};\\n  for (var n in state) {\\n    var val = state[n];\\n    if (val instanceof Array) { val = val.concat([]); }\\n    nstate[n] = val;\\n  }\\n  return nstate\\n}\\n\\n\\u002F\\u002F Given a mode and a state (for that mode), find the inner mode and\\n\\u002F\\u002F state at the position that the state refers to.\\nfunction innerMode(mode, state) {\\n  var info;\\n  while (mode.innerMode) {\\n    info = mode.innerMode(state);\\n    if (!info || info.mode == mode) { break }\\n    state = info.state;\\n    mode = info.mode;\\n  }\\n  return info || {mode: mode, state: state}\\n}\\n\\nfunction startState(mode, a1, a2) {\\n  return mode.startState ? mode.startState(a1, a2) : true\\n}\\n\\n\\u002F\\u002F STRING STREAM\\n\\n\\u002F\\u002F Fed to the mode parsers, provides helper functions to make\\n\\u002F\\u002F parsers more succinct.\\n\\nvar StringStream = function(string, tabSize, lineOracle) {\\n  this.pos = this.start = 0;\\n  this.string = string;\\n  this.tabSize = tabSize || 8;\\n  this.lastColumnPos = this.lastColumnValue = 0;\\n  this.lineStart = 0;\\n  this.lineOracle = lineOracle;\\n};\\n\\nStringStream.prototype.eol = function () {return this.pos \\u003E= this.string.length};\\nStringStream.prototype.sol = function () {return this.pos == this.lineStart};\\nStringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\\nStringStream.prototype.next = function () {\\n  if (this.pos \\u003C this.string.length)\\n    { return this.string.charAt(this.pos++) }\\n};\\nStringStream.prototype.eat = function (match) {\\n  var ch = this.string.charAt(this.pos);\\n  var ok;\\n  if (typeof match == \\\"string\\\") { ok = ch == match; }\\n  else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\\n  if (ok) {++this.pos; return ch}\\n};\\nStringStream.prototype.eatWhile = function (match) {\\n  var start = this.pos;\\n  while (this.eat(match)){}\\n  return this.pos \\u003E start\\n};\\nStringStream.prototype.eatSpace = function () {\\n    var this$1 = this;\\n\\n  var start = this.pos;\\n  while (\\u002F[\\\\s\\\\u00a0]\\u002F.test(this.string.charAt(this.pos))) { ++this$1.pos; }\\n  return this.pos \\u003E start\\n};\\nStringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\\nStringStream.prototype.skipTo = function (ch) {\\n  var found = this.string.indexOf(ch, this.pos);\\n  if (found \\u003E -1) {this.pos = found; return true}\\n};\\nStringStream.prototype.backUp = function (n) {this.pos -= n;};\\nStringStream.prototype.column = function () {\\n  if (this.lastColumnPos \\u003C this.start) {\\n    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\\n    this.lastColumnPos = this.start;\\n  }\\n  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n};\\nStringStream.prototype.indentation = function () {\\n  return countColumn(this.string, null, this.tabSize) -\\n    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\\n};\\nStringStream.prototype.match = function (pattern, consume, caseInsensitive) {\\n  if (typeof pattern == \\\"string\\\") {\\n    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\\n    var substr = this.string.substr(this.pos, pattern.length);\\n    if (cased(substr) == cased(pattern)) {\\n      if (consume !== false) { this.pos += pattern.length; }\\n      return true\\n    }\\n  } else {\\n    var match = this.string.slice(this.pos).match(pattern);\\n    if (match && match.index \\u003E 0) { return null }\\n    if (match && consume !== false) { this.pos += match[0].length; }\\n    return match\\n  }\\n};\\nStringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\\nStringStream.prototype.hideFirstChars = function (n, inner) {\\n  this.lineStart += n;\\n  try { return inner() }\\n  finally { this.lineStart -= n; }\\n};\\nStringStream.prototype.lookAhead = function (n) {\\n  var oracle = this.lineOracle;\\n  return oracle && oracle.lookAhead(n)\\n};\\nStringStream.prototype.baseToken = function () {\\n  var oracle = this.lineOracle;\\n  return oracle && oracle.baseToken(this.pos)\\n};\\n\\nvar SavedContext = function(state, lookAhead) {\\n  this.state = state;\\n  this.lookAhead = lookAhead;\\n};\\n\\nvar Context = function(doc, state, line, lookAhead) {\\n  this.state = state;\\n  this.doc = doc;\\n  this.line = line;\\n  this.maxLookAhead = lookAhead || 0;\\n  this.baseTokens = null;\\n  this.baseTokenPos = 1;\\n};\\n\\nContext.prototype.lookAhead = function (n) {\\n  var line = this.doc.getLine(this.line + n);\\n  if (line != null && n \\u003E this.maxLookAhead) { this.maxLookAhead = n; }\\n  return line\\n};\\n\\nContext.prototype.baseToken = function (n) {\\n    var this$1 = this;\\n\\n  if (!this.baseTokens) { return null }\\n  while (this.baseTokens[this.baseTokenPos] \\u003C= n)\\n    { this$1.baseTokenPos += 2; }\\n  var type = this.baseTokens[this.baseTokenPos + 1];\\n  return {type: type && type.replace(\\u002F( |^)overlay .*\\u002F, \\\"\\\"),\\n          size: this.baseTokens[this.baseTokenPos] - n}\\n};\\n\\nContext.prototype.nextLine = function () {\\n  this.line++;\\n  if (this.maxLookAhead \\u003E 0) { this.maxLookAhead--; }\\n};\\n\\nContext.fromSaved = function (doc, saved, line) {\\n  if (saved instanceof SavedContext)\\n    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\\n  else\\n    { return new Context(doc, copyState(doc.mode, saved), line) }\\n};\\n\\nContext.prototype.save = function (copy) {\\n  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\\n  return this.maxLookAhead \\u003E 0 ? new SavedContext(state, this.maxLookAhead) : state\\n};\\n\\n\\n\\u002F\\u002F Compute a style array (an array starting with a mode generation\\n\\u002F\\u002F -- for invalidation -- followed by pairs of end positions and\\n\\u002F\\u002F style strings), which is used to highlight the tokens on the\\n\\u002F\\u002F line.\\nfunction highlightLine(cm, line, context, forceToEnd) {\\n  \\u002F\\u002F A styles array always starts with a number identifying the\\n  \\u002F\\u002F mode\\u002Foverlays that it is based on (for easy invalidation).\\n  var st = [cm.state.modeGen], lineClasses = {};\\n  \\u002F\\u002F Compute the base array of styles\\n  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\\n          lineClasses, forceToEnd);\\n  var state = context.state;\\n\\n  \\u002F\\u002F Run overlays, adjust style array.\\n  var loop = function ( o ) {\\n    context.baseTokens = st;\\n    var overlay = cm.state.overlays[o], i = 1, at = 0;\\n    context.state = true;\\n    runMode(cm, line.text, overlay.mode, context, function (end, style) {\\n      var start = i;\\n      \\u002F\\u002F Ensure there's a token end at the current position, and that i points at it\\n      while (at \\u003C end) {\\n        var i_end = st[i];\\n        if (i_end \\u003E end)\\n          { st.splice(i, 1, end, st[i+1], i_end); }\\n        i += 2;\\n        at = Math.min(end, i_end);\\n      }\\n      if (!style) { return }\\n      if (overlay.opaque) {\\n        st.splice(start, i - start, end, \\\"overlay \\\" + style);\\n        i = start + 2;\\n      } else {\\n        for (; start \\u003C i; start += 2) {\\n          var cur = st[start+1];\\n          st[start+1] = (cur ? cur + \\\" \\\" : \\\"\\\") + \\\"overlay \\\" + style;\\n        }\\n      }\\n    }, lineClasses);\\n    context.state = state;\\n    context.baseTokens = null;\\n    context.baseTokenPos = 1;\\n  };\\n\\n  for (var o = 0; o \\u003C cm.state.overlays.length; ++o) loop( o );\\n\\n  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\\n}\\n\\nfunction getLineStyles(cm, line, updateFrontier) {\\n  if (!line.styles || line.styles[0] != cm.state.modeGen) {\\n    var context = getContextBefore(cm, lineNo(line));\\n    var resetState = line.text.length \\u003E cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\\n    var result = highlightLine(cm, line, context);\\n    if (resetState) { context.state = resetState; }\\n    line.stateAfter = context.save(!resetState);\\n    line.styles = result.styles;\\n    if (result.classes) { line.styleClasses = result.classes; }\\n    else if (line.styleClasses) { line.styleClasses = null; }\\n    if (updateFrontier === cm.doc.highlightFrontier)\\n      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\\n  }\\n  return line.styles\\n}\\n\\nfunction getContextBefore(cm, n, precise) {\\n  var doc = cm.doc, display = cm.display;\\n  if (!doc.mode.startState) { return new Context(doc, true, n) }\\n  var start = findStartLine(cm, n, precise);\\n  var saved = start \\u003E doc.first && getLine(doc, start - 1).stateAfter;\\n  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\\n\\n  doc.iter(start, n, function (line) {\\n    processLine(cm, line.text, context);\\n    var pos = context.line;\\n    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos \\u003E= display.viewFrom && pos \\u003C display.viewTo ? context.save() : null;\\n    context.nextLine();\\n  });\\n  if (precise) { doc.modeFrontier = context.line; }\\n  return context\\n}\\n\\n\\u002F\\u002F Lightweight form of highlight -- proceed over this line and\\n\\u002F\\u002F update state, but don't save a style array. Used for lines that\\n\\u002F\\u002F aren't currently visible.\\nfunction processLine(cm, text, context, startAt) {\\n  var mode = cm.doc.mode;\\n  var stream = new StringStream(text, cm.options.tabSize, context);\\n  stream.start = stream.pos = startAt || 0;\\n  if (text == \\\"\\\") { callBlankLine(mode, context.state); }\\n  while (!stream.eol()) {\\n    readToken(mode, stream, context.state);\\n    stream.start = stream.pos;\\n  }\\n}\\n\\nfunction callBlankLine(mode, state) {\\n  if (mode.blankLine) { return mode.blankLine(state) }\\n  if (!mode.innerMode) { return }\\n  var inner = innerMode(mode, state);\\n  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\\n}\\n\\nfunction readToken(mode, stream, state, inner) {\\n  for (var i = 0; i \\u003C 10; i++) {\\n    if (inner) { inner[0] = innerMode(mode, state).mode; }\\n    var style = mode.token(stream, state);\\n    if (stream.pos \\u003E stream.start) { return style }\\n  }\\n  throw new Error(\\\"Mode \\\" + mode.name + \\\" failed to advance stream.\\\")\\n}\\n\\nvar Token = function(stream, type, state) {\\n  this.start = stream.start; this.end = stream.pos;\\n  this.string = stream.current();\\n  this.type = type || null;\\n  this.state = state;\\n};\\n\\n\\u002F\\u002F Utility for getTokenAt and getLineTokens\\nfunction takeToken(cm, pos, precise, asArray) {\\n  var doc = cm.doc, mode = doc.mode, style;\\n  pos = clipPos(doc, pos);\\n  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\\n  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\\n  if (asArray) { tokens = []; }\\n  while ((asArray || stream.pos \\u003C pos.ch) && !stream.eol()) {\\n    stream.start = stream.pos;\\n    style = readToken(mode, stream, context.state);\\n    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\\n  }\\n  return asArray ? tokens : new Token(stream, style, context.state)\\n}\\n\\nfunction extractLineClasses(type, output) {\\n  if (type) { for (;;) {\\n    var lineClass = type.match(\\u002F(?:^|\\\\s+)line-(background-)?(\\\\S+)\\u002F);\\n    if (!lineClass) { break }\\n    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\\n    var prop = lineClass[1] ? \\\"bgClass\\\" : \\\"textClass\\\";\\n    if (output[prop] == null)\\n      { output[prop] = lineClass[2]; }\\n    else if (!(new RegExp(\\\"(?:^|\\\\s)\\\" + lineClass[2] + \\\"(?:$|\\\\s)\\\")).test(output[prop]))\\n      { output[prop] += \\\" \\\" + lineClass[2]; }\\n  } }\\n  return type\\n}\\n\\n\\u002F\\u002F Run the given mode's parser over a line, calling f for each token.\\nfunction runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\\n  var flattenSpans = mode.flattenSpans;\\n  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\\n  var curStart = 0, curStyle = null;\\n  var stream = new StringStream(text, cm.options.tabSize, context), style;\\n  var inner = cm.options.addModeClass && [null];\\n  if (text == \\\"\\\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\\n  while (!stream.eol()) {\\n    if (stream.pos \\u003E cm.options.maxHighlightLength) {\\n      flattenSpans = false;\\n      if (forceToEnd) { processLine(cm, text, context, stream.pos); }\\n      stream.pos = text.length;\\n      style = null;\\n    } else {\\n      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\\n    }\\n    if (inner) {\\n      var mName = inner[0].name;\\n      if (mName) { style = \\\"m-\\\" + (style ? mName + \\\" \\\" + style : mName); }\\n    }\\n    if (!flattenSpans || curStyle != style) {\\n      while (curStart \\u003C stream.start) {\\n        curStart = Math.min(stream.start, curStart + 5000);\\n        f(curStart, curStyle);\\n      }\\n      curStyle = style;\\n    }\\n    stream.start = stream.pos;\\n  }\\n  while (curStart \\u003C stream.pos) {\\n    \\u002F\\u002F Webkit seems to refuse to render text nodes longer than 57444\\n    \\u002F\\u002F characters, and returns inaccurate measurements in nodes\\n    \\u002F\\u002F starting around 5000 chars.\\n    var pos = Math.min(stream.pos, curStart + 5000);\\n    f(pos, curStyle);\\n    curStart = pos;\\n  }\\n}\\n\\n\\u002F\\u002F Finds the line to start with when starting a parse. Tries to\\n\\u002F\\u002F find a line with a stateAfter, so that it can start with a\\n\\u002F\\u002F valid state. If that fails, it returns the line with the\\n\\u002F\\u002F smallest indentation, which tends to need the least context to\\n\\u002F\\u002F parse correctly.\\nfunction findStartLine(cm, n, precise) {\\n  var minindent, minline, doc = cm.doc;\\n  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\\n  for (var search = n; search \\u003E lim; --search) {\\n    if (search \\u003C= doc.first) { return doc.first }\\n    var line = getLine(doc, search - 1), after = line.stateAfter;\\n    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) \\u003C= doc.modeFrontier))\\n      { return search }\\n    var indented = countColumn(line.text, null, cm.options.tabSize);\\n    if (minline == null || minindent \\u003E indented) {\\n      minline = search - 1;\\n      minindent = indented;\\n    }\\n  }\\n  return minline\\n}\\n\\nfunction retreatFrontier(doc, n) {\\n  doc.modeFrontier = Math.min(doc.modeFrontier, n);\\n  if (doc.highlightFrontier \\u003C n - 10) { return }\\n  var start = doc.first;\\n  for (var line = n - 1; line \\u003E start; line--) {\\n    var saved = getLine(doc, line).stateAfter;\\n    \\u002F\\u002F change is on 3\\n    \\u002F\\u002F state on line 1 looked ahead 2 -- so saw 3\\n    \\u002F\\u002F test 1 + 2 \\u003C 3 should cover this\\n    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead \\u003C n)) {\\n      start = line + 1;\\n      break\\n    }\\n  }\\n  doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\\n}\\n\\n\\u002F\\u002F LINE DATA STRUCTURE\\n\\n\\u002F\\u002F Line objects. These hold state related to a line, including\\n\\u002F\\u002F highlighting info (the styles array).\\nvar Line = function(text, markedSpans, estimateHeight) {\\n  this.text = text;\\n  attachMarkedSpans(this, markedSpans);\\n  this.height = estimateHeight ? estimateHeight(this) : 1;\\n};\\n\\nLine.prototype.lineNo = function () { return lineNo(this) };\\neventMixin(Line);\\n\\n\\u002F\\u002F Change the content (text, markers) of a line. Automatically\\n\\u002F\\u002F invalidates cached information and tries to re-estimate the\\n\\u002F\\u002F line's height.\\nfunction updateLine(line, text, markedSpans, estimateHeight) {\\n  line.text = text;\\n  if (line.stateAfter) { line.stateAfter = null; }\\n  if (line.styles) { line.styles = null; }\\n  if (line.order != null) { line.order = null; }\\n  detachMarkedSpans(line);\\n  attachMarkedSpans(line, markedSpans);\\n  var estHeight = estimateHeight ? estimateHeight(line) : 1;\\n  if (estHeight != line.height) { updateLineHeight(line, estHeight); }\\n}\\n\\n\\u002F\\u002F Detach a line from the document tree and its markers.\\nfunction cleanUpLine(line) {\\n  line.parent = null;\\n  detachMarkedSpans(line);\\n}\\n\\n\\u002F\\u002F Convert a style as returned by a mode (either null, or a string\\n\\u002F\\u002F containing one or more styles) to a CSS style. This is cached,\\n\\u002F\\u002F and also looks for line-wide styles.\\nvar styleToClassCache = {};\\nvar styleToClassCacheWithMode = {};\\nfunction interpretTokenStyle(style, options) {\\n  if (!style || \\u002F^\\\\s*$\\u002F.test(style)) { return null }\\n  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\\n  return cache[style] ||\\n    (cache[style] = style.replace(\\u002F\\\\S+\\u002Fg, \\\"cm-$&\\\"))\\n}\\n\\n\\u002F\\u002F Render the DOM representation of the text of a line. Also builds\\n\\u002F\\u002F up a 'line map', which points at the DOM nodes that represent\\n\\u002F\\u002F specific stretches of text, and is used by the measuring code.\\n\\u002F\\u002F The returned object contains the DOM node, this map, and\\n\\u002F\\u002F information about line-wide styles that were set by the mode.\\nfunction buildLineContent(cm, lineView) {\\n  \\u002F\\u002F The padding-right forces the element to have a 'border', which\\n  \\u002F\\u002F is needed on Webkit to be able to get line-level bounding\\n  \\u002F\\u002F rectangles for it (in measureChar).\\n  var content = eltP(\\\"span\\\", null, null, webkit ? \\\"padding-right: .1px\\\" : null);\\n  var builder = {pre: eltP(\\\"pre\\\", [content], \\\"CodeMirror-line\\\"), content: content,\\n                 col: 0, pos: 0, cm: cm,\\n                 trailingSpace: false,\\n                 splitSpaces: (ie || webkit) && cm.getOption(\\\"lineWrapping\\\")};\\n  lineView.measure = {};\\n\\n  \\u002F\\u002F Iterate over the logical lines that make up this visual line.\\n  for (var i = 0; i \\u003C= (lineView.rest ? lineView.rest.length : 0); i++) {\\n    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\\n    builder.pos = 0;\\n    builder.addToken = buildToken;\\n    \\u002F\\u002F Optionally wire in some hacks into the token-rendering\\n    \\u002F\\u002F algorithm, to deal with browser quirks.\\n    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\\n      { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\\n    builder.map = [];\\n    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\\n    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\\n    if (line.styleClasses) {\\n      if (line.styleClasses.bgClass)\\n        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \\\"\\\"); }\\n      if (line.styleClasses.textClass)\\n        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \\\"\\\"); }\\n    }\\n\\n    \\u002F\\u002F Ensure at least a single node is present, for measuring.\\n    if (builder.map.length == 0)\\n      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\\n\\n    \\u002F\\u002F Store the map and a cache object for the current logical line\\n    if (i == 0) {\\n      lineView.measure.map = builder.map;\\n      lineView.measure.cache = {};\\n    } else {\\n      (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\\n      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\\n    }\\n  }\\n\\n  \\u002F\\u002F See issue #2901\\n  if (webkit) {\\n    var last = builder.content.lastChild;\\n    if (\\u002F\\\\bcm-tab\\\\b\\u002F.test(last.className) || (last.querySelector && last.querySelector(\\\".cm-tab\\\")))\\n      { builder.content.className = \\\"cm-tab-wrap-hack\\\"; }\\n  }\\n\\n  signal(cm, \\\"renderLine\\\", cm, lineView.line, builder.pre);\\n  if (builder.pre.className)\\n    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \\\"\\\"); }\\n\\n  return builder\\n}\\n\\nfunction defaultSpecialCharPlaceholder(ch) {\\n  var token = elt(\\\"span\\\", \\\"\\\\u2022\\\", \\\"cm-invalidchar\\\");\\n  token.title = \\\"\\\\\\\\u\\\" + ch.charCodeAt(0).toString(16);\\n  token.setAttribute(\\\"aria-label\\\", token.title);\\n  return token\\n}\\n\\n\\u002F\\u002F Build up the DOM representation for a single token, and add it to\\n\\u002F\\u002F the line map. Takes care to render special characters separately.\\nfunction buildToken(builder, text, style, startStyle, endStyle, title, css) {\\n  if (!text) { return }\\n  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\\n  var special = builder.cm.state.specialChars, mustWrap = false;\\n  var content;\\n  if (!special.test(text)) {\\n    builder.col += text.length;\\n    content = document.createTextNode(displayText);\\n    builder.map.push(builder.pos, builder.pos + text.length, content);\\n    if (ie && ie_version \\u003C 9) { mustWrap = true; }\\n    builder.pos += text.length;\\n  } else {\\n    content = document.createDocumentFragment();\\n    var pos = 0;\\n    while (true) {\\n      special.lastIndex = pos;\\n      var m = special.exec(text);\\n      var skipped = m ? m.index - pos : text.length - pos;\\n      if (skipped) {\\n        var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\\n        if (ie && ie_version \\u003C 9) { content.appendChild(elt(\\\"span\\\", [txt])); }\\n        else { content.appendChild(txt); }\\n        builder.map.push(builder.pos, builder.pos + skipped, txt);\\n        builder.col += skipped;\\n        builder.pos += skipped;\\n      }\\n      if (!m) { break }\\n      pos += skipped + 1;\\n      var txt$1 = (void 0);\\n      if (m[0] == \\\"\\\\t\\\") {\\n        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\\n        txt$1 = content.appendChild(elt(\\\"span\\\", spaceStr(tabWidth), \\\"cm-tab\\\"));\\n        txt$1.setAttribute(\\\"role\\\", \\\"presentation\\\");\\n        txt$1.setAttribute(\\\"cm-text\\\", \\\"\\\\t\\\");\\n        builder.col += tabWidth;\\n      } else if (m[0] == \\\"\\\\r\\\" || m[0] == \\\"\\\\n\\\") {\\n        txt$1 = content.appendChild(elt(\\\"span\\\", m[0] == \\\"\\\\r\\\" ? \\\"\\\\u240d\\\" : \\\"\\\\u2424\\\", \\\"cm-invalidchar\\\"));\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0]);\\n        builder.col += 1;\\n      } else {\\n        txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\\n        txt$1.setAttribute(\\\"cm-text\\\", m[0]);\\n        if (ie && ie_version \\u003C 9) { content.appendChild(elt(\\\"span\\\", [txt$1])); }\\n        else { content.appendChild(txt$1); }\\n        builder.col += 1;\\n      }\\n      builder.map.push(builder.pos, builder.pos + 1, txt$1);\\n      builder.pos++;\\n    }\\n  }\\n  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\\n  if (style || startStyle || endStyle || mustWrap || css) {\\n    var fullStyle = style || \\\"\\\";\\n    if (startStyle) { fullStyle += startStyle; }\\n    if (endStyle) { fullStyle += endStyle; }\\n    var token = elt(\\\"span\\\", [content], fullStyle, css);\\n    if (title) { token.title = title; }\\n    return builder.content.appendChild(token)\\n  }\\n  builder.content.appendChild(content);\\n}\\n\\nfunction splitSpaces(text, trailingBefore) {\\n  if (text.length \\u003E 1 && !\\u002F  \\u002F.test(text)) { return text }\\n  var spaceBefore = trailingBefore, result = \\\"\\\";\\n  for (var i = 0; i \\u003C text.length; i++) {\\n    var ch = text.charAt(i);\\n    if (ch == \\\" \\\" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\\n      { ch = \\\"\\\\u00a0\\\"; }\\n    result += ch;\\n    spaceBefore = ch == \\\" \\\";\\n  }\\n  return result\\n}\\n\\n\\u002F\\u002F Work around nonsense dimensions being reported for stretches of\\n\\u002F\\u002F right-to-left text.\\nfunction buildTokenBadBidi(inner, order) {\\n  return function (builder, text, style, startStyle, endStyle, title, css) {\\n    style = style ? style + \\\" cm-force-border\\\" : \\\"cm-force-border\\\";\\n    var start = builder.pos, end = start + text.length;\\n    for (;;) {\\n      \\u002F\\u002F Find the part that overlaps with the start of this text\\n      var part = (void 0);\\n      for (var i = 0; i \\u003C order.length; i++) {\\n        part = order[i];\\n        if (part.to \\u003E start && part.from \\u003C= start) { break }\\n      }\\n      if (part.to \\u003E= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }\\n      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\\n      startStyle = null;\\n      text = text.slice(part.to - start);\\n      start = part.to;\\n    }\\n  }\\n}\\n\\nfunction buildCollapsedSpan(builder, size, marker, ignoreWidget) {\\n  var widget = !ignoreWidget && marker.widgetNode;\\n  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\\n  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\\n    if (!widget)\\n      { widget = builder.content.appendChild(document.createElement(\\\"span\\\")); }\\n    widget.setAttribute(\\\"cm-marker\\\", marker.id);\\n  }\\n  if (widget) {\\n    builder.cm.display.input.setUneditable(widget);\\n    builder.content.appendChild(widget);\\n  }\\n  builder.pos += size;\\n  builder.trailingSpace = false;\\n}\\n\\n\\u002F\\u002F Outputs a number of spans to make up a line, taking highlighting\\n\\u002F\\u002F and marked text into account.\\nfunction insertLineContent(line, builder, styles) {\\n  var spans = line.markedSpans, allText = line.text, at = 0;\\n  if (!spans) {\\n    for (var i$1 = 1; i$1 \\u003C styles.length; i$1+=2)\\n      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\\n    return\\n  }\\n\\n  var len = allText.length, pos = 0, i = 1, text = \\\"\\\", style, css;\\n  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\\n  for (;;) {\\n    if (nextChange == pos) { \\u002F\\u002F Update current marker set\\n      spanStyle = spanEndStyle = spanStartStyle = title = css = \\\"\\\";\\n      collapsed = null; nextChange = Infinity;\\n      var foundBookmarks = [], endStyles = (void 0);\\n      for (var j = 0; j \\u003C spans.length; ++j) {\\n        var sp = spans[j], m = sp.marker;\\n        if (m.type == \\\"bookmark\\\" && sp.from == pos && m.widgetNode) {\\n          foundBookmarks.push(m);\\n        } else if (sp.from \\u003C= pos && (sp.to == null || sp.to \\u003E pos || m.collapsed && sp.to == pos && sp.from == pos)) {\\n          if (sp.to != null && sp.to != pos && nextChange \\u003E sp.to) {\\n            nextChange = sp.to;\\n            spanEndStyle = \\\"\\\";\\n          }\\n          if (m.className) { spanStyle += \\\" \\\" + m.className; }\\n          if (m.css) { css = (css ? css + \\\";\\\" : \\\"\\\") + m.css; }\\n          if (m.startStyle && sp.from == pos) { spanStartStyle += \\\" \\\" + m.startStyle; }\\n          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\\n          if (m.title && !title) { title = m.title; }\\n          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) \\u003C 0))\\n            { collapsed = sp; }\\n        } else if (sp.from \\u003E pos && nextChange \\u003E sp.from) {\\n          nextChange = sp.from;\\n        }\\n      }\\n      if (endStyles) { for (var j$1 = 0; j$1 \\u003C endStyles.length; j$1 += 2)\\n        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \\\" \\\" + endStyles[j$1]; } } }\\n\\n      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 \\u003C foundBookmarks.length; ++j$2)\\n        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\\n      if (collapsed && (collapsed.from || 0) == pos) {\\n        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\\n                           collapsed.marker, collapsed.from == null);\\n        if (collapsed.to == null) { return }\\n        if (collapsed.to == pos) { collapsed = false; }\\n      }\\n    }\\n    if (pos \\u003E= len) { break }\\n\\n    var upto = Math.min(len, nextChange);\\n    while (true) {\\n      if (text) {\\n        var end = pos + text.length;\\n        if (!collapsed) {\\n          var tokenText = end \\u003E upto ? text.slice(0, upto - pos) : text;\\n          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\\n                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \\\"\\\", title, css);\\n        }\\n        if (end \\u003E= upto) {text = text.slice(upto - pos); pos = upto; break}\\n        pos = end;\\n        spanStartStyle = \\\"\\\";\\n      }\\n      text = allText.slice(at, at = styles[i++]);\\n      style = interpretTokenStyle(styles[i++], builder.cm.options);\\n    }\\n  }\\n}\\n\\n\\n\\u002F\\u002F These objects are used to represent the visible (currently drawn)\\n\\u002F\\u002F part of the document. A LineView may correspond to multiple\\n\\u002F\\u002F logical lines, if those are connected by collapsed ranges.\\nfunction LineView(doc, line, lineN) {\\n  \\u002F\\u002F The starting line\\n  this.line = line;\\n  \\u002F\\u002F Continuing lines, if any\\n  this.rest = visualLineContinued(line);\\n  \\u002F\\u002F Number of logical lines in this visual line\\n  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\\n  this.node = this.text = null;\\n  this.hidden = lineIsHidden(doc, line);\\n}\\n\\n\\u002F\\u002F Create a range of LineView objects for the given lines.\\nfunction buildViewArray(cm, from, to) {\\n  var array = [], nextPos;\\n  for (var pos = from; pos \\u003C to; pos = nextPos) {\\n    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\\n    nextPos = pos + view.size;\\n    array.push(view);\\n  }\\n  return array\\n}\\n\\nvar operationGroup = null;\\n\\nfunction pushOperation(op) {\\n  if (operationGroup) {\\n    operationGroup.ops.push(op);\\n  } else {\\n    op.ownsGroup = operationGroup = {\\n      ops: [op],\\n      delayedCallbacks: []\\n    };\\n  }\\n}\\n\\nfunction fireCallbacksForOps(group) {\\n  \\u002F\\u002F Calls delayed callbacks and cursorActivity handlers until no\\n  \\u002F\\u002F new ones appear\\n  var callbacks = group.delayedCallbacks, i = 0;\\n  do {\\n    for (; i \\u003C callbacks.length; i++)\\n      { callbacks[i].call(null); }\\n    for (var j = 0; j \\u003C group.ops.length; j++) {\\n      var op = group.ops[j];\\n      if (op.cursorActivityHandlers)\\n        { while (op.cursorActivityCalled \\u003C op.cursorActivityHandlers.length)\\n          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\\n    }\\n  } while (i \\u003C callbacks.length)\\n}\\n\\nfunction finishOperation(op, endCb) {\\n  var group = op.ownsGroup;\\n  if (!group) { return }\\n\\n  try { fireCallbacksForOps(group); }\\n  finally {\\n    operationGroup = null;\\n    endCb(group);\\n  }\\n}\\n\\nvar orphanDelayedCallbacks = null;\\n\\n\\u002F\\u002F Often, we want to signal events at a point where we are in the\\n\\u002F\\u002F middle of some work, but don't want the handler to start calling\\n\\u002F\\u002F other methods on the editor, which might be in an inconsistent\\n\\u002F\\u002F state or simply not expect any other events to happen.\\n\\u002F\\u002F signalLater looks whether there are any handlers, and schedules\\n\\u002F\\u002F them to be executed when the last operation ends, or, if no\\n\\u002F\\u002F operation is active, when a timeout fires.\\nfunction signalLater(emitter, type \\u002F*, values...*\\u002F) {\\n  var arr = getHandlers(emitter, type);\\n  if (!arr.length) { return }\\n  var args = Array.prototype.slice.call(arguments, 2), list;\\n  if (operationGroup) {\\n    list = operationGroup.delayedCallbacks;\\n  } else if (orphanDelayedCallbacks) {\\n    list = orphanDelayedCallbacks;\\n  } else {\\n    list = orphanDelayedCallbacks = [];\\n    setTimeout(fireOrphanDelayed, 0);\\n  }\\n  var loop = function ( i ) {\\n    list.push(function () { return arr[i].apply(null, args); });\\n  };\\n\\n  for (var i = 0; i \\u003C arr.length; ++i)\\n    loop( i );\\n}\\n\\nfunction fireOrphanDelayed() {\\n  var delayed = orphanDelayedCallbacks;\\n  orphanDelayedCallbacks = null;\\n  for (var i = 0; i \\u003C delayed.length; ++i) { delayed[i](); }\\n}\\n\\n\\u002F\\u002F When an aspect of a line changes, a string is added to\\n\\u002F\\u002F lineView.changes. This updates the relevant part of the line's\\n\\u002F\\u002F DOM structure.\\nfunction updateLineForChanges(cm, lineView, lineN, dims) {\\n  for (var j = 0; j \\u003C lineView.changes.length; j++) {\\n    var type = lineView.changes[j];\\n    if (type == \\\"text\\\") { updateLineText(cm, lineView); }\\n    else if (type == \\\"gutter\\\") { updateLineGutter(cm, lineView, lineN, dims); }\\n    else if (type == \\\"class\\\") { updateLineClasses(cm, lineView); }\\n    else if (type == \\\"widget\\\") { updateLineWidgets(cm, lineView, dims); }\\n  }\\n  lineView.changes = null;\\n}\\n\\n\\u002F\\u002F Lines with gutter elements, widgets or a background class need to\\n\\u002F\\u002F be wrapped, and have the extra elements added to the wrapper div\\nfunction ensureLineWrapped(lineView) {\\n  if (lineView.node == lineView.text) {\\n    lineView.node = elt(\\\"div\\\", null, null, \\\"position: relative\\\");\\n    if (lineView.text.parentNode)\\n      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\\n    lineView.node.appendChild(lineView.text);\\n    if (ie && ie_version \\u003C 8) { lineView.node.style.zIndex = 2; }\\n  }\\n  return lineView.node\\n}\\n\\nfunction updateLineBackground(cm, lineView) {\\n  var cls = lineView.bgClass ? lineView.bgClass + \\\" \\\" + (lineView.line.bgClass || \\\"\\\") : lineView.line.bgClass;\\n  if (cls) { cls += \\\" CodeMirror-linebackground\\\"; }\\n  if (lineView.background) {\\n    if (cls) { lineView.background.className = cls; }\\n    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\\n  } else if (cls) {\\n    var wrap = ensureLineWrapped(lineView);\\n    lineView.background = wrap.insertBefore(elt(\\\"div\\\", null, cls), wrap.firstChild);\\n    cm.display.input.setUneditable(lineView.background);\\n  }\\n}\\n\\n\\u002F\\u002F Wrapper around buildLineContent which will reuse the structure\\n\\u002F\\u002F in display.externalMeasured when possible.\\nfunction getLineContent(cm, lineView) {\\n  var ext = cm.display.externalMeasured;\\n  if (ext && ext.line == lineView.line) {\\n    cm.display.externalMeasured = null;\\n    lineView.measure = ext.measure;\\n    return ext.built\\n  }\\n  return buildLineContent(cm, lineView)\\n}\\n\\n\\u002F\\u002F Redraw the line's text. Interacts with the background and text\\n\\u002F\\u002F classes because the mode may output tokens that influence these\\n\\u002F\\u002F classes.\\nfunction updateLineText(cm, lineView) {\\n  var cls = lineView.text.className;\\n  var built = getLineContent(cm, lineView);\\n  if (lineView.text == lineView.node) { lineView.node = built.pre; }\\n  lineView.text.parentNode.replaceChild(built.pre, lineView.text);\\n  lineView.text = built.pre;\\n  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\\n    lineView.bgClass = built.bgClass;\\n    lineView.textClass = built.textClass;\\n    updateLineClasses(cm, lineView);\\n  } else if (cls) {\\n    lineView.text.className = cls;\\n  }\\n}\\n\\nfunction updateLineClasses(cm, lineView) {\\n  updateLineBackground(cm, lineView);\\n  if (lineView.line.wrapClass)\\n    { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\\n  else if (lineView.node != lineView.text)\\n    { lineView.node.className = \\\"\\\"; }\\n  var textClass = lineView.textClass ? lineView.textClass + \\\" \\\" + (lineView.line.textClass || \\\"\\\") : lineView.line.textClass;\\n  lineView.text.className = textClass || \\\"\\\";\\n}\\n\\nfunction updateLineGutter(cm, lineView, lineN, dims) {\\n  if (lineView.gutter) {\\n    lineView.node.removeChild(lineView.gutter);\\n    lineView.gutter = null;\\n  }\\n  if (lineView.gutterBackground) {\\n    lineView.node.removeChild(lineView.gutterBackground);\\n    lineView.gutterBackground = null;\\n  }\\n  if (lineView.line.gutterClass) {\\n    var wrap = ensureLineWrapped(lineView);\\n    lineView.gutterBackground = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-background \\\" + lineView.line.gutterClass,\\n                                    (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px; width: \\\" + (dims.gutterTotalWidth) + \\\"px\\\"));\\n    cm.display.input.setUneditable(lineView.gutterBackground);\\n    wrap.insertBefore(lineView.gutterBackground, lineView.text);\\n  }\\n  var markers = lineView.line.gutterMarkers;\\n  if (cm.options.lineNumbers || markers) {\\n    var wrap$1 = ensureLineWrapped(lineView);\\n    var gutterWrap = lineView.gutter = elt(\\\"div\\\", null, \\\"CodeMirror-gutter-wrapper\\\", (\\\"left: \\\" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \\\"px\\\"));\\n    cm.display.input.setUneditable(gutterWrap);\\n    wrap$1.insertBefore(gutterWrap, lineView.text);\\n    if (lineView.line.gutterClass)\\n      { gutterWrap.className += \\\" \\\" + lineView.line.gutterClass; }\\n    if (cm.options.lineNumbers && (!markers || !markers[\\\"CodeMirror-linenumbers\\\"]))\\n      { lineView.lineNumber = gutterWrap.appendChild(\\n        elt(\\\"div\\\", lineNumberFor(cm.options, lineN),\\n            \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\",\\n            (\\\"left: \\\" + (dims.gutterLeft[\\\"CodeMirror-linenumbers\\\"]) + \\\"px; width: \\\" + (cm.display.lineNumInnerWidth) + \\\"px\\\"))); }\\n    if (markers) { for (var k = 0; k \\u003C cm.options.gutters.length; ++k) {\\n      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\\n      if (found)\\n        { gutterWrap.appendChild(elt(\\\"div\\\", [found], \\\"CodeMirror-gutter-elt\\\",\\n                                   (\\\"left: \\\" + (dims.gutterLeft[id]) + \\\"px; width: \\\" + (dims.gutterWidth[id]) + \\\"px\\\"))); }\\n    } }\\n  }\\n}\\n\\nfunction updateLineWidgets(cm, lineView, dims) {\\n  if (lineView.alignable) { lineView.alignable = null; }\\n  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\\n    next = node.nextSibling;\\n    if (node.className == \\\"CodeMirror-linewidget\\\")\\n      { lineView.node.removeChild(node); }\\n  }\\n  insertLineWidgets(cm, lineView, dims);\\n}\\n\\n\\u002F\\u002F Build a line's DOM representation from scratch\\nfunction buildLineElement(cm, lineView, lineN, dims) {\\n  var built = getLineContent(cm, lineView);\\n  lineView.text = lineView.node = built.pre;\\n  if (built.bgClass) { lineView.bgClass = built.bgClass; }\\n  if (built.textClass) { lineView.textClass = built.textClass; }\\n\\n  updateLineClasses(cm, lineView);\\n  updateLineGutter(cm, lineView, lineN, dims);\\n  insertLineWidgets(cm, lineView, dims);\\n  return lineView.node\\n}\\n\\n\\u002F\\u002F A lineView may contain multiple logical lines (when merged by\\n\\u002F\\u002F collapsed spans). The widgets for all of them need to be drawn.\\nfunction insertLineWidgets(cm, lineView, dims) {\\n  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\\n  if (lineView.rest) { for (var i = 0; i \\u003C lineView.rest.length; i++)\\n    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\\n}\\n\\nfunction insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\\n  if (!line.widgets) { return }\\n  var wrap = ensureLineWrapped(lineView);\\n  for (var i = 0, ws = line.widgets; i \\u003C ws.length; ++i) {\\n    var widget = ws[i], node = elt(\\\"div\\\", [widget.node], \\\"CodeMirror-linewidget\\\");\\n    if (!widget.handleMouseEvents) { node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\"); }\\n    positionLineWidget(widget, node, lineView, dims);\\n    cm.display.input.setUneditable(node);\\n    if (allowAbove && widget.above)\\n      { wrap.insertBefore(node, lineView.gutter || lineView.text); }\\n    else\\n      { wrap.appendChild(node); }\\n    signalLater(widget, \\\"redraw\\\");\\n  }\\n}\\n\\nfunction positionLineWidget(widget, node, lineView, dims) {\\n  if (widget.noHScroll) {\\n    (lineView.alignable || (lineView.alignable = [])).push(node);\\n    var width = dims.wrapperWidth;\\n    node.style.left = dims.fixedPos + \\\"px\\\";\\n    if (!widget.coverGutter) {\\n      width -= dims.gutterTotalWidth;\\n      node.style.paddingLeft = dims.gutterTotalWidth + \\\"px\\\";\\n    }\\n    node.style.width = width + \\\"px\\\";\\n  }\\n  if (widget.coverGutter) {\\n    node.style.zIndex = 5;\\n    node.style.position = \\\"relative\\\";\\n    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \\\"px\\\"; }\\n  }\\n}\\n\\nfunction widgetHeight(widget) {\\n  if (widget.height != null) { return widget.height }\\n  var cm = widget.doc.cm;\\n  if (!cm) { return 0 }\\n  if (!contains(document.body, widget.node)) {\\n    var parentStyle = \\\"position: relative;\\\";\\n    if (widget.coverGutter)\\n      { parentStyle += \\\"margin-left: -\\\" + cm.display.gutters.offsetWidth + \\\"px;\\\"; }\\n    if (widget.noHScroll)\\n      { parentStyle += \\\"width: \\\" + cm.display.wrapper.clientWidth + \\\"px;\\\"; }\\n    removeChildrenAndAdd(cm.display.measure, elt(\\\"div\\\", [widget.node], null, parentStyle));\\n  }\\n  return widget.height = widget.node.parentNode.offsetHeight\\n}\\n\\n\\u002F\\u002F Return true when the given mouse event happened in a widget\\nfunction eventInWidget(display, e) {\\n  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\\n    if (!n || (n.nodeType == 1 && n.getAttribute(\\\"cm-ignore-events\\\") == \\\"true\\\") ||\\n        (n.parentNode == display.sizer && n != display.mover))\\n      { return true }\\n  }\\n}\\n\\n\\u002F\\u002F POSITION MEASUREMENT\\n\\nfunction paddingTop(display) {return display.lineSpace.offsetTop}\\nfunction paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\\nfunction paddingH(display) {\\n  if (display.cachedPaddingH) { return display.cachedPaddingH }\\n  var e = removeChildrenAndAdd(display.measure, elt(\\\"pre\\\", \\\"x\\\"));\\n  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\\n  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\\n  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\\n  return data\\n}\\n\\nfunction scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\\nfunction displayWidth(cm) {\\n  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\\n}\\nfunction displayHeight(cm) {\\n  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\\n}\\n\\n\\u002F\\u002F Ensure the lineView.wrapping.heights array is populated. This is\\n\\u002F\\u002F an array of bottom offsets for the lines that make up a drawn\\n\\u002F\\u002F line. When lineWrapping is on, there might be more than one\\n\\u002F\\u002F height.\\nfunction ensureLineHeights(cm, lineView, rect) {\\n  var wrapping = cm.options.lineWrapping;\\n  var curWidth = wrapping && displayWidth(cm);\\n  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\\n    var heights = lineView.measure.heights = [];\\n    if (wrapping) {\\n      lineView.measure.width = curWidth;\\n      var rects = lineView.text.firstChild.getClientRects();\\n      for (var i = 0; i \\u003C rects.length - 1; i++) {\\n        var cur = rects[i], next = rects[i + 1];\\n        if (Math.abs(cur.bottom - next.bottom) \\u003E 2)\\n          { heights.push((cur.bottom + next.top) \\u002F 2 - rect.top); }\\n      }\\n    }\\n    heights.push(rect.bottom - rect.top);\\n  }\\n}\\n\\n\\u002F\\u002F Find a line map (mapping character offsets to text nodes) and a\\n\\u002F\\u002F measurement cache for the given line number. (A line view might\\n\\u002F\\u002F contain multiple lines when collapsed ranges are present.)\\nfunction mapFromLineView(lineView, line, lineN) {\\n  if (lineView.line == line)\\n    { return {map: lineView.measure.map, cache: lineView.measure.cache} }\\n  for (var i = 0; i \\u003C lineView.rest.length; i++)\\n    { if (lineView.rest[i] == line)\\n      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\\n  for (var i$1 = 0; i$1 \\u003C lineView.rest.length; i$1++)\\n    { if (lineNo(lineView.rest[i$1]) \\u003E lineN)\\n      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\\n}\\n\\n\\u002F\\u002F Render a line into the hidden node display.externalMeasured. Used\\n\\u002F\\u002F when measurement is needed for a line that's not in the viewport.\\nfunction updateExternalMeasurement(cm, line) {\\n  line = visualLine(line);\\n  var lineN = lineNo(line);\\n  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\\n  view.lineN = lineN;\\n  var built = view.built = buildLineContent(cm, view);\\n  view.text = built.pre;\\n  removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\\n  return view\\n}\\n\\n\\u002F\\u002F Get a {top, bottom, left, right} box (in line-local coordinates)\\n\\u002F\\u002F for a given character.\\nfunction measureChar(cm, line, ch, bias) {\\n  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\\n}\\n\\n\\u002F\\u002F Find a line view that corresponds to the given line number.\\nfunction findViewForLine(cm, lineN) {\\n  if (lineN \\u003E= cm.display.viewFrom && lineN \\u003C cm.display.viewTo)\\n    { return cm.display.view[findViewIndex(cm, lineN)] }\\n  var ext = cm.display.externalMeasured;\\n  if (ext && lineN \\u003E= ext.lineN && lineN \\u003C ext.lineN + ext.size)\\n    { return ext }\\n}\\n\\n\\u002F\\u002F Measurement can be split in two steps, the set-up work that\\n\\u002F\\u002F applies to the whole line, and the measurement of the actual\\n\\u002F\\u002F character. Functions like coordsChar, that need to do a lot of\\n\\u002F\\u002F measurements in a row, can thus ensure that the set-up work is\\n\\u002F\\u002F only done once.\\nfunction prepareMeasureForLine(cm, line) {\\n  var lineN = lineNo(line);\\n  var view = findViewForLine(cm, lineN);\\n  if (view && !view.text) {\\n    view = null;\\n  } else if (view && view.changes) {\\n    updateLineForChanges(cm, view, lineN, getDimensions(cm));\\n    cm.curOp.forceUpdate = true;\\n  }\\n  if (!view)\\n    { view = updateExternalMeasurement(cm, line); }\\n\\n  var info = mapFromLineView(view, line, lineN);\\n  return {\\n    line: line, view: view, rect: null,\\n    map: info.map, cache: info.cache, before: info.before,\\n    hasHeights: false\\n  }\\n}\\n\\n\\u002F\\u002F Given a prepared measurement object, measures the position of an\\n\\u002F\\u002F actual character (or fetches it from the cache).\\nfunction measureCharPrepared(cm, prepared, ch, bias, varHeight) {\\n  if (prepared.before) { ch = -1; }\\n  var key = ch + (bias || \\\"\\\"), found;\\n  if (prepared.cache.hasOwnProperty(key)) {\\n    found = prepared.cache[key];\\n  } else {\\n    if (!prepared.rect)\\n      { prepared.rect = prepared.view.text.getBoundingClientRect(); }\\n    if (!prepared.hasHeights) {\\n      ensureLineHeights(cm, prepared.view, prepared.rect);\\n      prepared.hasHeights = true;\\n    }\\n    found = measureCharInner(cm, prepared, ch, bias);\\n    if (!found.bogus) { prepared.cache[key] = found; }\\n  }\\n  return {left: found.left, right: found.right,\\n          top: varHeight ? found.rtop : found.top,\\n          bottom: varHeight ? found.rbottom : found.bottom}\\n}\\n\\nvar nullRect = {left: 0, right: 0, top: 0, bottom: 0};\\n\\nfunction nodeAndOffsetInLineMap(map$$1, ch, bias) {\\n  var node, start, end, collapse, mStart, mEnd;\\n  \\u002F\\u002F First, search the line map for the text node corresponding to,\\n  \\u002F\\u002F or closest to, the target character.\\n  for (var i = 0; i \\u003C map$$1.length; i += 3) {\\n    mStart = map$$1[i];\\n    mEnd = map$$1[i + 1];\\n    if (ch \\u003C mStart) {\\n      start = 0; end = 1;\\n      collapse = \\\"left\\\";\\n    } else if (ch \\u003C mEnd) {\\n      start = ch - mStart;\\n      end = start + 1;\\n    } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] \\u003E ch) {\\n      end = mEnd - mStart;\\n      start = end - 1;\\n      if (ch \\u003E= mEnd) { collapse = \\\"right\\\"; }\\n    }\\n    if (start != null) {\\n      node = map$$1[i + 2];\\n      if (mStart == mEnd && bias == (node.insertLeft ? \\\"left\\\" : \\\"right\\\"))\\n        { collapse = bias; }\\n      if (bias == \\\"left\\\" && start == 0)\\n        { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\\n          node = map$$1[(i -= 3) + 2];\\n          collapse = \\\"left\\\";\\n        } }\\n      if (bias == \\\"right\\\" && start == mEnd - mStart)\\n        { while (i \\u003C map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\\n          node = map$$1[(i += 3) + 2];\\n          collapse = \\\"right\\\";\\n        } }\\n      break\\n    }\\n  }\\n  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\\n}\\n\\nfunction getUsefulRect(rects, bias) {\\n  var rect = nullRect;\\n  if (bias == \\\"left\\\") { for (var i = 0; i \\u003C rects.length; i++) {\\n    if ((rect = rects[i]).left != rect.right) { break }\\n  } } else { for (var i$1 = rects.length - 1; i$1 \\u003E= 0; i$1--) {\\n    if ((rect = rects[i$1]).left != rect.right) { break }\\n  } }\\n  return rect\\n}\\n\\nfunction measureCharInner(cm, prepared, ch, bias) {\\n  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\\n  var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\\n\\n  var rect;\\n  if (node.nodeType == 3) { \\u002F\\u002F If it is a text node, use a range to retrieve the coordinates.\\n    for (var i$1 = 0; i$1 \\u003C 4; i$1++) { \\u002F\\u002F Retry a maximum of 4 times when nonsense rectangles are returned\\n      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\\n      while (place.coverStart + end \\u003C place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\\n      if (ie && ie_version \\u003C 9 && start == 0 && end == place.coverEnd - place.coverStart)\\n        { rect = node.parentNode.getBoundingClientRect(); }\\n      else\\n        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\\n      if (rect.left || rect.right || start == 0) { break }\\n      end = start;\\n      start = start - 1;\\n      collapse = \\\"right\\\";\\n    }\\n    if (ie && ie_version \\u003C 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\\n  } else { \\u002F\\u002F If it is a widget, simply get the box for the whole widget.\\n    if (start \\u003E 0) { collapse = bias = \\\"right\\\"; }\\n    var rects;\\n    if (cm.options.lineWrapping && (rects = node.getClientRects()).length \\u003E 1)\\n      { rect = rects[bias == \\\"right\\\" ? rects.length - 1 : 0]; }\\n    else\\n      { rect = node.getBoundingClientRect(); }\\n  }\\n  if (ie && ie_version \\u003C 9 && !start && (!rect || !rect.left && !rect.right)) {\\n    var rSpan = node.parentNode.getClientRects()[0];\\n    if (rSpan)\\n      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\\n    else\\n      { rect = nullRect; }\\n  }\\n\\n  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\\n  var mid = (rtop + rbot) \\u002F 2;\\n  var heights = prepared.view.measure.heights;\\n  var i = 0;\\n  for (; i \\u003C heights.length - 1; i++)\\n    { if (mid \\u003C heights[i]) { break } }\\n  var top = i ? heights[i - 1] : 0, bot = heights[i];\\n  var result = {left: (collapse == \\\"right\\\" ? rect.right : rect.left) - prepared.rect.left,\\n                right: (collapse == \\\"left\\\" ? rect.left : rect.right) - prepared.rect.left,\\n                top: top, bottom: bot};\\n  if (!rect.left && !rect.right) { result.bogus = true; }\\n  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\\n\\n  return result\\n}\\n\\n\\u002F\\u002F Work around problem with bounding client rects on ranges being\\n\\u002F\\u002F returned incorrectly when zoomed on IE10 and below.\\nfunction maybeUpdateRectForZooming(measure, rect) {\\n  if (!window.screen || screen.logicalXDPI == null ||\\n      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\\n    { return rect }\\n  var scaleX = screen.logicalXDPI \\u002F screen.deviceXDPI;\\n  var scaleY = screen.logicalYDPI \\u002F screen.deviceYDPI;\\n  return {left: rect.left * scaleX, right: rect.right * scaleX,\\n          top: rect.top * scaleY, bottom: rect.bottom * scaleY}\\n}\\n\\nfunction clearLineMeasurementCacheFor(lineView) {\\n  if (lineView.measure) {\\n    lineView.measure.cache = {};\\n    lineView.measure.heights = null;\\n    if (lineView.rest) { for (var i = 0; i \\u003C lineView.rest.length; i++)\\n      { lineView.measure.caches[i] = {}; } }\\n  }\\n}\\n\\nfunction clearLineMeasurementCache(cm) {\\n  cm.display.externalMeasure = null;\\n  removeChildren(cm.display.lineMeasure);\\n  for (var i = 0; i \\u003C cm.display.view.length; i++)\\n    { clearLineMeasurementCacheFor(cm.display.view[i]); }\\n}\\n\\nfunction clearCaches(cm) {\\n  clearLineMeasurementCache(cm);\\n  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\\n  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\\n  cm.display.lineNumChars = null;\\n}\\n\\nfunction pageScrollX() {\\n  \\u002F\\u002F Work around https:\\u002F\\u002Fbugs.chromium.org\\u002Fp\\u002Fchromium\\u002Fissues\\u002Fdetail?id=489206\\n  \\u002F\\u002F which causes page_Offset and bounding client rects to use\\n  \\u002F\\u002F different reference viewports and invalidate our calculations.\\n  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\\n  return window.pageXOffset || (document.documentElement || document.body).scrollLeft\\n}\\nfunction pageScrollY() {\\n  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\\n  return window.pageYOffset || (document.documentElement || document.body).scrollTop\\n}\\n\\nfunction widgetTopHeight(lineObj) {\\n  var height = 0;\\n  if (lineObj.widgets) { for (var i = 0; i \\u003C lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\\n    { height += widgetHeight(lineObj.widgets[i]); } } }\\n  return height\\n}\\n\\n\\u002F\\u002F Converts a {top, bottom, left, right} box from line-local\\n\\u002F\\u002F coordinates into another coordinate system. Context may be one of\\n\\u002F\\u002F \\\"line\\\", \\\"div\\\" (display.lineDiv), \\\"local\\\".\\u002Fnull (editor), \\\"window\\\",\\n\\u002F\\u002F or \\\"page\\\".\\nfunction intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\\n  if (!includeWidgets) {\\n    var height = widgetTopHeight(lineObj);\\n    rect.top += height; rect.bottom += height;\\n  }\\n  if (context == \\\"line\\\") { return rect }\\n  if (!context) { context = \\\"local\\\"; }\\n  var yOff = heightAtLine(lineObj);\\n  if (context == \\\"local\\\") { yOff += paddingTop(cm.display); }\\n  else { yOff -= cm.display.viewOffset; }\\n  if (context == \\\"page\\\" || context == \\\"window\\\") {\\n    var lOff = cm.display.lineSpace.getBoundingClientRect();\\n    yOff += lOff.top + (context == \\\"window\\\" ? 0 : pageScrollY());\\n    var xOff = lOff.left + (context == \\\"window\\\" ? 0 : pageScrollX());\\n    rect.left += xOff; rect.right += xOff;\\n  }\\n  rect.top += yOff; rect.bottom += yOff;\\n  return rect\\n}\\n\\n\\u002F\\u002F Coverts a box from \\\"div\\\" coords to another coordinate system.\\n\\u002F\\u002F Context may be \\\"window\\\", \\\"page\\\", \\\"div\\\", or \\\"local\\\".\\u002Fnull.\\nfunction fromCoordSystem(cm, coords, context) {\\n  if (context == \\\"div\\\") { return coords }\\n  var left = coords.left, top = coords.top;\\n  \\u002F\\u002F First move into \\\"page\\\" coordinate system\\n  if (context == \\\"page\\\") {\\n    left -= pageScrollX();\\n    top -= pageScrollY();\\n  } else if (context == \\\"local\\\" || !context) {\\n    var localBox = cm.display.sizer.getBoundingClientRect();\\n    left += localBox.left;\\n    top += localBox.top;\\n  }\\n\\n  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\\n  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\\n}\\n\\nfunction charCoords(cm, pos, context, lineObj, bias) {\\n  if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\\n  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\\n}\\n\\n\\u002F\\u002F Returns a box for a given cursor position, which may have an\\n\\u002F\\u002F 'other' property containing the position of the secondary cursor\\n\\u002F\\u002F on a bidi boundary.\\n\\u002F\\u002F A cursor Pos(line, char, \\\"before\\\") is on the same visual line as `char - 1`\\n\\u002F\\u002F and after `char - 1` in writing order of `char - 1`\\n\\u002F\\u002F A cursor Pos(line, char, \\\"after\\\") is on the same visual line as `char`\\n\\u002F\\u002F and before `char` in writing order of `char`\\n\\u002F\\u002F Examples (upper-case letters are RTL, lower-case are LTR):\\n\\u002F\\u002F     Pos(0, 1, ...)\\n\\u002F\\u002F     before   after\\n\\u002F\\u002F ab     a|b     a|b\\n\\u002F\\u002F aB     a|B     aB|\\n\\u002F\\u002F Ab     |Ab     A|b\\n\\u002F\\u002F AB     B|A     B|A\\n\\u002F\\u002F Every position after the last character on a line is considered to stick\\n\\u002F\\u002F to the last character on the line.\\nfunction cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\\n  lineObj = lineObj || getLine(cm.doc, pos.line);\\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\\n  function get(ch, right) {\\n    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \\\"right\\\" : \\\"left\\\", varHeight);\\n    if (right) { m.left = m.right; } else { m.right = m.left; }\\n    return intoCoordSystem(cm, lineObj, m, context)\\n  }\\n  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\\n  if (ch \\u003E= lineObj.text.length) {\\n    ch = lineObj.text.length;\\n    sticky = \\\"before\\\";\\n  } else if (ch \\u003C= 0) {\\n    ch = 0;\\n    sticky = \\\"after\\\";\\n  }\\n  if (!order) { return get(sticky == \\\"before\\\" ? ch - 1 : ch, sticky == \\\"before\\\") }\\n\\n  function getBidi(ch, partPos, invert) {\\n    var part = order[partPos], right = part.level == 1;\\n    return get(invert ? ch - 1 : ch, right != invert)\\n  }\\n  var partPos = getBidiPartAt(order, ch, sticky);\\n  var other = bidiOther;\\n  var val = getBidi(ch, partPos, sticky == \\\"before\\\");\\n  if (other != null) { val.other = getBidi(ch, other, sticky != \\\"before\\\"); }\\n  return val\\n}\\n\\n\\u002F\\u002F Used to cheaply estimate the coordinates for a position. Used for\\n\\u002F\\u002F intermediate scroll updates.\\nfunction estimateCoords(cm, pos) {\\n  var left = 0;\\n  pos = clipPos(cm.doc, pos);\\n  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\\n  var lineObj = getLine(cm.doc, pos.line);\\n  var top = heightAtLine(lineObj) + paddingTop(cm.display);\\n  return {left: left, right: left, top: top, bottom: top + lineObj.height}\\n}\\n\\n\\u002F\\u002F Positions returned by coordsChar contain some extra information.\\n\\u002F\\u002F xRel is the relative x position of the input coordinates compared\\n\\u002F\\u002F to the found position (so xRel \\u003E 0 means the coordinates are to\\n\\u002F\\u002F the right of the character position, for example). When outside\\n\\u002F\\u002F is true, that means the coordinates lie outside the line's\\n\\u002F\\u002F vertical range.\\nfunction PosWithInfo(line, ch, sticky, outside, xRel) {\\n  var pos = Pos(line, ch, sticky);\\n  pos.xRel = xRel;\\n  if (outside) { pos.outside = true; }\\n  return pos\\n}\\n\\n\\u002F\\u002F Compute the character position closest to the given coordinates.\\n\\u002F\\u002F Input must be lineSpace-local (\\\"div\\\" coordinate system).\\nfunction coordsChar(cm, x, y) {\\n  var doc = cm.doc;\\n  y += cm.display.viewOffset;\\n  if (y \\u003C 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\\n  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\\n  if (lineN \\u003E last)\\n    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\\n  if (x \\u003C 0) { x = 0; }\\n\\n  var lineObj = getLine(doc, lineN);\\n  for (;;) {\\n    var found = coordsCharInner(cm, lineObj, lineN, x, y);\\n    var merged = collapsedSpanAtEnd(lineObj);\\n    var mergedPos = merged && merged.find(0, true);\\n    if (merged && (found.ch \\u003E mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel \\u003E 0))\\n      { lineN = lineNo(lineObj = mergedPos.to.line); }\\n    else\\n      { return found }\\n  }\\n}\\n\\nfunction wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\\n  y -= widgetTopHeight(lineObj);\\n  var end = lineObj.text.length;\\n  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom \\u003C= y; }, end, 0);\\n  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top \\u003E y; }, begin, end);\\n  return {begin: begin, end: end}\\n}\\n\\nfunction wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\\n  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\\n  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \\\"line\\\").top;\\n  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\\n}\\n\\n\\u002F\\u002F Returns true if the given side of a box is after the given\\n\\u002F\\u002F coordinates, in top-to-bottom, left-to-right order.\\nfunction boxIsAfter(box, x, y, left) {\\n  return box.bottom \\u003C= y ? false : box.top \\u003E y ? true : (left ? box.left : box.right) \\u003E x\\n}\\n\\nfunction coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\\n  \\u002F\\u002F Move y into line-local coordinate space\\n  y -= heightAtLine(lineObj);\\n  var preparedMeasure = prepareMeasureForLine(cm, lineObj);\\n  \\u002F\\u002F When directly calling `measureCharPrepared`, we have to adjust\\n  \\u002F\\u002F for the widgets at this line.\\n  var widgetHeight$$1 = widgetTopHeight(lineObj);\\n  var begin = 0, end = lineObj.text.length, ltr = true;\\n\\n  var order = getOrder(lineObj, cm.doc.direction);\\n  \\u002F\\u002F If the line isn't plain left-to-right text, first figure out\\n  \\u002F\\u002F which bidi section the coordinates fall into.\\n  if (order) {\\n    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\\n                 (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\\n    ltr = part.level != 1;\\n    \\u002F\\u002F The awkward -1 offsets are needed because findFirst (called\\n    \\u002F\\u002F on these below) will treat its first bound as inclusive,\\n    \\u002F\\u002F second as exclusive, but we want to actually address the\\n    \\u002F\\u002F characters in the part's range\\n    begin = ltr ? part.from : part.to - 1;\\n    end = ltr ? part.to : part.from - 1;\\n  }\\n\\n  \\u002F\\u002F A binary search to find the first character whose bounding box\\n  \\u002F\\u002F starts after the coordinates. If we run across any whose box wrap\\n  \\u002F\\u002F the coordinates, store that.\\n  var chAround = null, boxAround = null;\\n  var ch = findFirst(function (ch) {\\n    var box = measureCharPrepared(cm, preparedMeasure, ch);\\n    box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\\n    if (!boxIsAfter(box, x, y, false)) { return false }\\n    if (box.top \\u003C= y && box.left \\u003C= x) {\\n      chAround = ch;\\n      boxAround = box;\\n    }\\n    return true\\n  }, begin, end);\\n\\n  var baseX, sticky, outside = false;\\n  \\u002F\\u002F If a box around the coordinates was found, use that\\n  if (boxAround) {\\n    \\u002F\\u002F Distinguish coordinates nearer to the left or right side of the box\\n    var atLeft = x - boxAround.left \\u003C boxAround.right - x, atStart = atLeft == ltr;\\n    ch = chAround + (atStart ? 0 : 1);\\n    sticky = atStart ? \\\"after\\\" : \\\"before\\\";\\n    baseX = atLeft ? boxAround.left : boxAround.right;\\n  } else {\\n    \\u002F\\u002F (Adjust for extended bound, if necessary.)\\n    if (!ltr && (ch == end || ch == begin)) { ch++; }\\n    \\u002F\\u002F To determine which side to associate with, get the box to the\\n    \\u002F\\u002F left of the character and compare it's vertical position to the\\n    \\u002F\\u002F coordinates\\n    sticky = ch == 0 ? \\\"after\\\" : ch == lineObj.text.length ? \\\"before\\\" :\\n      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 \\u003C= y) == ltr ?\\n      \\\"after\\\" : \\\"before\\\";\\n    \\u002F\\u002F Now get accurate coordinates for this place, in order to get a\\n    \\u002F\\u002F base X position\\n    var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \\\"line\\\", lineObj, preparedMeasure);\\n    baseX = coords.left;\\n    outside = y \\u003C coords.top || y \\u003E= coords.bottom;\\n  }\\n\\n  ch = skipExtendingChars(lineObj.text, ch, 1);\\n  return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\\n}\\n\\nfunction coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\\n  \\u002F\\u002F Bidi parts are sorted left-to-right, and in a non-line-wrapping\\n  \\u002F\\u002F situation, we can take this ordering to correspond to the visual\\n  \\u002F\\u002F ordering. This finds the first part whose end is after the given\\n  \\u002F\\u002F coordinates.\\n  var index = findFirst(function (i) {\\n    var part = order[i], ltr = part.level != 1;\\n    return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \\\"before\\\" : \\\"after\\\"),\\n                                   \\\"line\\\", lineObj, preparedMeasure), x, y, true)\\n  }, 0, order.length - 1);\\n  var part = order[index];\\n  \\u002F\\u002F If this isn't the first part, the part's start is also after\\n  \\u002F\\u002F the coordinates, and the coordinates aren't on the same line as\\n  \\u002F\\u002F that start, move one part back.\\n  if (index \\u003E 0) {\\n    var ltr = part.level != 1;\\n    var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \\\"after\\\" : \\\"before\\\"),\\n                             \\\"line\\\", lineObj, preparedMeasure);\\n    if (boxIsAfter(start, x, y, true) && start.top \\u003E y)\\n      { part = order[index - 1]; }\\n  }\\n  return part\\n}\\n\\nfunction coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\\n  \\u002F\\u002F In a wrapped line, rtl text on wrapping boundaries can do things\\n  \\u002F\\u002F that don't correspond to the ordering in our `order` array at\\n  \\u002F\\u002F all, so a binary search doesn't work, and we want to return a\\n  \\u002F\\u002F part that only spans one line so that the binary search in\\n  \\u002F\\u002F coordsCharInner is safe. As such, we first find the extent of the\\n  \\u002F\\u002F wrapped line, and then do a flat search in which we discard any\\n  \\u002F\\u002F spans that aren't on the line.\\n  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\\n  var begin = ref.begin;\\n  var end = ref.end;\\n  if (\\u002F\\\\s\\u002F.test(lineObj.text.charAt(end - 1))) { end--; }\\n  var part = null, closestDist = null;\\n  for (var i = 0; i \\u003C order.length; i++) {\\n    var p = order[i];\\n    if (p.from \\u003E= end || p.to \\u003C= begin) { continue }\\n    var ltr = p.level != 1;\\n    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\\n    \\u002F\\u002F Weigh against spans ending before this, so that they are only\\n    \\u002F\\u002F picked if nothing ends after\\n    var dist = endX \\u003C x ? x - endX + 1e9 : endX - x;\\n    if (!part || closestDist \\u003E dist) {\\n      part = p;\\n      closestDist = dist;\\n    }\\n  }\\n  if (!part) { part = order[order.length - 1]; }\\n  \\u002F\\u002F Clip the part to the wrapped line.\\n  if (part.from \\u003C begin) { part = {from: begin, to: part.to, level: part.level}; }\\n  if (part.to \\u003E end) { part = {from: part.from, to: end, level: part.level}; }\\n  return part\\n}\\n\\nvar measureText;\\n\\u002F\\u002F Compute the default text height.\\nfunction textHeight(display) {\\n  if (display.cachedTextHeight != null) { return display.cachedTextHeight }\\n  if (measureText == null) {\\n    measureText = elt(\\\"pre\\\");\\n    \\u002F\\u002F Measure a bunch of lines, for browsers that compute\\n    \\u002F\\u002F fractional heights.\\n    for (var i = 0; i \\u003C 49; ++i) {\\n      measureText.appendChild(document.createTextNode(\\\"x\\\"));\\n      measureText.appendChild(elt(\\\"br\\\"));\\n    }\\n    measureText.appendChild(document.createTextNode(\\\"x\\\"));\\n  }\\n  removeChildrenAndAdd(display.measure, measureText);\\n  var height = measureText.offsetHeight \\u002F 50;\\n  if (height \\u003E 3) { display.cachedTextHeight = height; }\\n  removeChildren(display.measure);\\n  return height || 1\\n}\\n\\n\\u002F\\u002F Compute the default character width.\\nfunction charWidth(display) {\\n  if (display.cachedCharWidth != null) { return display.cachedCharWidth }\\n  var anchor = elt(\\\"span\\\", \\\"xxxxxxxxxx\\\");\\n  var pre = elt(\\\"pre\\\", [anchor]);\\n  removeChildrenAndAdd(display.measure, pre);\\n  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) \\u002F 10;\\n  if (width \\u003E 2) { display.cachedCharWidth = width; }\\n  return width || 10\\n}\\n\\n\\u002F\\u002F Do a bulk-read of the DOM positions and sizes needed to draw the\\n\\u002F\\u002F view, so that we don't interleave reading and writing to the DOM.\\nfunction getDimensions(cm) {\\n  var d = cm.display, left = {}, width = {};\\n  var gutterLeft = d.gutters.clientLeft;\\n  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\\n    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\\n    width[cm.options.gutters[i]] = n.clientWidth;\\n  }\\n  return {fixedPos: compensateForHScroll(d),\\n          gutterTotalWidth: d.gutters.offsetWidth,\\n          gutterLeft: left,\\n          gutterWidth: width,\\n          wrapperWidth: d.wrapper.clientWidth}\\n}\\n\\n\\u002F\\u002F Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\\n\\u002F\\u002F but using getBoundingClientRect to get a sub-pixel-accurate\\n\\u002F\\u002F result.\\nfunction compensateForHScroll(display) {\\n  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\\n}\\n\\n\\u002F\\u002F Returns a function that estimates the height of a line, to use as\\n\\u002F\\u002F first approximation until the line becomes visible (and is thus\\n\\u002F\\u002F properly measurable).\\nfunction estimateHeight(cm) {\\n  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\\n  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth \\u002F charWidth(cm.display) - 3);\\n  return function (line) {\\n    if (lineIsHidden(cm.doc, line)) { return 0 }\\n\\n    var widgetsHeight = 0;\\n    if (line.widgets) { for (var i = 0; i \\u003C line.widgets.length; i++) {\\n      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\\n    } }\\n\\n    if (wrapping)\\n      { return widgetsHeight + (Math.ceil(line.text.length \\u002F perLine) || 1) * th }\\n    else\\n      { return widgetsHeight + th }\\n  }\\n}\\n\\nfunction estimateLineHeights(cm) {\\n  var doc = cm.doc, est = estimateHeight(cm);\\n  doc.iter(function (line) {\\n    var estHeight = est(line);\\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\\n  });\\n}\\n\\n\\u002F\\u002F Given a mouse event, find the corresponding position. If liberal\\n\\u002F\\u002F is false, it checks whether a gutter or scrollbar was clicked,\\n\\u002F\\u002F and returns null if it was. forRect is used by rectangular\\n\\u002F\\u002F selections, and tries to estimate a character position even for\\n\\u002F\\u002F coordinates beyond the right of the text.\\nfunction posFromMouse(cm, e, liberal, forRect) {\\n  var display = cm.display;\\n  if (!liberal && e_target(e).getAttribute(\\\"cm-not-content\\\") == \\\"true\\\") { return null }\\n\\n  var x, y, space = display.lineSpace.getBoundingClientRect();\\n  \\u002F\\u002F Fails unpredictably on IE[67] when mouse is dragged around quickly.\\n  try { x = e.clientX - space.left; y = e.clientY - space.top; }\\n  catch (e) { return null }\\n  var coords = coordsChar(cm, x, y), line;\\n  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\\n    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\\n    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) \\u002F charWidth(cm.display)) - colDiff));\\n  }\\n  return coords\\n}\\n\\n\\u002F\\u002F Find the view element corresponding to a given line. Return null\\n\\u002F\\u002F when the line isn't visible.\\nfunction findViewIndex(cm, n) {\\n  if (n \\u003E= cm.display.viewTo) { return null }\\n  n -= cm.display.viewFrom;\\n  if (n \\u003C 0) { return null }\\n  var view = cm.display.view;\\n  for (var i = 0; i \\u003C view.length; i++) {\\n    n -= view[i].size;\\n    if (n \\u003C 0) { return i }\\n  }\\n}\\n\\nfunction updateSelection(cm) {\\n  cm.display.input.showSelection(cm.display.input.prepareSelection());\\n}\\n\\nfunction prepareSelection(cm, primary) {\\n  if ( primary === void 0 ) primary = true;\\n\\n  var doc = cm.doc, result = {};\\n  var curFragment = result.cursors = document.createDocumentFragment();\\n  var selFragment = result.selection = document.createDocumentFragment();\\n\\n  for (var i = 0; i \\u003C doc.sel.ranges.length; i++) {\\n    if (!primary && i == doc.sel.primIndex) { continue }\\n    var range$$1 = doc.sel.ranges[i];\\n    if (range$$1.from().line \\u003E= cm.display.viewTo || range$$1.to().line \\u003C cm.display.viewFrom) { continue }\\n    var collapsed = range$$1.empty();\\n    if (collapsed || cm.options.showCursorWhenSelecting)\\n      { drawSelectionCursor(cm, range$$1.head, curFragment); }\\n    if (!collapsed)\\n      { drawSelectionRange(cm, range$$1, selFragment); }\\n  }\\n  return result\\n}\\n\\n\\u002F\\u002F Draws a cursor for the given range\\nfunction drawSelectionCursor(cm, head, output) {\\n  var pos = cursorCoords(cm, head, \\\"div\\\", null, null, !cm.options.singleCursorHeightPerLine);\\n\\n  var cursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor\\\"));\\n  cursor.style.left = pos.left + \\\"px\\\";\\n  cursor.style.top = pos.top + \\\"px\\\";\\n  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \\\"px\\\";\\n\\n  if (pos.other) {\\n    \\u002F\\u002F Secondary cursor, shown when on a 'jump' in bi-directional text\\n    var otherCursor = output.appendChild(elt(\\\"div\\\", \\\"\\\\u00a0\\\", \\\"CodeMirror-cursor CodeMirror-secondarycursor\\\"));\\n    otherCursor.style.display = \\\"\\\";\\n    otherCursor.style.left = pos.other.left + \\\"px\\\";\\n    otherCursor.style.top = pos.other.top + \\\"px\\\";\\n    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \\\"px\\\";\\n  }\\n}\\n\\nfunction cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\\n\\n\\u002F\\u002F Draws the given range as a highlighted selection\\nfunction drawSelectionRange(cm, range$$1, output) {\\n  var display = cm.display, doc = cm.doc;\\n  var fragment = document.createDocumentFragment();\\n  var padding = paddingH(cm.display), leftSide = padding.left;\\n  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\\n  var docLTR = doc.direction == \\\"ltr\\\";\\n\\n  function add(left, top, width, bottom) {\\n    if (top \\u003C 0) { top = 0; }\\n    top = Math.round(top);\\n    bottom = Math.round(bottom);\\n    fragment.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-selected\\\", (\\\"position: absolute; left: \\\" + left + \\\"px;\\\\n                             top: \\\" + top + \\\"px; width: \\\" + (width == null ? rightSide - left : width) + \\\"px;\\\\n                             height: \\\" + (bottom - top) + \\\"px\\\")));\\n  }\\n\\n  function drawForLine(line, fromArg, toArg) {\\n    var lineObj = getLine(doc, line);\\n    var lineLen = lineObj.text.length;\\n    var start, end;\\n    function coords(ch, bias) {\\n      return charCoords(cm, Pos(line, ch), \\\"div\\\", lineObj, bias)\\n    }\\n\\n    function wrapX(pos, dir, side) {\\n      var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\\n      var prop = (dir == \\\"ltr\\\") == (side == \\\"after\\\") ? \\\"left\\\" : \\\"right\\\";\\n      var ch = side == \\\"after\\\" ? extent.begin : extent.end - (\\u002F\\\\s\\u002F.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\\n      return coords(ch, prop)[prop]\\n    }\\n\\n    var order = getOrder(lineObj, doc.direction);\\n    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\\n      var ltr = dir == \\\"ltr\\\";\\n      var fromPos = coords(from, ltr ? \\\"left\\\" : \\\"right\\\");\\n      var toPos = coords(to - 1, ltr ? \\\"right\\\" : \\\"left\\\");\\n\\n      var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\\n      var first = i == 0, last = !order || i == order.length - 1;\\n      if (toPos.top - fromPos.top \\u003C= 3) { \\u002F\\u002F Single line\\n        var openLeft = (docLTR ? openStart : openEnd) && first;\\n        var openRight = (docLTR ? openEnd : openStart) && last;\\n        var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\\n        var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\\n        add(left, fromPos.top, right - left, fromPos.bottom);\\n      } else { \\u002F\\u002F Multiple lines\\n        var topLeft, topRight, botLeft, botRight;\\n        if (ltr) {\\n          topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\\n          topRight = docLTR ? rightSide : wrapX(from, dir, \\\"before\\\");\\n          botLeft = docLTR ? leftSide : wrapX(to, dir, \\\"after\\\");\\n          botRight = docLTR && openEnd && last ? rightSide : toPos.right;\\n        } else {\\n          topLeft = !docLTR ? leftSide : wrapX(from, dir, \\\"before\\\");\\n          topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\\n          botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\\n          botRight = !docLTR ? rightSide : wrapX(to, dir, \\\"after\\\");\\n        }\\n        add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\\n        if (fromPos.bottom \\u003C toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\\n        add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\\n      }\\n\\n      if (!start || cmpCoords(fromPos, start) \\u003C 0) { start = fromPos; }\\n      if (cmpCoords(toPos, start) \\u003C 0) { start = toPos; }\\n      if (!end || cmpCoords(fromPos, end) \\u003C 0) { end = fromPos; }\\n      if (cmpCoords(toPos, end) \\u003C 0) { end = toPos; }\\n    });\\n    return {start: start, end: end}\\n  }\\n\\n  var sFrom = range$$1.from(), sTo = range$$1.to();\\n  if (sFrom.line == sTo.line) {\\n    drawForLine(sFrom.line, sFrom.ch, sTo.ch);\\n  } else {\\n    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\\n    var singleVLine = visualLine(fromLine) == visualLine(toLine);\\n    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\\n    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\\n    if (singleVLine) {\\n      if (leftEnd.top \\u003C rightStart.top - 2) {\\n        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\\n        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\\n      } else {\\n        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\\n      }\\n    }\\n    if (leftEnd.bottom \\u003C rightStart.top)\\n      { add(leftSide, leftEnd.bottom, null, rightStart.top); }\\n  }\\n\\n  output.appendChild(fragment);\\n}\\n\\n\\u002F\\u002F Cursor-blinking\\nfunction restartBlink(cm) {\\n  if (!cm.state.focused) { return }\\n  var display = cm.display;\\n  clearInterval(display.blinker);\\n  var on = true;\\n  display.cursorDiv.style.visibility = \\\"\\\";\\n  if (cm.options.cursorBlinkRate \\u003E 0)\\n    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \\\"\\\" : \\\"hidden\\\"; },\\n      cm.options.cursorBlinkRate); }\\n  else if (cm.options.cursorBlinkRate \\u003C 0)\\n    { display.cursorDiv.style.visibility = \\\"hidden\\\"; }\\n}\\n\\nfunction ensureFocus(cm) {\\n  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\\n}\\n\\nfunction delayBlurEvent(cm) {\\n  cm.state.delayingBlurEvent = true;\\n  setTimeout(function () { if (cm.state.delayingBlurEvent) {\\n    cm.state.delayingBlurEvent = false;\\n    onBlur(cm);\\n  } }, 100);\\n}\\n\\nfunction onFocus(cm, e) {\\n  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\\n\\n  if (cm.options.readOnly == \\\"nocursor\\\") { return }\\n  if (!cm.state.focused) {\\n    signal(cm, \\\"focus\\\", cm, e);\\n    cm.state.focused = true;\\n    addClass(cm.display.wrapper, \\\"CodeMirror-focused\\\");\\n    \\u002F\\u002F This test prevents this from firing when a context\\n    \\u002F\\u002F menu is closed (since the input reset would kill the\\n    \\u002F\\u002F select-all detection hack)\\n    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\\n      cm.display.input.reset();\\n      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } \\u002F\\u002F Issue #1730\\n    }\\n    cm.display.input.receivedFocus();\\n  }\\n  restartBlink(cm);\\n}\\nfunction onBlur(cm, e) {\\n  if (cm.state.delayingBlurEvent) { return }\\n\\n  if (cm.state.focused) {\\n    signal(cm, \\\"blur\\\", cm, e);\\n    cm.state.focused = false;\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-focused\\\");\\n  }\\n  clearInterval(cm.display.blinker);\\n  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\\n}\\n\\n\\u002F\\u002F Read the actual heights of the rendered lines, and update their\\n\\u002F\\u002F stored heights to match.\\nfunction updateHeightsInViewport(cm) {\\n  var display = cm.display;\\n  var prevBottom = display.lineDiv.offsetTop;\\n  for (var i = 0; i \\u003C display.view.length; i++) {\\n    var cur = display.view[i], height = (void 0);\\n    if (cur.hidden) { continue }\\n    if (ie && ie_version \\u003C 8) {\\n      var bot = cur.node.offsetTop + cur.node.offsetHeight;\\n      height = bot - prevBottom;\\n      prevBottom = bot;\\n    } else {\\n      var box = cur.node.getBoundingClientRect();\\n      height = box.bottom - box.top;\\n    }\\n    var diff = cur.line.height - height;\\n    if (height \\u003C 2) { height = textHeight(display); }\\n    if (diff \\u003E .005 || diff \\u003C -.005) {\\n      updateLineHeight(cur.line, height);\\n      updateWidgetHeight(cur.line);\\n      if (cur.rest) { for (var j = 0; j \\u003C cur.rest.length; j++)\\n        { updateWidgetHeight(cur.rest[j]); } }\\n    }\\n  }\\n}\\n\\n\\u002F\\u002F Read and store the height of line widgets associated with the\\n\\u002F\\u002F given line.\\nfunction updateWidgetHeight(line) {\\n  if (line.widgets) { for (var i = 0; i \\u003C line.widgets.length; ++i) {\\n    var w = line.widgets[i], parent = w.node.parentNode;\\n    if (parent) { w.height = parent.offsetHeight; }\\n  } }\\n}\\n\\n\\u002F\\u002F Compute the lines that are visible in a given viewport (defaults\\n\\u002F\\u002F the the current scroll position). viewport may contain top,\\n\\u002F\\u002F height, and ensure (see op.scrollToPos) properties.\\nfunction visibleLines(display, doc, viewport) {\\n  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\\n  top = Math.floor(top - paddingTop(display));\\n  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\\n\\n  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\\n  \\u002F\\u002F Ensure is a {from: {line, ch}, to: {line, ch}} object, and\\n  \\u002F\\u002F forces those lines into the viewport (if possible).\\n  if (viewport && viewport.ensure) {\\n    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\\n    if (ensureFrom \\u003C from) {\\n      from = ensureFrom;\\n      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\\n    } else if (Math.min(ensureTo, doc.lastLine()) \\u003E= to) {\\n      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\\n      to = ensureTo;\\n    }\\n  }\\n  return {from: from, to: Math.max(to, from + 1)}\\n}\\n\\n\\u002F\\u002F Re-align line numbers and gutter marks to compensate for\\n\\u002F\\u002F horizontal scrolling.\\nfunction alignHorizontally(cm) {\\n  var display = cm.display, view = display.view;\\n  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\\n  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\\n  var gutterW = display.gutters.offsetWidth, left = comp + \\\"px\\\";\\n  for (var i = 0; i \\u003C view.length; i++) { if (!view[i].hidden) {\\n    if (cm.options.fixedGutter) {\\n      if (view[i].gutter)\\n        { view[i].gutter.style.left = left; }\\n      if (view[i].gutterBackground)\\n        { view[i].gutterBackground.style.left = left; }\\n    }\\n    var align = view[i].alignable;\\n    if (align) { for (var j = 0; j \\u003C align.length; j++)\\n      { align[j].style.left = left; } }\\n  } }\\n  if (cm.options.fixedGutter)\\n    { display.gutters.style.left = (comp + gutterW) + \\\"px\\\"; }\\n}\\n\\n\\u002F\\u002F Used to ensure that the line number gutter is still the right\\n\\u002F\\u002F size for the current document size. Returns true when an update\\n\\u002F\\u002F is needed.\\nfunction maybeUpdateLineNumberWidth(cm) {\\n  if (!cm.options.lineNumbers) { return false }\\n  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\\n  if (last.length != display.lineNumChars) {\\n    var test = display.measure.appendChild(elt(\\\"div\\\", [elt(\\\"div\\\", last)],\\n                                               \\\"CodeMirror-linenumber CodeMirror-gutter-elt\\\"));\\n    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\\n    display.lineGutter.style.width = \\\"\\\";\\n    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\\n    display.lineNumWidth = display.lineNumInnerWidth + padding;\\n    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\\n    display.lineGutter.style.width = display.lineNumWidth + \\\"px\\\";\\n    updateGutterSpace(cm);\\n    return true\\n  }\\n  return false\\n}\\n\\n\\u002F\\u002F SCROLLING THINGS INTO VIEW\\n\\n\\u002F\\u002F If an editor sits on the top or bottom of the window, partially\\n\\u002F\\u002F scrolled out of view, this ensures that the cursor is visible.\\nfunction maybeScrollWindow(cm, rect) {\\n  if (signalDOMEvent(cm, \\\"scrollCursorIntoView\\\")) { return }\\n\\n  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\\n  if (rect.top + box.top \\u003C 0) { doScroll = true; }\\n  else if (rect.bottom + box.top \\u003E (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\\n  if (doScroll != null && !phantom) {\\n    var scrollNode = elt(\\\"div\\\", \\\"\\\\u200b\\\", null, (\\\"position: absolute;\\\\n                         top: \\\" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \\\"px;\\\\n                         height: \\\" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \\\"px;\\\\n                         left: \\\" + (rect.left) + \\\"px; width: \\\" + (Math.max(2, rect.right - rect.left)) + \\\"px;\\\"));\\n    cm.display.lineSpace.appendChild(scrollNode);\\n    scrollNode.scrollIntoView(doScroll);\\n    cm.display.lineSpace.removeChild(scrollNode);\\n  }\\n}\\n\\n\\u002F\\u002F Scroll a given position into view (immediately), verifying that\\n\\u002F\\u002F it actually became visible (as line heights are accurately\\n\\u002F\\u002F measured, the position of something may 'drift' during drawing).\\nfunction scrollPosIntoView(cm, pos, end, margin) {\\n  if (margin == null) { margin = 0; }\\n  var rect;\\n  if (!cm.options.lineWrapping && pos == end) {\\n    \\u002F\\u002F Set pos and end to the cursor positions around the character pos sticks to\\n    \\u002F\\u002F If pos.sticky == \\\"before\\\", that is around pos.ch - 1, otherwise around pos.ch\\n    \\u002F\\u002F If pos == Pos(_, 0, \\\"before\\\"), pos and end are unchanged\\n    pos = pos.ch ? Pos(pos.line, pos.sticky == \\\"before\\\" ? pos.ch - 1 : pos.ch, \\\"after\\\") : pos;\\n    end = pos.sticky == \\\"before\\\" ? Pos(pos.line, pos.ch + 1, \\\"before\\\") : pos;\\n  }\\n  for (var limit = 0; limit \\u003C 5; limit++) {\\n    var changed = false;\\n    var coords = cursorCoords(cm, pos);\\n    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\\n    rect = {left: Math.min(coords.left, endCoords.left),\\n            top: Math.min(coords.top, endCoords.top) - margin,\\n            right: Math.max(coords.left, endCoords.left),\\n            bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\\n    var scrollPos = calculateScrollPos(cm, rect);\\n    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\\n    if (scrollPos.scrollTop != null) {\\n      updateScrollTop(cm, scrollPos.scrollTop);\\n      if (Math.abs(cm.doc.scrollTop - startTop) \\u003E 1) { changed = true; }\\n    }\\n    if (scrollPos.scrollLeft != null) {\\n      setScrollLeft(cm, scrollPos.scrollLeft);\\n      if (Math.abs(cm.doc.scrollLeft - startLeft) \\u003E 1) { changed = true; }\\n    }\\n    if (!changed) { break }\\n  }\\n  return rect\\n}\\n\\n\\u002F\\u002F Scroll a given set of coordinates into view (immediately).\\nfunction scrollIntoView(cm, rect) {\\n  var scrollPos = calculateScrollPos(cm, rect);\\n  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\\n  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\\n}\\n\\n\\u002F\\u002F Calculate a new scroll position needed to scroll the given\\n\\u002F\\u002F rectangle into view. Returns an object with scrollTop and\\n\\u002F\\u002F scrollLeft properties. When these are undefined, the\\n\\u002F\\u002F vertical\\u002Fhorizontal position does not need to be adjusted.\\nfunction calculateScrollPos(cm, rect) {\\n  var display = cm.display, snapMargin = textHeight(cm.display);\\n  if (rect.top \\u003C 0) { rect.top = 0; }\\n  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\\n  var screen = displayHeight(cm), result = {};\\n  if (rect.bottom - rect.top \\u003E screen) { rect.bottom = rect.top + screen; }\\n  var docBottom = cm.doc.height + paddingVert(display);\\n  var atTop = rect.top \\u003C snapMargin, atBottom = rect.bottom \\u003E docBottom - snapMargin;\\n  if (rect.top \\u003C screentop) {\\n    result.scrollTop = atTop ? 0 : rect.top;\\n  } else if (rect.bottom \\u003E screentop + screen) {\\n    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\\n    if (newTop != screentop) { result.scrollTop = newTop; }\\n  }\\n\\n  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\\n  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\\n  var tooWide = rect.right - rect.left \\u003E screenw;\\n  if (tooWide) { rect.right = rect.left + screenw; }\\n  if (rect.left \\u003C 10)\\n    { result.scrollLeft = 0; }\\n  else if (rect.left \\u003C screenleft)\\n    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\\n  else if (rect.right \\u003E screenw + screenleft - 3)\\n    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\\n  return result\\n}\\n\\n\\u002F\\u002F Store a relative adjustment to the scroll position in the current\\n\\u002F\\u002F operation (to be applied when the operation finishes).\\nfunction addToScrollTop(cm, top) {\\n  if (top == null) { return }\\n  resolveScrollToPos(cm);\\n  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\\n}\\n\\n\\u002F\\u002F Make sure that at the end of the operation the current cursor is\\n\\u002F\\u002F shown.\\nfunction ensureCursorVisible(cm) {\\n  resolveScrollToPos(cm);\\n  var cur = cm.getCursor();\\n  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\\n}\\n\\nfunction scrollToCoords(cm, x, y) {\\n  if (x != null || y != null) { resolveScrollToPos(cm); }\\n  if (x != null) { cm.curOp.scrollLeft = x; }\\n  if (y != null) { cm.curOp.scrollTop = y; }\\n}\\n\\nfunction scrollToRange(cm, range$$1) {\\n  resolveScrollToPos(cm);\\n  cm.curOp.scrollToPos = range$$1;\\n}\\n\\n\\u002F\\u002F When an operation has its scrollToPos property set, and another\\n\\u002F\\u002F scroll action is applied before the end of the operation, this\\n\\u002F\\u002F 'simulates' scrolling that position into view in a cheap way, so\\n\\u002F\\u002F that the effect of intermediate scroll commands is not ignored.\\nfunction resolveScrollToPos(cm) {\\n  var range$$1 = cm.curOp.scrollToPos;\\n  if (range$$1) {\\n    cm.curOp.scrollToPos = null;\\n    var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\\n    scrollToCoordsRange(cm, from, to, range$$1.margin);\\n  }\\n}\\n\\nfunction scrollToCoordsRange(cm, from, to, margin) {\\n  var sPos = calculateScrollPos(cm, {\\n    left: Math.min(from.left, to.left),\\n    top: Math.min(from.top, to.top) - margin,\\n    right: Math.max(from.right, to.right),\\n    bottom: Math.max(from.bottom, to.bottom) + margin\\n  });\\n  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\\n}\\n\\n\\u002F\\u002F Sync the scrollable area and scrollbars, ensure the viewport\\n\\u002F\\u002F covers the visible area.\\nfunction updateScrollTop(cm, val) {\\n  if (Math.abs(cm.doc.scrollTop - val) \\u003C 2) { return }\\n  if (!gecko) { updateDisplaySimple(cm, {top: val}); }\\n  setScrollTop(cm, val, true);\\n  if (gecko) { updateDisplaySimple(cm); }\\n  startWorker(cm, 100);\\n}\\n\\nfunction setScrollTop(cm, val, forceScroll) {\\n  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\\n  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\\n  cm.doc.scrollTop = val;\\n  cm.display.scrollbars.setScrollTop(val);\\n  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\\n}\\n\\n\\u002F\\u002F Sync scroller and scrollbar, ensure the gutter elements are\\n\\u002F\\u002F aligned.\\nfunction setScrollLeft(cm, val, isScroller, forceScroll) {\\n  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\\n  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) \\u003C 2) && !forceScroll) { return }\\n  cm.doc.scrollLeft = val;\\n  alignHorizontally(cm);\\n  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\\n  cm.display.scrollbars.setScrollLeft(val);\\n}\\n\\n\\u002F\\u002F SCROLLBARS\\n\\n\\u002F\\u002F Prepare DOM reads needed to update the scrollbars. Done in one\\n\\u002F\\u002F shot to minimize update\\u002Fmeasure roundtrips.\\nfunction measureForScrollbars(cm) {\\n  var d = cm.display, gutterW = d.gutters.offsetWidth;\\n  var docH = Math.round(cm.doc.height + paddingVert(cm.display));\\n  return {\\n    clientHeight: d.scroller.clientHeight,\\n    viewHeight: d.wrapper.clientHeight,\\n    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\\n    viewWidth: d.wrapper.clientWidth,\\n    barLeft: cm.options.fixedGutter ? gutterW : 0,\\n    docHeight: docH,\\n    scrollHeight: docH + scrollGap(cm) + d.barHeight,\\n    nativeBarWidth: d.nativeBarWidth,\\n    gutterWidth: gutterW\\n  }\\n}\\n\\nvar NativeScrollbars = function(place, scroll, cm) {\\n  this.cm = cm;\\n  var vert = this.vert = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"min-width: 1px\\\")], \\\"CodeMirror-vscrollbar\\\");\\n  var horiz = this.horiz = elt(\\\"div\\\", [elt(\\\"div\\\", null, null, \\\"height: 100%; min-height: 1px\\\")], \\\"CodeMirror-hscrollbar\\\");\\n  place(vert); place(horiz);\\n\\n  on(vert, \\\"scroll\\\", function () {\\n    if (vert.clientHeight) { scroll(vert.scrollTop, \\\"vertical\\\"); }\\n  });\\n  on(horiz, \\\"scroll\\\", function () {\\n    if (horiz.clientWidth) { scroll(horiz.scrollLeft, \\\"horizontal\\\"); }\\n  });\\n\\n  this.checkedZeroWidth = false;\\n  \\u002F\\u002F Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\\n  if (ie && ie_version \\u003C 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \\\"18px\\\"; }\\n};\\n\\nNativeScrollbars.prototype.update = function (measure) {\\n  var needsH = measure.scrollWidth \\u003E measure.clientWidth + 1;\\n  var needsV = measure.scrollHeight \\u003E measure.clientHeight + 1;\\n  var sWidth = measure.nativeBarWidth;\\n\\n  if (needsV) {\\n    this.vert.style.display = \\\"block\\\";\\n    this.vert.style.bottom = needsH ? sWidth + \\\"px\\\" : \\\"0\\\";\\n    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\\n    \\u002F\\u002F A bug in IE8 can cause this value to be negative, so guard it.\\n    this.vert.firstChild.style.height =\\n      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \\\"px\\\";\\n  } else {\\n    this.vert.style.display = \\\"\\\";\\n    this.vert.firstChild.style.height = \\\"0\\\";\\n  }\\n\\n  if (needsH) {\\n    this.horiz.style.display = \\\"block\\\";\\n    this.horiz.style.right = needsV ? sWidth + \\\"px\\\" : \\\"0\\\";\\n    this.horiz.style.left = measure.barLeft + \\\"px\\\";\\n    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\\n    this.horiz.firstChild.style.width =\\n      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \\\"px\\\";\\n  } else {\\n    this.horiz.style.display = \\\"\\\";\\n    this.horiz.firstChild.style.width = \\\"0\\\";\\n  }\\n\\n  if (!this.checkedZeroWidth && measure.clientHeight \\u003E 0) {\\n    if (sWidth == 0) { this.zeroWidthHack(); }\\n    this.checkedZeroWidth = true;\\n  }\\n\\n  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\\n};\\n\\nNativeScrollbars.prototype.setScrollLeft = function (pos) {\\n  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\\n  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \\\"horiz\\\"); }\\n};\\n\\nNativeScrollbars.prototype.setScrollTop = function (pos) {\\n  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\\n  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \\\"vert\\\"); }\\n};\\n\\nNativeScrollbars.prototype.zeroWidthHack = function () {\\n  var w = mac && !mac_geMountainLion ? \\\"12px\\\" : \\\"18px\\\";\\n  this.horiz.style.height = this.vert.style.width = w;\\n  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \\\"none\\\";\\n  this.disableHoriz = new Delayed;\\n  this.disableVert = new Delayed;\\n};\\n\\nNativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\\n  bar.style.pointerEvents = \\\"auto\\\";\\n  function maybeDisable() {\\n    \\u002F\\u002F To find out whether the scrollbar is still visible, we\\n    \\u002F\\u002F check whether the element under the pixel in the bottom\\n    \\u002F\\u002F right corner of the scrollbar box is the scrollbar box\\n    \\u002F\\u002F itself (when the bar is still visible) or its filler child\\n    \\u002F\\u002F (when the bar is hidden). If it is still visible, we keep\\n    \\u002F\\u002F it enabled, if it's hidden, we disable pointer events.\\n    var box = bar.getBoundingClientRect();\\n    var elt$$1 = type == \\\"vert\\\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) \\u002F 2)\\n        : document.elementFromPoint((box.right + box.left) \\u002F 2, box.bottom - 1);\\n    if (elt$$1 != bar) { bar.style.pointerEvents = \\\"none\\\"; }\\n    else { delay.set(1000, maybeDisable); }\\n  }\\n  delay.set(1000, maybeDisable);\\n};\\n\\nNativeScrollbars.prototype.clear = function () {\\n  var parent = this.horiz.parentNode;\\n  parent.removeChild(this.horiz);\\n  parent.removeChild(this.vert);\\n};\\n\\nvar NullScrollbars = function () {};\\n\\nNullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\\nNullScrollbars.prototype.setScrollLeft = function () {};\\nNullScrollbars.prototype.setScrollTop = function () {};\\nNullScrollbars.prototype.clear = function () {};\\n\\nfunction updateScrollbars(cm, measure) {\\n  if (!measure) { measure = measureForScrollbars(cm); }\\n  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\\n  updateScrollbarsInner(cm, measure);\\n  for (var i = 0; i \\u003C 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\\n    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\\n      { updateHeightsInViewport(cm); }\\n    updateScrollbarsInner(cm, measureForScrollbars(cm));\\n    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\\n  }\\n}\\n\\n\\u002F\\u002F Re-synchronize the fake scrollbars with the actual size of the\\n\\u002F\\u002F content.\\nfunction updateScrollbarsInner(cm, measure) {\\n  var d = cm.display;\\n  var sizes = d.scrollbars.update(measure);\\n\\n  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \\\"px\\\";\\n  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \\\"px\\\";\\n  d.heightForcer.style.borderBottom = sizes.bottom + \\\"px solid transparent\\\";\\n\\n  if (sizes.right && sizes.bottom) {\\n    d.scrollbarFiller.style.display = \\\"block\\\";\\n    d.scrollbarFiller.style.height = sizes.bottom + \\\"px\\\";\\n    d.scrollbarFiller.style.width = sizes.right + \\\"px\\\";\\n  } else { d.scrollbarFiller.style.display = \\\"\\\"; }\\n  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\\n    d.gutterFiller.style.display = \\\"block\\\";\\n    d.gutterFiller.style.height = sizes.bottom + \\\"px\\\";\\n    d.gutterFiller.style.width = measure.gutterWidth + \\\"px\\\";\\n  } else { d.gutterFiller.style.display = \\\"\\\"; }\\n}\\n\\nvar scrollbarModel = {\\\"native\\\": NativeScrollbars, \\\"null\\\": NullScrollbars};\\n\\nfunction initScrollbars(cm) {\\n  if (cm.display.scrollbars) {\\n    cm.display.scrollbars.clear();\\n    if (cm.display.scrollbars.addClass)\\n      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\\n  }\\n\\n  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\\n    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\\n    \\u002F\\u002F Prevent clicks in the scrollbars from killing focus\\n    on(node, \\\"mousedown\\\", function () {\\n      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\\n    });\\n    node.setAttribute(\\\"cm-not-content\\\", \\\"true\\\");\\n  }, function (pos, axis) {\\n    if (axis == \\\"horizontal\\\") { setScrollLeft(cm, pos); }\\n    else { updateScrollTop(cm, pos); }\\n  }, cm);\\n  if (cm.display.scrollbars.addClass)\\n    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\\n}\\n\\n\\u002F\\u002F Operations are used to wrap a series of changes to the editor\\n\\u002F\\u002F state in such a way that each change won't have to update the\\n\\u002F\\u002F cursor and display (which would be awkward, slow, and\\n\\u002F\\u002F error-prone). Instead, display updates are batched and then all\\n\\u002F\\u002F combined and executed at once.\\n\\nvar nextOpId = 0;\\n\\u002F\\u002F Start a new operation.\\nfunction startOperation(cm) {\\n  cm.curOp = {\\n    cm: cm,\\n    viewChanged: false,      \\u002F\\u002F Flag that indicates that lines might need to be redrawn\\n    startHeight: cm.doc.height, \\u002F\\u002F Used to detect need to update scrollbar\\n    forceUpdate: false,      \\u002F\\u002F Used to force a redraw\\n    updateInput: null,       \\u002F\\u002F Whether to reset the input textarea\\n    typing: false,           \\u002F\\u002F Whether this reset should be careful to leave existing text (for compositing)\\n    changeObjs: null,        \\u002F\\u002F Accumulated changes, for firing change events\\n    cursorActivityHandlers: null, \\u002F\\u002F Set of handlers to fire cursorActivity on\\n    cursorActivityCalled: 0, \\u002F\\u002F Tracks which cursorActivity handlers have been called already\\n    selectionChanged: false, \\u002F\\u002F Whether the selection needs to be redrawn\\n    updateMaxLine: false,    \\u002F\\u002F Set when the widest line needs to be determined anew\\n    scrollLeft: null, scrollTop: null, \\u002F\\u002F Intermediate scroll position, not pushed to DOM yet\\n    scrollToPos: null,       \\u002F\\u002F Used to scroll to a specific position\\n    focus: false,\\n    id: ++nextOpId           \\u002F\\u002F Unique ID\\n  };\\n  pushOperation(cm.curOp);\\n}\\n\\n\\u002F\\u002F Finish an operation, updating the display and signalling delayed events\\nfunction endOperation(cm) {\\n  var op = cm.curOp;\\n  finishOperation(op, function (group) {\\n    for (var i = 0; i \\u003C group.ops.length; i++)\\n      { group.ops[i].cm.curOp = null; }\\n    endOperations(group);\\n  });\\n}\\n\\n\\u002F\\u002F The DOM updates done when an operation finishes are batched so\\n\\u002F\\u002F that the minimum number of relayouts are required.\\nfunction endOperations(group) {\\n  var ops = group.ops;\\n  for (var i = 0; i \\u003C ops.length; i++) \\u002F\\u002F Read DOM\\n    { endOperation_R1(ops[i]); }\\n  for (var i$1 = 0; i$1 \\u003C ops.length; i$1++) \\u002F\\u002F Write DOM (maybe)\\n    { endOperation_W1(ops[i$1]); }\\n  for (var i$2 = 0; i$2 \\u003C ops.length; i$2++) \\u002F\\u002F Read DOM\\n    { endOperation_R2(ops[i$2]); }\\n  for (var i$3 = 0; i$3 \\u003C ops.length; i$3++) \\u002F\\u002F Write DOM (maybe)\\n    { endOperation_W2(ops[i$3]); }\\n  for (var i$4 = 0; i$4 \\u003C ops.length; i$4++) \\u002F\\u002F Read DOM\\n    { endOperation_finish(ops[i$4]); }\\n}\\n\\nfunction endOperation_R1(op) {\\n  var cm = op.cm, display = cm.display;\\n  maybeClipScrollbars(cm);\\n  if (op.updateMaxLine) { findMaxLine(cm); }\\n\\n  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\\n    op.scrollToPos && (op.scrollToPos.from.line \\u003C display.viewFrom ||\\n                       op.scrollToPos.to.line \\u003E= display.viewTo) ||\\n    display.maxLineChanged && cm.options.lineWrapping;\\n  op.update = op.mustUpdate &&\\n    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\\n}\\n\\nfunction endOperation_W1(op) {\\n  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\\n}\\n\\nfunction endOperation_R2(op) {\\n  var cm = op.cm, display = cm.display;\\n  if (op.updatedDisplay) { updateHeightsInViewport(cm); }\\n\\n  op.barMeasure = measureForScrollbars(cm);\\n\\n  \\u002F\\u002F If the max line changed since it was last measured, measure it,\\n  \\u002F\\u002F and ensure the document's width matches it.\\n  \\u002F\\u002F updateDisplay_W2 will use these properties to do the actual resizing\\n  if (display.maxLineChanged && !cm.options.lineWrapping) {\\n    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\\n    cm.display.sizerWidth = op.adjustWidthTo;\\n    op.barMeasure.scrollWidth =\\n      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\\n    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\\n  }\\n\\n  if (op.updatedDisplay || op.selectionChanged)\\n    { op.preparedSelection = display.input.prepareSelection(); }\\n}\\n\\nfunction endOperation_W2(op) {\\n  var cm = op.cm;\\n\\n  if (op.adjustWidthTo != null) {\\n    cm.display.sizer.style.minWidth = op.adjustWidthTo + \\\"px\\\";\\n    if (op.maxScrollLeft \\u003C cm.doc.scrollLeft)\\n      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\\n    cm.display.maxLineChanged = false;\\n  }\\n\\n  var takeFocus = op.focus && op.focus == activeElt();\\n  if (op.preparedSelection)\\n    { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\\n  if (op.updatedDisplay || op.startHeight != cm.doc.height)\\n    { updateScrollbars(cm, op.barMeasure); }\\n  if (op.updatedDisplay)\\n    { setDocumentHeight(cm, op.barMeasure); }\\n\\n  if (op.selectionChanged) { restartBlink(cm); }\\n\\n  if (cm.state.focused && op.updateInput)\\n    { cm.display.input.reset(op.typing); }\\n  if (takeFocus) { ensureFocus(op.cm); }\\n}\\n\\nfunction endOperation_finish(op) {\\n  var cm = op.cm, display = cm.display, doc = cm.doc;\\n\\n  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\\n\\n  \\u002F\\u002F Abort mouse wheel delta measurement, when scrolling explicitly\\n  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\\n    { display.wheelStartX = display.wheelStartY = null; }\\n\\n  \\u002F\\u002F Propagate the scroll position to the actual DOM scroller\\n  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\\n\\n  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\\n  \\u002F\\u002F If we need to scroll a specific position into view, do so.\\n  if (op.scrollToPos) {\\n    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\\n                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\\n    maybeScrollWindow(cm, rect);\\n  }\\n\\n  \\u002F\\u002F Fire events for markers that are hidden\\u002Funidden by editing or\\n  \\u002F\\u002F undoing\\n  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\\n  if (hidden) { for (var i = 0; i \\u003C hidden.length; ++i)\\n    { if (!hidden[i].lines.length) { signal(hidden[i], \\\"hide\\\"); } } }\\n  if (unhidden) { for (var i$1 = 0; i$1 \\u003C unhidden.length; ++i$1)\\n    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \\\"unhide\\\"); } } }\\n\\n  if (display.wrapper.offsetHeight)\\n    { doc.scrollTop = cm.display.scroller.scrollTop; }\\n\\n  \\u002F\\u002F Fire change events, and delayed event handlers\\n  if (op.changeObjs)\\n    { signal(cm, \\\"changes\\\", cm, op.changeObjs); }\\n  if (op.update)\\n    { op.update.finish(); }\\n}\\n\\n\\u002F\\u002F Run the given function in an operation\\nfunction runInOp(cm, f) {\\n  if (cm.curOp) { return f() }\\n  startOperation(cm);\\n  try { return f() }\\n  finally { endOperation(cm); }\\n}\\n\\u002F\\u002F Wraps a function in an operation. Returns the wrapped function.\\nfunction operation(cm, f) {\\n  return function() {\\n    if (cm.curOp) { return f.apply(cm, arguments) }\\n    startOperation(cm);\\n    try { return f.apply(cm, arguments) }\\n    finally { endOperation(cm); }\\n  }\\n}\\n\\u002F\\u002F Used to add methods to editor and doc instances, wrapping them in\\n\\u002F\\u002F operations.\\nfunction methodOp(f) {\\n  return function() {\\n    if (this.curOp) { return f.apply(this, arguments) }\\n    startOperation(this);\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(this); }\\n  }\\n}\\nfunction docMethodOp(f) {\\n  return function() {\\n    var cm = this.cm;\\n    if (!cm || cm.curOp) { return f.apply(this, arguments) }\\n    startOperation(cm);\\n    try { return f.apply(this, arguments) }\\n    finally { endOperation(cm); }\\n  }\\n}\\n\\n\\u002F\\u002F Updates the display.view data structure for a given change to the\\n\\u002F\\u002F document. From and to are in pre-change coordinates. Lendiff is\\n\\u002F\\u002F the amount of lines added or subtracted by the change. This is\\n\\u002F\\u002F used for changes that span multiple lines, or change the way\\n\\u002F\\u002F lines are divided into visual lines. regLineChange (below)\\n\\u002F\\u002F registers single-line changes.\\nfunction regChange(cm, from, to, lendiff) {\\n  if (from == null) { from = cm.doc.first; }\\n  if (to == null) { to = cm.doc.first + cm.doc.size; }\\n  if (!lendiff) { lendiff = 0; }\\n\\n  var display = cm.display;\\n  if (lendiff && to \\u003C display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers \\u003E from))\\n    { display.updateLineNumbers = from; }\\n\\n  cm.curOp.viewChanged = true;\\n\\n  if (from \\u003E= display.viewTo) { \\u002F\\u002F Change after\\n    if (sawCollapsedSpans && visualLineNo(cm.doc, from) \\u003C display.viewTo)\\n      { resetView(cm); }\\n  } else if (to \\u003C= display.viewFrom) { \\u002F\\u002F Change before\\n    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) \\u003E display.viewFrom) {\\n      resetView(cm);\\n    } else {\\n      display.viewFrom += lendiff;\\n      display.viewTo += lendiff;\\n    }\\n  } else if (from \\u003C= display.viewFrom && to \\u003E= display.viewTo) { \\u002F\\u002F Full overlap\\n    resetView(cm);\\n  } else if (from \\u003C= display.viewFrom) { \\u002F\\u002F Top overlap\\n    var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\\n    if (cut) {\\n      display.view = display.view.slice(cut.index);\\n      display.viewFrom = cut.lineN;\\n      display.viewTo += lendiff;\\n    } else {\\n      resetView(cm);\\n    }\\n  } else if (to \\u003E= display.viewTo) { \\u002F\\u002F Bottom overlap\\n    var cut$1 = viewCuttingPoint(cm, from, from, -1);\\n    if (cut$1) {\\n      display.view = display.view.slice(0, cut$1.index);\\n      display.viewTo = cut$1.lineN;\\n    } else {\\n      resetView(cm);\\n    }\\n  } else { \\u002F\\u002F Gap in the middle\\n    var cutTop = viewCuttingPoint(cm, from, from, -1);\\n    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\\n    if (cutTop && cutBot) {\\n      display.view = display.view.slice(0, cutTop.index)\\n        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\\n        .concat(display.view.slice(cutBot.index));\\n      display.viewTo += lendiff;\\n    } else {\\n      resetView(cm);\\n    }\\n  }\\n\\n  var ext = display.externalMeasured;\\n  if (ext) {\\n    if (to \\u003C ext.lineN)\\n      { ext.lineN += lendiff; }\\n    else if (from \\u003C ext.lineN + ext.size)\\n      { display.externalMeasured = null; }\\n  }\\n}\\n\\n\\u002F\\u002F Register a change to a single line. Type must be one of \\\"text\\\",\\n\\u002F\\u002F \\\"gutter\\\", \\\"class\\\", \\\"widget\\\"\\nfunction regLineChange(cm, line, type) {\\n  cm.curOp.viewChanged = true;\\n  var display = cm.display, ext = cm.display.externalMeasured;\\n  if (ext && line \\u003E= ext.lineN && line \\u003C ext.lineN + ext.size)\\n    { display.externalMeasured = null; }\\n\\n  if (line \\u003C display.viewFrom || line \\u003E= display.viewTo) { return }\\n  var lineView = display.view[findViewIndex(cm, line)];\\n  if (lineView.node == null) { return }\\n  var arr = lineView.changes || (lineView.changes = []);\\n  if (indexOf(arr, type) == -1) { arr.push(type); }\\n}\\n\\n\\u002F\\u002F Clear the view.\\nfunction resetView(cm) {\\n  cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\\n  cm.display.view = [];\\n  cm.display.viewOffset = 0;\\n}\\n\\nfunction viewCuttingPoint(cm, oldN, newN, dir) {\\n  var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\\n  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\\n    { return {index: index, lineN: newN} }\\n  var n = cm.display.viewFrom;\\n  for (var i = 0; i \\u003C index; i++)\\n    { n += view[i].size; }\\n  if (n != oldN) {\\n    if (dir \\u003E 0) {\\n      if (index == view.length - 1) { return null }\\n      diff = (n + view[index].size) - oldN;\\n      index++;\\n    } else {\\n      diff = n - oldN;\\n    }\\n    oldN += diff; newN += diff;\\n  }\\n  while (visualLineNo(cm.doc, newN) != newN) {\\n    if (index == (dir \\u003C 0 ? 0 : view.length - 1)) { return null }\\n    newN += dir * view[index - (dir \\u003C 0 ? 1 : 0)].size;\\n    index += dir;\\n  }\\n  return {index: index, lineN: newN}\\n}\\n\\n\\u002F\\u002F Force the view to cover a given range, adding empty view element\\n\\u002F\\u002F or clipping off existing ones as needed.\\nfunction adjustView(cm, from, to) {\\n  var display = cm.display, view = display.view;\\n  if (view.length == 0 || from \\u003E= display.viewTo || to \\u003C= display.viewFrom) {\\n    display.view = buildViewArray(cm, from, to);\\n    display.viewFrom = from;\\n  } else {\\n    if (display.viewFrom \\u003E from)\\n      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\\n    else if (display.viewFrom \\u003C from)\\n      { display.view = display.view.slice(findViewIndex(cm, from)); }\\n    display.viewFrom = from;\\n    if (display.viewTo \\u003C to)\\n      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\\n    else if (display.viewTo \\u003E to)\\n      { display.view = display.view.slice(0, findViewIndex(cm, to)); }\\n  }\\n  display.viewTo = to;\\n}\\n\\n\\u002F\\u002F Count the number of lines in the view whose DOM representation is\\n\\u002F\\u002F out of date (or nonexistent).\\nfunction countDirtyView(cm) {\\n  var view = cm.display.view, dirty = 0;\\n  for (var i = 0; i \\u003C view.length; i++) {\\n    var lineView = view[i];\\n    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\\n  }\\n  return dirty\\n}\\n\\n\\u002F\\u002F HIGHLIGHT WORKER\\n\\nfunction startWorker(cm, time) {\\n  if (cm.doc.highlightFrontier \\u003C cm.display.viewTo)\\n    { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\\n}\\n\\nfunction highlightWorker(cm) {\\n  var doc = cm.doc;\\n  if (doc.highlightFrontier \\u003E= cm.display.viewTo) { return }\\n  var end = +new Date + cm.options.workTime;\\n  var context = getContextBefore(cm, doc.highlightFrontier);\\n  var changedLines = [];\\n\\n  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\\n    if (context.line \\u003E= cm.display.viewFrom) { \\u002F\\u002F Visible\\n      var oldStyles = line.styles;\\n      var resetState = line.text.length \\u003E cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\\n      var highlighted = highlightLine(cm, line, context, true);\\n      if (resetState) { context.state = resetState; }\\n      line.styles = highlighted.styles;\\n      var oldCls = line.styleClasses, newCls = highlighted.classes;\\n      if (newCls) { line.styleClasses = newCls; }\\n      else if (oldCls) { line.styleClasses = null; }\\n      var ischange = !oldStyles || oldStyles.length != line.styles.length ||\\n        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\\n      for (var i = 0; !ischange && i \\u003C oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\\n      if (ischange) { changedLines.push(context.line); }\\n      line.stateAfter = context.save();\\n      context.nextLine();\\n    } else {\\n      if (line.text.length \\u003C= cm.options.maxHighlightLength)\\n        { processLine(cm, line.text, context); }\\n      line.stateAfter = context.line % 5 == 0 ? context.save() : null;\\n      context.nextLine();\\n    }\\n    if (+new Date \\u003E end) {\\n      startWorker(cm, cm.options.workDelay);\\n      return true\\n    }\\n  });\\n  doc.highlightFrontier = context.line;\\n  doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\\n  if (changedLines.length) { runInOp(cm, function () {\\n    for (var i = 0; i \\u003C changedLines.length; i++)\\n      { regLineChange(cm, changedLines[i], \\\"text\\\"); }\\n  }); }\\n}\\n\\n\\u002F\\u002F DISPLAY DRAWING\\n\\nvar DisplayUpdate = function(cm, viewport, force) {\\n  var display = cm.display;\\n\\n  this.viewport = viewport;\\n  \\u002F\\u002F Store some values that we'll need later (but don't want to force a relayout for)\\n  this.visible = visibleLines(display, cm.doc, viewport);\\n  this.editorIsHidden = !display.wrapper.offsetWidth;\\n  this.wrapperHeight = display.wrapper.clientHeight;\\n  this.wrapperWidth = display.wrapper.clientWidth;\\n  this.oldDisplayWidth = displayWidth(cm);\\n  this.force = force;\\n  this.dims = getDimensions(cm);\\n  this.events = [];\\n};\\n\\nDisplayUpdate.prototype.signal = function (emitter, type) {\\n  if (hasHandler(emitter, type))\\n    { this.events.push(arguments); }\\n};\\nDisplayUpdate.prototype.finish = function () {\\n    var this$1 = this;\\n\\n  for (var i = 0; i \\u003C this.events.length; i++)\\n    { signal.apply(null, this$1.events[i]); }\\n};\\n\\nfunction maybeClipScrollbars(cm) {\\n  var display = cm.display;\\n  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\\n    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\\n    display.heightForcer.style.height = scrollGap(cm) + \\\"px\\\";\\n    display.sizer.style.marginBottom = -display.nativeBarWidth + \\\"px\\\";\\n    display.sizer.style.borderRightWidth = scrollGap(cm) + \\\"px\\\";\\n    display.scrollbarsClipped = true;\\n  }\\n}\\n\\nfunction selectionSnapshot(cm) {\\n  if (cm.hasFocus()) { return null }\\n  var active = activeElt();\\n  if (!active || !contains(cm.display.lineDiv, active)) { return null }\\n  var result = {activeElt: active};\\n  if (window.getSelection) {\\n    var sel = window.getSelection();\\n    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\\n      result.anchorNode = sel.anchorNode;\\n      result.anchorOffset = sel.anchorOffset;\\n      result.focusNode = sel.focusNode;\\n      result.focusOffset = sel.focusOffset;\\n    }\\n  }\\n  return result\\n}\\n\\nfunction restoreSelection(snapshot) {\\n  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\\n  snapshot.activeElt.focus();\\n  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\\n    var sel = window.getSelection(), range$$1 = document.createRange();\\n    range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\\n    range$$1.collapse(false);\\n    sel.removeAllRanges();\\n    sel.addRange(range$$1);\\n    sel.extend(snapshot.focusNode, snapshot.focusOffset);\\n  }\\n}\\n\\n\\u002F\\u002F Does the actual updating of the line display. Bails out\\n\\u002F\\u002F (returning false) when there is nothing to be done and forced is\\n\\u002F\\u002F false.\\nfunction updateDisplayIfNeeded(cm, update) {\\n  var display = cm.display, doc = cm.doc;\\n\\n  if (update.editorIsHidden) {\\n    resetView(cm);\\n    return false\\n  }\\n\\n  \\u002F\\u002F Bail out if the visible area is already rendered and nothing changed.\\n  if (!update.force &&\\n      update.visible.from \\u003E= display.viewFrom && update.visible.to \\u003C= display.viewTo &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers \\u003E= display.viewTo) &&\\n      display.renderedView == display.view && countDirtyView(cm) == 0)\\n    { return false }\\n\\n  if (maybeUpdateLineNumberWidth(cm)) {\\n    resetView(cm);\\n    update.dims = getDimensions(cm);\\n  }\\n\\n  \\u002F\\u002F Compute a suitable new viewport (from & to)\\n  var end = doc.first + doc.size;\\n  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\\n  var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\\n  if (display.viewFrom \\u003C from && from - display.viewFrom \\u003C 20) { from = Math.max(doc.first, display.viewFrom); }\\n  if (display.viewTo \\u003E to && display.viewTo - to \\u003C 20) { to = Math.min(end, display.viewTo); }\\n  if (sawCollapsedSpans) {\\n    from = visualLineNo(cm.doc, from);\\n    to = visualLineEndNo(cm.doc, to);\\n  }\\n\\n  var different = from != display.viewFrom || to != display.viewTo ||\\n    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\\n  adjustView(cm, from, to);\\n\\n  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\\n  \\u002F\\u002F Position the mover div to align with the current scroll position\\n  cm.display.mover.style.top = display.viewOffset + \\\"px\\\";\\n\\n  var toUpdate = countDirtyView(cm);\\n  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\\n      (display.updateLineNumbers == null || display.updateLineNumbers \\u003E= display.viewTo))\\n    { return false }\\n\\n  \\u002F\\u002F For big changes, we hide the enclosing element during the\\n  \\u002F\\u002F update, since that speeds up the operations on most browsers.\\n  var selSnapshot = selectionSnapshot(cm);\\n  if (toUpdate \\u003E 4) { display.lineDiv.style.display = \\\"none\\\"; }\\n  patchDisplay(cm, display.updateLineNumbers, update.dims);\\n  if (toUpdate \\u003E 4) { display.lineDiv.style.display = \\\"\\\"; }\\n  display.renderedView = display.view;\\n  \\u002F\\u002F There might have been a widget with a focused element that got\\n  \\u002F\\u002F hidden or updated, if so re-focus it.\\n  restoreSelection(selSnapshot);\\n\\n  \\u002F\\u002F Prevent selection and cursors from interfering with the scroll\\n  \\u002F\\u002F width and height.\\n  removeChildren(display.cursorDiv);\\n  removeChildren(display.selectionDiv);\\n  display.gutters.style.height = display.sizer.style.minHeight = 0;\\n\\n  if (different) {\\n    display.lastWrapHeight = update.wrapperHeight;\\n    display.lastWrapWidth = update.wrapperWidth;\\n    startWorker(cm, 400);\\n  }\\n\\n  display.updateLineNumbers = null;\\n\\n  return true\\n}\\n\\nfunction postUpdateDisplay(cm, update) {\\n  var viewport = update.viewport;\\n\\n  for (var first = true;; first = false) {\\n    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\\n      \\u002F\\u002F Clip forced viewport to actual scrollable area.\\n      if (viewport && viewport.top != null)\\n        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\\n      \\u002F\\u002F Updated line heights might result in the drawn area not\\n      \\u002F\\u002F actually covering the viewport. Keep looping until it does.\\n      update.visible = visibleLines(cm.display, cm.doc, viewport);\\n      if (update.visible.from \\u003E= cm.display.viewFrom && update.visible.to \\u003C= cm.display.viewTo)\\n        { break }\\n    }\\n    if (!updateDisplayIfNeeded(cm, update)) { break }\\n    updateHeightsInViewport(cm);\\n    var barMeasure = measureForScrollbars(cm);\\n    updateSelection(cm);\\n    updateScrollbars(cm, barMeasure);\\n    setDocumentHeight(cm, barMeasure);\\n    update.force = false;\\n  }\\n\\n  update.signal(cm, \\\"update\\\", cm);\\n  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\\n    update.signal(cm, \\\"viewportChange\\\", cm, cm.display.viewFrom, cm.display.viewTo);\\n    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\\n  }\\n}\\n\\nfunction updateDisplaySimple(cm, viewport) {\\n  var update = new DisplayUpdate(cm, viewport);\\n  if (updateDisplayIfNeeded(cm, update)) {\\n    updateHeightsInViewport(cm);\\n    postUpdateDisplay(cm, update);\\n    var barMeasure = measureForScrollbars(cm);\\n    updateSelection(cm);\\n    updateScrollbars(cm, barMeasure);\\n    setDocumentHeight(cm, barMeasure);\\n    update.finish();\\n  }\\n}\\n\\n\\u002F\\u002F Sync the actual display DOM structure with display.view, removing\\n\\u002F\\u002F nodes for lines that are no longer in view, and creating the ones\\n\\u002F\\u002F that are not there yet, and updating the ones that are out of\\n\\u002F\\u002F date.\\nfunction patchDisplay(cm, updateNumbersFrom, dims) {\\n  var display = cm.display, lineNumbers = cm.options.lineNumbers;\\n  var container = display.lineDiv, cur = container.firstChild;\\n\\n  function rm(node) {\\n    var next = node.nextSibling;\\n    \\u002F\\u002F Works around a throw-scroll bug in OS X Webkit\\n    if (webkit && mac && cm.display.currentWheelTarget == node)\\n      { node.style.display = \\\"none\\\"; }\\n    else\\n      { node.parentNode.removeChild(node); }\\n    return next\\n  }\\n\\n  var view = display.view, lineN = display.viewFrom;\\n  \\u002F\\u002F Loop over the elements in the view, syncing cur (the DOM nodes\\n  \\u002F\\u002F in display.lineDiv) with the view as we go.\\n  for (var i = 0; i \\u003C view.length; i++) {\\n    var lineView = view[i];\\n    if (lineView.hidden) {\\n    } else if (!lineView.node || lineView.node.parentNode != container) { \\u002F\\u002F Not drawn yet\\n      var node = buildLineElement(cm, lineView, lineN, dims);\\n      container.insertBefore(node, cur);\\n    } else { \\u002F\\u002F Already drawn\\n      while (cur != lineView.node) { cur = rm(cur); }\\n      var updateNumber = lineNumbers && updateNumbersFrom != null &&\\n        updateNumbersFrom \\u003C= lineN && lineView.lineNumber;\\n      if (lineView.changes) {\\n        if (indexOf(lineView.changes, \\\"gutter\\\") \\u003E -1) { updateNumber = false; }\\n        updateLineForChanges(cm, lineView, lineN, dims);\\n      }\\n      if (updateNumber) {\\n        removeChildren(lineView.lineNumber);\\n        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\\n      }\\n      cur = lineView.node.nextSibling;\\n    }\\n    lineN += lineView.size;\\n  }\\n  while (cur) { cur = rm(cur); }\\n}\\n\\nfunction updateGutterSpace(cm) {\\n  var width = cm.display.gutters.offsetWidth;\\n  cm.display.sizer.style.marginLeft = width + \\\"px\\\";\\n}\\n\\nfunction setDocumentHeight(cm, measure) {\\n  cm.display.sizer.style.minHeight = measure.docHeight + \\\"px\\\";\\n  cm.display.heightForcer.style.top = measure.docHeight + \\\"px\\\";\\n  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \\\"px\\\";\\n}\\n\\n\\u002F\\u002F Rebuild the gutter elements, ensure the margin to the left of the\\n\\u002F\\u002F code matches their width.\\nfunction updateGutters(cm) {\\n  var gutters = cm.display.gutters, specs = cm.options.gutters;\\n  removeChildren(gutters);\\n  var i = 0;\\n  for (; i \\u003C specs.length; ++i) {\\n    var gutterClass = specs[i];\\n    var gElt = gutters.appendChild(elt(\\\"div\\\", null, \\\"CodeMirror-gutter \\\" + gutterClass));\\n    if (gutterClass == \\\"CodeMirror-linenumbers\\\") {\\n      cm.display.lineGutter = gElt;\\n      gElt.style.width = (cm.display.lineNumWidth || 1) + \\\"px\\\";\\n    }\\n  }\\n  gutters.style.display = i ? \\\"\\\" : \\\"none\\\";\\n  updateGutterSpace(cm);\\n}\\n\\n\\u002F\\u002F Make sure the gutters options contains the element\\n\\u002F\\u002F \\\"CodeMirror-linenumbers\\\" when the lineNumbers option is true.\\nfunction setGuttersForLineNumbers(options) {\\n  var found = indexOf(options.gutters, \\\"CodeMirror-linenumbers\\\");\\n  if (found == -1 && options.lineNumbers) {\\n    options.gutters = options.gutters.concat([\\\"CodeMirror-linenumbers\\\"]);\\n  } else if (found \\u003E -1 && !options.lineNumbers) {\\n    options.gutters = options.gutters.slice(0);\\n    options.gutters.splice(found, 1);\\n  }\\n}\\n\\n\\u002F\\u002F Since the delta values reported on mouse wheel events are\\n\\u002F\\u002F unstandardized between browsers and even browser versions, and\\n\\u002F\\u002F generally horribly unpredictable, this code starts by measuring\\n\\u002F\\u002F the scroll effect that the first few mouse wheel events have,\\n\\u002F\\u002F and, from that, detects the way it can convert deltas to pixel\\n\\u002F\\u002F offsets afterwards.\\n\\u002F\\u002F\\n\\u002F\\u002F The reason we want to know the amount a wheel event will scroll\\n\\u002F\\u002F is that it gives us a chance to update the display before the\\n\\u002F\\u002F actual scrolling happens, reducing flickering.\\n\\nvar wheelSamples = 0;\\nvar wheelPixelsPerUnit = null;\\n\\u002F\\u002F Fill in a browser-detected starting value on browsers where we\\n\\u002F\\u002F know one. These don't have to be accurate -- the result of them\\n\\u002F\\u002F being wrong would just be a slight flicker on the first wheel\\n\\u002F\\u002F scroll (if it is large enough).\\nif (ie) { wheelPixelsPerUnit = -.53; }\\nelse if (gecko) { wheelPixelsPerUnit = 15; }\\nelse if (chrome) { wheelPixelsPerUnit = -.7; }\\nelse if (safari) { wheelPixelsPerUnit = -1\\u002F3; }\\n\\nfunction wheelEventDelta(e) {\\n  var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\\n  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\\n  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\\n  else if (dy == null) { dy = e.wheelDelta; }\\n  return {x: dx, y: dy}\\n}\\nfunction wheelEventPixels(e) {\\n  var delta = wheelEventDelta(e);\\n  delta.x *= wheelPixelsPerUnit;\\n  delta.y *= wheelPixelsPerUnit;\\n  return delta\\n}\\n\\nfunction onScrollWheel(cm, e) {\\n  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\\n\\n  var display = cm.display, scroll = display.scroller;\\n  \\u002F\\u002F Quit if there's nothing to scroll here\\n  var canScrollX = scroll.scrollWidth \\u003E scroll.clientWidth;\\n  var canScrollY = scroll.scrollHeight \\u003E scroll.clientHeight;\\n  if (!(dx && canScrollX || dy && canScrollY)) { return }\\n\\n  \\u002F\\u002F Webkit browsers on OS X abort momentum scrolls when the target\\n  \\u002F\\u002F of the scroll event is removed from the scrollable element.\\n  \\u002F\\u002F This hack (see related code in patchDisplay) makes sure the\\n  \\u002F\\u002F element is kept around.\\n  if (dy && mac && webkit) {\\n    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\\n      for (var i = 0; i \\u003C view.length; i++) {\\n        if (view[i].node == cur) {\\n          cm.display.currentWheelTarget = cur;\\n          break outer\\n        }\\n      }\\n    }\\n  }\\n\\n  \\u002F\\u002F On some browsers, horizontal scrolling will cause redraws to\\n  \\u002F\\u002F happen before the gutter has been realigned, causing it to\\n  \\u002F\\u002F wriggle around in a most unseemly way. When we have an\\n  \\u002F\\u002F estimated pixels\\u002Fdelta value, we just handle horizontal\\n  \\u002F\\u002F scrolling entirely here. It'll be slightly off from native, but\\n  \\u002F\\u002F better than glitching out.\\n  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\\n    if (dy && canScrollY)\\n      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\\n    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\\n    \\u002F\\u002F Only prevent default scrolling if vertical scrolling is\\n    \\u002F\\u002F actually possible. Otherwise, it causes vertical scroll\\n    \\u002F\\u002F jitter on OSX trackpads when deltaX is small and deltaY\\n    \\u002F\\u002F is large (issue #3579)\\n    if (!dy || (dy && canScrollY))\\n      { e_preventDefault(e); }\\n    display.wheelStartX = null; \\u002F\\u002F Abort measurement, if in progress\\n    return\\n  }\\n\\n  \\u002F\\u002F 'Project' the visible viewport to cover the area that is being\\n  \\u002F\\u002F scrolled into view (if we know enough to estimate it).\\n  if (dy && wheelPixelsPerUnit != null) {\\n    var pixels = dy * wheelPixelsPerUnit;\\n    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\\n    if (pixels \\u003C 0) { top = Math.max(0, top + pixels - 50); }\\n    else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\\n    updateDisplaySimple(cm, {top: top, bottom: bot});\\n  }\\n\\n  if (wheelSamples \\u003C 20) {\\n    if (display.wheelStartX == null) {\\n      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\\n      display.wheelDX = dx; display.wheelDY = dy;\\n      setTimeout(function () {\\n        if (display.wheelStartX == null) { return }\\n        var movedX = scroll.scrollLeft - display.wheelStartX;\\n        var movedY = scroll.scrollTop - display.wheelStartY;\\n        var sample = (movedY && display.wheelDY && movedY \\u002F display.wheelDY) ||\\n          (movedX && display.wheelDX && movedX \\u002F display.wheelDX);\\n        display.wheelStartX = display.wheelStartY = null;\\n        if (!sample) { return }\\n        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) \\u002F (wheelSamples + 1);\\n        ++wheelSamples;\\n      }, 200);\\n    } else {\\n      display.wheelDX += dx; display.wheelDY += dy;\\n    }\\n  }\\n}\\n\\n\\u002F\\u002F Selection objects are immutable. A new one is created every time\\n\\u002F\\u002F the selection changes. A selection is one or more non-overlapping\\n\\u002F\\u002F (and non-touching) ranges, sorted, and an integer that indicates\\n\\u002F\\u002F which one is the primary selection (the one that's scrolled into\\n\\u002F\\u002F view, that getCursor returns, etc).\\nvar Selection = function(ranges, primIndex) {\\n  this.ranges = ranges;\\n  this.primIndex = primIndex;\\n};\\n\\nSelection.prototype.primary = function () { return this.ranges[this.primIndex] };\\n\\nSelection.prototype.equals = function (other) {\\n    var this$1 = this;\\n\\n  if (other == this) { return true }\\n  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\\n  for (var i = 0; i \\u003C this.ranges.length; i++) {\\n    var here = this$1.ranges[i], there = other.ranges[i];\\n    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\\n  }\\n  return true\\n};\\n\\nSelection.prototype.deepCopy = function () {\\n    var this$1 = this;\\n\\n  var out = [];\\n  for (var i = 0; i \\u003C this.ranges.length; i++)\\n    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\\n  return new Selection(out, this.primIndex)\\n};\\n\\nSelection.prototype.somethingSelected = function () {\\n    var this$1 = this;\\n\\n  for (var i = 0; i \\u003C this.ranges.length; i++)\\n    { if (!this$1.ranges[i].empty()) { return true } }\\n  return false\\n};\\n\\nSelection.prototype.contains = function (pos, end) {\\n    var this$1 = this;\\n\\n  if (!end) { end = pos; }\\n  for (var i = 0; i \\u003C this.ranges.length; i++) {\\n    var range = this$1.ranges[i];\\n    if (cmp(end, range.from()) \\u003E= 0 && cmp(pos, range.to()) \\u003C= 0)\\n      { return i }\\n  }\\n  return -1\\n};\\n\\nvar Range = function(anchor, head) {\\n  this.anchor = anchor; this.head = head;\\n};\\n\\nRange.prototype.from = function () { return minPos(this.anchor, this.head) };\\nRange.prototype.to = function () { return maxPos(this.anchor, this.head) };\\nRange.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\\n\\n\\u002F\\u002F Take an unsorted, potentially overlapping set of ranges, and\\n\\u002F\\u002F build a selection out of it. 'Consumes' ranges array (modifying\\n\\u002F\\u002F it).\\nfunction normalizeSelection(ranges, primIndex) {\\n  var prim = ranges[primIndex];\\n  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\\n  primIndex = indexOf(ranges, prim);\\n  for (var i = 1; i \\u003C ranges.length; i++) {\\n    var cur = ranges[i], prev = ranges[i - 1];\\n    if (cmp(prev.to(), cur.from()) \\u003E= 0) {\\n      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\\n      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\\n      if (i \\u003C= primIndex) { --primIndex; }\\n      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\\n    }\\n  }\\n  return new Selection(ranges, primIndex)\\n}\\n\\nfunction simpleSelection(anchor, head) {\\n  return new Selection([new Range(anchor, head || anchor)], 0)\\n}\\n\\n\\u002F\\u002F Compute the position of the end of a change (its 'to' property\\n\\u002F\\u002F refers to the pre-change end).\\nfunction changeEnd(change) {\\n  if (!change.text) { return change.to }\\n  return Pos(change.from.line + change.text.length - 1,\\n             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\\n}\\n\\n\\u002F\\u002F Adjust a position to refer to the post-change position of the\\n\\u002F\\u002F same text, or the end of the change if the change covers it.\\nfunction adjustForChange(pos, change) {\\n  if (cmp(pos, change.from) \\u003C 0) { return pos }\\n  if (cmp(pos, change.to) \\u003C= 0) { return changeEnd(change) }\\n\\n  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\\n  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\\n  return Pos(line, ch)\\n}\\n\\nfunction computeSelAfterChange(doc, change) {\\n  var out = [];\\n  for (var i = 0; i \\u003C doc.sel.ranges.length; i++) {\\n    var range = doc.sel.ranges[i];\\n    out.push(new Range(adjustForChange(range.anchor, change),\\n                       adjustForChange(range.head, change)));\\n  }\\n  return normalizeSelection(out, doc.sel.primIndex)\\n}\\n\\nfunction offsetPos(pos, old, nw) {\\n  if (pos.line == old.line)\\n    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\\n  else\\n    { return Pos(nw.line + (pos.line - old.line), pos.ch) }\\n}\\n\\n\\u002F\\u002F Used by replaceSelections to allow moving the selection to the\\n\\u002F\\u002F start or around the replaced test. Hint may be \\\"start\\\" or \\\"around\\\".\\nfunction computeReplacedSel(doc, changes, hint) {\\n  var out = [];\\n  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\\n  for (var i = 0; i \\u003C changes.length; i++) {\\n    var change = changes[i];\\n    var from = offsetPos(change.from, oldPrev, newPrev);\\n    var to = offsetPos(changeEnd(change), oldPrev, newPrev);\\n    oldPrev = change.to;\\n    newPrev = to;\\n    if (hint == \\\"around\\\") {\\n      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) \\u003C 0;\\n      out[i] = new Range(inv ? to : from, inv ? from : to);\\n    } else {\\n      out[i] = new Range(from, from);\\n    }\\n  }\\n  return new Selection(out, doc.sel.primIndex)\\n}\\n\\n\\u002F\\u002F Used to get the editor into a consistent state again when options change.\\n\\nfunction loadMode(cm) {\\n  cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\\n  resetModeState(cm);\\n}\\n\\nfunction resetModeState(cm) {\\n  cm.doc.iter(function (line) {\\n    if (line.stateAfter) { line.stateAfter = null; }\\n    if (line.styles) { line.styles = null; }\\n  });\\n  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\\n  startWorker(cm, 100);\\n  cm.state.modeGen++;\\n  if (cm.curOp) { regChange(cm); }\\n}\\n\\n\\u002F\\u002F DOCUMENT DATA STRUCTURE\\n\\n\\u002F\\u002F By default, updates that start and end at the beginning of a line\\n\\u002F\\u002F are treated specially, in order to make the association of line\\n\\u002F\\u002F widgets and marker elements with the text behave more intuitive.\\nfunction isWholeLineUpdate(doc, change) {\\n  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \\\"\\\" &&\\n    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\\n}\\n\\n\\u002F\\u002F Perform a change on the document data structure.\\nfunction updateDoc(doc, change, markedSpans, estimateHeight$$1) {\\n  function spansFor(n) {return markedSpans ? markedSpans[n] : null}\\n  function update(line, text, spans) {\\n    updateLine(line, text, spans, estimateHeight$$1);\\n    signalLater(line, \\\"change\\\", line, change);\\n  }\\n  function linesFor(start, end) {\\n    var result = [];\\n    for (var i = start; i \\u003C end; ++i)\\n      { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\\n    return result\\n  }\\n\\n  var from = change.from, to = change.to, text = change.text;\\n  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\\n  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\\n\\n  \\u002F\\u002F Adjust the line structure\\n  if (change.full) {\\n    doc.insert(0, linesFor(0, text.length));\\n    doc.remove(text.length, doc.size - text.length);\\n  } else if (isWholeLineUpdate(doc, change)) {\\n    \\u002F\\u002F This is a whole-line replace. Treated specially to make\\n    \\u002F\\u002F sure line objects move the way they are supposed to.\\n    var added = linesFor(0, text.length - 1);\\n    update(lastLine, lastLine.text, lastSpans);\\n    if (nlines) { doc.remove(from.line, nlines); }\\n    if (added.length) { doc.insert(from.line, added); }\\n  } else if (firstLine == lastLine) {\\n    if (text.length == 1) {\\n      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\\n    } else {\\n      var added$1 = linesFor(1, text.length - 1);\\n      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\\n      doc.insert(from.line + 1, added$1);\\n    }\\n  } else if (text.length == 1) {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\\n    doc.remove(from.line + 1, nlines);\\n  } else {\\n    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\\n    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\\n    var added$2 = linesFor(1, text.length - 1);\\n    if (nlines \\u003E 1) { doc.remove(from.line + 1, nlines - 1); }\\n    doc.insert(from.line + 1, added$2);\\n  }\\n\\n  signalLater(doc, \\\"change\\\", doc, change);\\n}\\n\\n\\u002F\\u002F Call f for all linked documents.\\nfunction linkedDocs(doc, f, sharedHistOnly) {\\n  function propagate(doc, skip, sharedHist) {\\n    if (doc.linked) { for (var i = 0; i \\u003C doc.linked.length; ++i) {\\n      var rel = doc.linked[i];\\n      if (rel.doc == skip) { continue }\\n      var shared = sharedHist && rel.sharedHist;\\n      if (sharedHistOnly && !shared) { continue }\\n      f(rel.doc, shared);\\n      propagate(rel.doc, doc, shared);\\n    } }\\n  }\\n  propagate(doc, null, true);\\n}\\n\\n\\u002F\\u002F Attach a document to an editor.\\nfunction attachDoc(cm, doc) {\\n  if (doc.cm) { throw new Error(\\\"This document is already in use.\\\") }\\n  cm.doc = doc;\\n  doc.cm = cm;\\n  estimateLineHeights(cm);\\n  loadMode(cm);\\n  setDirectionClass(cm);\\n  if (!cm.options.lineWrapping) { findMaxLine(cm); }\\n  cm.options.mode = doc.modeOption;\\n  regChange(cm);\\n}\\n\\nfunction setDirectionClass(cm) {\\n  (cm.doc.direction == \\\"rtl\\\" ? addClass : rmClass)(cm.display.lineDiv, \\\"CodeMirror-rtl\\\");\\n}\\n\\nfunction directionChanged(cm) {\\n  runInOp(cm, function () {\\n    setDirectionClass(cm);\\n    regChange(cm);\\n  });\\n}\\n\\nfunction History(startGen) {\\n  \\u002F\\u002F Arrays of change events and selections. Doing something adds an\\n  \\u002F\\u002F event to done and clears undo. Undoing moves events from done\\n  \\u002F\\u002F to undone, redoing moves them in the other direction.\\n  this.done = []; this.undone = [];\\n  this.undoDepth = Infinity;\\n  \\u002F\\u002F Used to track when changes can be merged into a single undo\\n  \\u002F\\u002F event\\n  this.lastModTime = this.lastSelTime = 0;\\n  this.lastOp = this.lastSelOp = null;\\n  this.lastOrigin = this.lastSelOrigin = null;\\n  \\u002F\\u002F Used by the isClean() method\\n  this.generation = this.maxGeneration = startGen || 1;\\n}\\n\\n\\u002F\\u002F Create a history change event from an updateDoc-style change\\n\\u002F\\u002F object.\\nfunction historyChangeFromChange(doc, change) {\\n  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\\n  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\\n  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\\n  return histChange\\n}\\n\\n\\u002F\\u002F Pop all selection events off the end of a history array. Stop at\\n\\u002F\\u002F a change event.\\nfunction clearSelectionEvents(array) {\\n  while (array.length) {\\n    var last = lst(array);\\n    if (last.ranges) { array.pop(); }\\n    else { break }\\n  }\\n}\\n\\n\\u002F\\u002F Find the top change event in the history. Pop off selection\\n\\u002F\\u002F events that are in the way.\\nfunction lastChangeEvent(hist, force) {\\n  if (force) {\\n    clearSelectionEvents(hist.done);\\n    return lst(hist.done)\\n  } else if (hist.done.length && !lst(hist.done).ranges) {\\n    return lst(hist.done)\\n  } else if (hist.done.length \\u003E 1 && !hist.done[hist.done.length - 2].ranges) {\\n    hist.done.pop();\\n    return lst(hist.done)\\n  }\\n}\\n\\n\\u002F\\u002F Register a change in the history. Merges changes that are within\\n\\u002F\\u002F a single operation, or are close together with an origin that\\n\\u002F\\u002F allows merging (starting with \\\"+\\\") into a single event.\\nfunction addChangeToHistory(doc, change, selAfter, opId) {\\n  var hist = doc.history;\\n  hist.undone.length = 0;\\n  var time = +new Date, cur;\\n  var last;\\n\\n  if ((hist.lastOp == opId ||\\n       hist.lastOrigin == change.origin && change.origin &&\\n       ((change.origin.charAt(0) == \\\"+\\\" && doc.cm && hist.lastModTime \\u003E time - doc.cm.options.historyEventDelay) ||\\n        change.origin.charAt(0) == \\\"*\\\")) &&\\n      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\\n    \\u002F\\u002F Merge this change into the last event\\n    last = lst(cur.changes);\\n    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\\n      \\u002F\\u002F Optimized case for simple insertion -- don't want to add\\n      \\u002F\\u002F new changesets for every character typed\\n      last.to = changeEnd(change);\\n    } else {\\n      \\u002F\\u002F Add new sub-event\\n      cur.changes.push(historyChangeFromChange(doc, change));\\n    }\\n  } else {\\n    \\u002F\\u002F Can not be merged, start a new event.\\n    var before = lst(hist.done);\\n    if (!before || !before.ranges)\\n      { pushSelectionToHistory(doc.sel, hist.done); }\\n    cur = {changes: [historyChangeFromChange(doc, change)],\\n           generation: hist.generation};\\n    hist.done.push(cur);\\n    while (hist.done.length \\u003E hist.undoDepth) {\\n      hist.done.shift();\\n      if (!hist.done[0].ranges) { hist.done.shift(); }\\n    }\\n  }\\n  hist.done.push(selAfter);\\n  hist.generation = ++hist.maxGeneration;\\n  hist.lastModTime = hist.lastSelTime = time;\\n  hist.lastOp = hist.lastSelOp = opId;\\n  hist.lastOrigin = hist.lastSelOrigin = change.origin;\\n\\n  if (!last) { signal(doc, \\\"historyAdded\\\"); }\\n}\\n\\nfunction selectionEventCanBeMerged(doc, origin, prev, sel) {\\n  var ch = origin.charAt(0);\\n  return ch == \\\"*\\\" ||\\n    ch == \\\"+\\\" &&\\n    prev.ranges.length == sel.ranges.length &&\\n    prev.somethingSelected() == sel.somethingSelected() &&\\n    new Date - doc.history.lastSelTime \\u003C= (doc.cm ? doc.cm.options.historyEventDelay : 500)\\n}\\n\\n\\u002F\\u002F Called whenever the selection changes, sets the new selection as\\n\\u002F\\u002F the pending selection in the history, and pushes the old pending\\n\\u002F\\u002F selection into the 'done' array when it was significantly\\n\\u002F\\u002F different (in number of selected ranges, emptiness, or time).\\nfunction addSelectionToHistory(doc, sel, opId, options) {\\n  var hist = doc.history, origin = options && options.origin;\\n\\n  \\u002F\\u002F A new event is started when the previous origin does not match\\n  \\u002F\\u002F the current, or the origins don't allow matching. Origins\\n  \\u002F\\u002F starting with * are always merged, those starting with + are\\n  \\u002F\\u002F merged when similar and close together in time.\\n  if (opId == hist.lastSelOp ||\\n      (origin && hist.lastSelOrigin == origin &&\\n       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\\n        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\\n    { hist.done[hist.done.length - 1] = sel; }\\n  else\\n    { pushSelectionToHistory(sel, hist.done); }\\n\\n  hist.lastSelTime = +new Date;\\n  hist.lastSelOrigin = origin;\\n  hist.lastSelOp = opId;\\n  if (options && options.clearRedo !== false)\\n    { clearSelectionEvents(hist.undone); }\\n}\\n\\nfunction pushSelectionToHistory(sel, dest) {\\n  var top = lst(dest);\\n  if (!(top && top.ranges && top.equals(sel)))\\n    { dest.push(sel); }\\n}\\n\\n\\u002F\\u002F Used to store marked span information in the history.\\nfunction attachLocalSpans(doc, change, from, to) {\\n  var existing = change[\\\"spans_\\\" + doc.id], n = 0;\\n  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\\n    if (line.markedSpans)\\n      { (existing || (existing = change[\\\"spans_\\\" + doc.id] = {}))[n] = line.markedSpans; }\\n    ++n;\\n  });\\n}\\n\\n\\u002F\\u002F When un\\u002Fre-doing restores text containing marked spans, those\\n\\u002F\\u002F that have been explicitly cleared should not be restored.\\nfunction removeClearedSpans(spans) {\\n  if (!spans) { return null }\\n  var out;\\n  for (var i = 0; i \\u003C spans.length; ++i) {\\n    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\\n    else if (out) { out.push(spans[i]); }\\n  }\\n  return !out ? spans : out.length ? out : null\\n}\\n\\n\\u002F\\u002F Retrieve and filter the old marked spans stored in a change event.\\nfunction getOldSpans(doc, change) {\\n  var found = change[\\\"spans_\\\" + doc.id];\\n  if (!found) { return null }\\n  var nw = [];\\n  for (var i = 0; i \\u003C change.text.length; ++i)\\n    { nw.push(removeClearedSpans(found[i])); }\\n  return nw\\n}\\n\\n\\u002F\\u002F Used for un\\u002Fre-doing changes from the history. Combines the\\n\\u002F\\u002F result of computing the existing spans with the set of spans that\\n\\u002F\\u002F existed in the history (so that deleting around a span and then\\n\\u002F\\u002F undoing brings back the span).\\nfunction mergeOldSpans(doc, change) {\\n  var old = getOldSpans(doc, change);\\n  var stretched = stretchSpansOverChange(doc, change);\\n  if (!old) { return stretched }\\n  if (!stretched) { return old }\\n\\n  for (var i = 0; i \\u003C old.length; ++i) {\\n    var oldCur = old[i], stretchCur = stretched[i];\\n    if (oldCur && stretchCur) {\\n      spans: for (var j = 0; j \\u003C stretchCur.length; ++j) {\\n        var span = stretchCur[j];\\n        for (var k = 0; k \\u003C oldCur.length; ++k)\\n          { if (oldCur[k].marker == span.marker) { continue spans } }\\n        oldCur.push(span);\\n      }\\n    } else if (stretchCur) {\\n      old[i] = stretchCur;\\n    }\\n  }\\n  return old\\n}\\n\\n\\u002F\\u002F Used both to provide a JSON-safe object in .getHistory, and, when\\n\\u002F\\u002F detaching a document, to split the history in two\\nfunction copyHistoryArray(events, newGroup, instantiateSel) {\\n  var copy = [];\\n  for (var i = 0; i \\u003C events.length; ++i) {\\n    var event = events[i];\\n    if (event.ranges) {\\n      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\\n      continue\\n    }\\n    var changes = event.changes, newChanges = [];\\n    copy.push({changes: newChanges});\\n    for (var j = 0; j \\u003C changes.length; ++j) {\\n      var change = changes[j], m = (void 0);\\n      newChanges.push({from: change.from, to: change.to, text: change.text});\\n      if (newGroup) { for (var prop in change) { if (m = prop.match(\\u002F^spans_(\\\\d+)$\\u002F)) {\\n        if (indexOf(newGroup, Number(m[1])) \\u003E -1) {\\n          lst(newChanges)[prop] = change[prop];\\n          delete change[prop];\\n        }\\n      } } }\\n    }\\n  }\\n  return copy\\n}\\n\\n\\u002F\\u002F The 'scroll' parameter given to many of these indicated whether\\n\\u002F\\u002F the new cursor position should be scrolled into view after\\n\\u002F\\u002F modifying the selection.\\n\\n\\u002F\\u002F If shift is held or the extend flag is set, extends a range to\\n\\u002F\\u002F include a given position (and optionally a second position).\\n\\u002F\\u002F Otherwise, simply returns the range between the given positions.\\n\\u002F\\u002F Used for cursor motion and such.\\nfunction extendRange(range, head, other, extend) {\\n  if (extend) {\\n    var anchor = range.anchor;\\n    if (other) {\\n      var posBefore = cmp(head, anchor) \\u003C 0;\\n      if (posBefore != (cmp(other, anchor) \\u003C 0)) {\\n        anchor = head;\\n        head = other;\\n      } else if (posBefore != (cmp(head, other) \\u003C 0)) {\\n        head = other;\\n      }\\n    }\\n    return new Range(anchor, head)\\n  } else {\\n    return new Range(other || head, head)\\n  }\\n}\\n\\n\\u002F\\u002F Extend the primary selection range, discard the rest.\\nfunction extendSelection(doc, head, other, options, extend) {\\n  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\\n  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\\n}\\n\\n\\u002F\\u002F Extend all selections (pos is an array of selections with length\\n\\u002F\\u002F equal the number of selections)\\nfunction extendSelections(doc, heads, options) {\\n  var out = [];\\n  var extend = doc.cm && (doc.cm.display.shift || doc.extend);\\n  for (var i = 0; i \\u003C doc.sel.ranges.length; i++)\\n    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\\n  var newSel = normalizeSelection(out, doc.sel.primIndex);\\n  setSelection(doc, newSel, options);\\n}\\n\\n\\u002F\\u002F Updates a single range in the selection.\\nfunction replaceOneSelection(doc, i, range, options) {\\n  var ranges = doc.sel.ranges.slice(0);\\n  ranges[i] = range;\\n  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\\n}\\n\\n\\u002F\\u002F Reset the selection to a single range.\\nfunction setSimpleSelection(doc, anchor, head, options) {\\n  setSelection(doc, simpleSelection(anchor, head), options);\\n}\\n\\n\\u002F\\u002F Give beforeSelectionChange handlers a change to influence a\\n\\u002F\\u002F selection update.\\nfunction filterSelectionChange(doc, sel, options) {\\n  var obj = {\\n    ranges: sel.ranges,\\n    update: function(ranges) {\\n      var this$1 = this;\\n\\n      this.ranges = [];\\n      for (var i = 0; i \\u003C ranges.length; i++)\\n        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\\n                                   clipPos(doc, ranges[i].head)); }\\n    },\\n    origin: options && options.origin\\n  };\\n  signal(doc, \\\"beforeSelectionChange\\\", doc, obj);\\n  if (doc.cm) { signal(doc.cm, \\\"beforeSelectionChange\\\", doc.cm, obj); }\\n  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }\\n  else { return sel }\\n}\\n\\nfunction setSelectionReplaceHistory(doc, sel, options) {\\n  var done = doc.history.done, last = lst(done);\\n  if (last && last.ranges) {\\n    done[done.length - 1] = sel;\\n    setSelectionNoUndo(doc, sel, options);\\n  } else {\\n    setSelection(doc, sel, options);\\n  }\\n}\\n\\n\\u002F\\u002F Set a new selection.\\nfunction setSelection(doc, sel, options) {\\n  setSelectionNoUndo(doc, sel, options);\\n  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\\n}\\n\\nfunction setSelectionNoUndo(doc, sel, options) {\\n  if (hasHandler(doc, \\\"beforeSelectionChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeSelectionChange\\\"))\\n    { sel = filterSelectionChange(doc, sel, options); }\\n\\n  var bias = options && options.bias ||\\n    (cmp(sel.primary().head, doc.sel.primary().head) \\u003C 0 ? -1 : 1);\\n  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\\n\\n  if (!(options && options.scroll === false) && doc.cm)\\n    { ensureCursorVisible(doc.cm); }\\n}\\n\\nfunction setSelectionInner(doc, sel) {\\n  if (sel.equals(doc.sel)) { return }\\n\\n  doc.sel = sel;\\n\\n  if (doc.cm) {\\n    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\\n    signalCursorActivity(doc.cm);\\n  }\\n  signalLater(doc, \\\"cursorActivity\\\", doc);\\n}\\n\\n\\u002F\\u002F Verify that the selection does not partially select any atomic\\n\\u002F\\u002F marked ranges.\\nfunction reCheckSelection(doc) {\\n  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\\n}\\n\\n\\u002F\\u002F Return a selection that does not partially select any atomic\\n\\u002F\\u002F ranges.\\nfunction skipAtomicInSelection(doc, sel, bias, mayClear) {\\n  var out;\\n  for (var i = 0; i \\u003C sel.ranges.length; i++) {\\n    var range = sel.ranges[i];\\n    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\\n    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\\n    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\\n    if (out || newAnchor != range.anchor || newHead != range.head) {\\n      if (!out) { out = sel.ranges.slice(0, i); }\\n      out[i] = new Range(newAnchor, newHead);\\n    }\\n  }\\n  return out ? normalizeSelection(out, sel.primIndex) : sel\\n}\\n\\nfunction skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\\n  var line = getLine(doc, pos.line);\\n  if (line.markedSpans) { for (var i = 0; i \\u003C line.markedSpans.length; ++i) {\\n    var sp = line.markedSpans[i], m = sp.marker;\\n    if ((sp.from == null || (m.inclusiveLeft ? sp.from \\u003C= pos.ch : sp.from \\u003C pos.ch)) &&\\n        (sp.to == null || (m.inclusiveRight ? sp.to \\u003E= pos.ch : sp.to \\u003E pos.ch))) {\\n      if (mayClear) {\\n        signal(m, \\\"beforeCursorEnter\\\");\\n        if (m.explicitlyCleared) {\\n          if (!line.markedSpans) { break }\\n          else {--i; continue}\\n        }\\n      }\\n      if (!m.atomic) { continue }\\n\\n      if (oldPos) {\\n        var near = m.find(dir \\u003C 0 ? 1 : -1), diff = (void 0);\\n        if (dir \\u003C 0 ? m.inclusiveRight : m.inclusiveLeft)\\n          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\\n        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir \\u003C 0 ? diff \\u003C 0 : diff \\u003E 0))\\n          { return skipAtomicInner(doc, near, pos, dir, mayClear) }\\n      }\\n\\n      var far = m.find(dir \\u003C 0 ? -1 : 1);\\n      if (dir \\u003C 0 ? m.inclusiveLeft : m.inclusiveRight)\\n        { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\\n      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\\n    }\\n  } }\\n  return pos\\n}\\n\\n\\u002F\\u002F Ensure a given position is not inside an atomic range.\\nfunction skipAtomic(doc, pos, oldPos, bias, mayClear) {\\n  var dir = bias || 1;\\n  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\\n      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\\n      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\\n  if (!found) {\\n    doc.cantEdit = true;\\n    return Pos(doc.first, 0)\\n  }\\n  return found\\n}\\n\\nfunction movePos(doc, pos, dir, line) {\\n  if (dir \\u003C 0 && pos.ch == 0) {\\n    if (pos.line \\u003E doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\\n    else { return null }\\n  } else if (dir \\u003E 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\\n    if (pos.line \\u003C doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\\n    else { return null }\\n  } else {\\n    return new Pos(pos.line, pos.ch + dir)\\n  }\\n}\\n\\nfunction selectAll(cm) {\\n  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\\n}\\n\\n\\u002F\\u002F UPDATING\\n\\n\\u002F\\u002F Allow \\\"beforeChange\\\" event handlers to influence a change\\nfunction filterChange(doc, change, update) {\\n  var obj = {\\n    canceled: false,\\n    from: change.from,\\n    to: change.to,\\n    text: change.text,\\n    origin: change.origin,\\n    cancel: function () { return obj.canceled = true; }\\n  };\\n  if (update) { obj.update = function (from, to, text, origin) {\\n    if (from) { obj.from = clipPos(doc, from); }\\n    if (to) { obj.to = clipPos(doc, to); }\\n    if (text) { obj.text = text; }\\n    if (origin !== undefined) { obj.origin = origin; }\\n  }; }\\n  signal(doc, \\\"beforeChange\\\", doc, obj);\\n  if (doc.cm) { signal(doc.cm, \\\"beforeChange\\\", doc.cm, obj); }\\n\\n  if (obj.canceled) { return null }\\n  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\\n}\\n\\n\\u002F\\u002F Apply a change to a document, and add it to the document's\\n\\u002F\\u002F history, and propagating it to all linked documents.\\nfunction makeChange(doc, change, ignoreReadOnly) {\\n  if (doc.cm) {\\n    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\\n    if (doc.cm.state.suppressEdits) { return }\\n  }\\n\\n  if (hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\")) {\\n    change = filterChange(doc, change, true);\\n    if (!change) { return }\\n  }\\n\\n  \\u002F\\u002F Possibly split or suppress the update based on the presence\\n  \\u002F\\u002F of read-only spans in its range.\\n  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\\n  if (split) {\\n    for (var i = split.length - 1; i \\u003E= 0; --i)\\n      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\\\"\\\"] : change.text, origin: change.origin}); }\\n  } else {\\n    makeChangeInner(doc, change);\\n  }\\n}\\n\\nfunction makeChangeInner(doc, change) {\\n  if (change.text.length == 1 && change.text[0] == \\\"\\\" && cmp(change.from, change.to) == 0) { return }\\n  var selAfter = computeSelAfterChange(doc, change);\\n  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\\n\\n  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\\n  var rebased = [];\\n\\n  linkedDocs(doc, function (doc, sharedHist) {\\n    if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n      rebaseHist(doc.history, change);\\n      rebased.push(doc.history);\\n    }\\n    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\\n  });\\n}\\n\\n\\u002F\\u002F Revert a change stored in a document's history.\\nfunction makeChangeFromHistory(doc, type, allowSelectionOnly) {\\n  var suppress = doc.cm && doc.cm.state.suppressEdits;\\n  if (suppress && !allowSelectionOnly) { return }\\n\\n  var hist = doc.history, event, selAfter = doc.sel;\\n  var source = type == \\\"undo\\\" ? hist.done : hist.undone, dest = type == \\\"undo\\\" ? hist.undone : hist.done;\\n\\n  \\u002F\\u002F Verify that there is a useable event (so that ctrl-z won't\\n  \\u002F\\u002F needlessly clear selection events)\\n  var i = 0;\\n  for (; i \\u003C source.length; i++) {\\n    event = source[i];\\n    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\\n      { break }\\n  }\\n  if (i == source.length) { return }\\n  hist.lastOrigin = hist.lastSelOrigin = null;\\n\\n  for (;;) {\\n    event = source.pop();\\n    if (event.ranges) {\\n      pushSelectionToHistory(event, dest);\\n      if (allowSelectionOnly && !event.equals(doc.sel)) {\\n        setSelection(doc, event, {clearRedo: false});\\n        return\\n      }\\n      selAfter = event;\\n    } else if (suppress) {\\n      source.push(event);\\n      return\\n    } else { break }\\n  }\\n\\n  \\u002F\\u002F Build up a reverse change object to add to the opposite history\\n  \\u002F\\u002F stack (redo when undoing, and vice versa).\\n  var antiChanges = [];\\n  pushSelectionToHistory(selAfter, dest);\\n  dest.push({changes: antiChanges, generation: hist.generation});\\n  hist.generation = event.generation || ++hist.maxGeneration;\\n\\n  var filter = hasHandler(doc, \\\"beforeChange\\\") || doc.cm && hasHandler(doc.cm, \\\"beforeChange\\\");\\n\\n  var loop = function ( i ) {\\n    var change = event.changes[i];\\n    change.origin = type;\\n    if (filter && !filterChange(doc, change, false)) {\\n      source.length = 0;\\n      return {}\\n    }\\n\\n    antiChanges.push(historyChangeFromChange(doc, change));\\n\\n    var after = i ? computeSelAfterChange(doc, change) : lst(source);\\n    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\\n    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\\n    var rebased = [];\\n\\n    \\u002F\\u002F Propagate to the linked documents\\n    linkedDocs(doc, function (doc, sharedHist) {\\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\\n        rebaseHist(doc.history, change);\\n        rebased.push(doc.history);\\n      }\\n      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\\n    });\\n  };\\n\\n  for (var i$1 = event.changes.length - 1; i$1 \\u003E= 0; --i$1) {\\n    var returned = loop( i$1 );\\n\\n    if ( returned ) return returned.v;\\n  }\\n}\\n\\n\\u002F\\u002F Sub-views need their line numbers shifted when text is added\\n\\u002F\\u002F above or below them in the parent document.\\nfunction shiftDoc(doc, distance) {\\n  if (distance == 0) { return }\\n  doc.first += distance;\\n  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\\n    Pos(range.anchor.line + distance, range.anchor.ch),\\n    Pos(range.head.line + distance, range.head.ch)\\n  ); }), doc.sel.primIndex);\\n  if (doc.cm) {\\n    regChange(doc.cm, doc.first, doc.first - distance, distance);\\n    for (var d = doc.cm.display, l = d.viewFrom; l \\u003C d.viewTo; l++)\\n      { regLineChange(doc.cm, l, \\\"gutter\\\"); }\\n  }\\n}\\n\\n\\u002F\\u002F More lower-level change function, handling only a single document\\n\\u002F\\u002F (not linked ones).\\nfunction makeChangeSingleDoc(doc, change, selAfter, spans) {\\n  if (doc.cm && !doc.cm.curOp)\\n    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\\n\\n  if (change.to.line \\u003C doc.first) {\\n    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\\n    return\\n  }\\n  if (change.from.line \\u003E doc.lastLine()) { return }\\n\\n  \\u002F\\u002F Clip the change to the size of this doc\\n  if (change.from.line \\u003C doc.first) {\\n    var shift = change.text.length - 1 - (doc.first - change.from.line);\\n    shiftDoc(doc, shift);\\n    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\\n              text: [lst(change.text)], origin: change.origin};\\n  }\\n  var last = doc.lastLine();\\n  if (change.to.line \\u003E last) {\\n    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\\n              text: [change.text[0]], origin: change.origin};\\n  }\\n\\n  change.removed = getBetween(doc, change.from, change.to);\\n\\n  if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\\n  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\\n  else { updateDoc(doc, change, spans); }\\n  setSelectionNoUndo(doc, selAfter, sel_dontScroll);\\n}\\n\\n\\u002F\\u002F Handle the interaction of a change to a document with the editor\\n\\u002F\\u002F that this document is part of.\\nfunction makeChangeSingleDocInEditor(cm, change, spans) {\\n  var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\\n\\n  var recomputeMaxLength = false, checkWidthStart = from.line;\\n  if (!cm.options.lineWrapping) {\\n    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\\n    doc.iter(checkWidthStart, to.line + 1, function (line) {\\n      if (line == display.maxLine) {\\n        recomputeMaxLength = true;\\n        return true\\n      }\\n    });\\n  }\\n\\n  if (doc.sel.contains(change.from, change.to) \\u003E -1)\\n    { signalCursorActivity(cm); }\\n\\n  updateDoc(doc, change, spans, estimateHeight(cm));\\n\\n  if (!cm.options.lineWrapping) {\\n    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\\n      var len = lineLength(line);\\n      if (len \\u003E display.maxLineLength) {\\n        display.maxLine = line;\\n        display.maxLineLength = len;\\n        display.maxLineChanged = true;\\n        recomputeMaxLength = false;\\n      }\\n    });\\n    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\\n  }\\n\\n  retreatFrontier(doc, from.line);\\n  startWorker(cm, 400);\\n\\n  var lendiff = change.text.length - (to.line - from.line) - 1;\\n  \\u002F\\u002F Remember that these lines changed, for updating the display\\n  if (change.full)\\n    { regChange(cm); }\\n  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\\n    { regLineChange(cm, from.line, \\\"text\\\"); }\\n  else\\n    { regChange(cm, from.line, to.line + 1, lendiff); }\\n\\n  var changesHandler = hasHandler(cm, \\\"changes\\\"), changeHandler = hasHandler(cm, \\\"change\\\");\\n  if (changeHandler || changesHandler) {\\n    var obj = {\\n      from: from, to: to,\\n      text: change.text,\\n      removed: change.removed,\\n      origin: change.origin\\n    };\\n    if (changeHandler) { signalLater(cm, \\\"change\\\", cm, obj); }\\n    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\\n  }\\n  cm.display.selForContextMenu = null;\\n}\\n\\nfunction replaceRange(doc, code, from, to, origin) {\\n  if (!to) { to = from; }\\n  if (cmp(to, from) \\u003C 0) { var assign;\\n    (assign = [to, from], from = assign[0], to = assign[1], assign); }\\n  if (typeof code == \\\"string\\\") { code = doc.splitLines(code); }\\n  makeChange(doc, {from: from, to: to, text: code, origin: origin});\\n}\\n\\n\\u002F\\u002F Rebasing\\u002Fresetting history to deal with externally-sourced changes\\n\\nfunction rebaseHistSelSingle(pos, from, to, diff) {\\n  if (to \\u003C pos.line) {\\n    pos.line += diff;\\n  } else if (from \\u003C pos.line) {\\n    pos.line = from;\\n    pos.ch = 0;\\n  }\\n}\\n\\n\\u002F\\u002F Tries to rebase an array of history events given a change in the\\n\\u002F\\u002F document. If the change touches the same lines as the event, the\\n\\u002F\\u002F event, and everything 'behind' it, is discarded. If the change is\\n\\u002F\\u002F before the event, the event's positions are updated. Uses a\\n\\u002F\\u002F copy-on-write scheme for the positions, to avoid having to\\n\\u002F\\u002F reallocate them all on every rebase, but also avoid problems with\\n\\u002F\\u002F shared position objects being unsafely updated.\\nfunction rebaseHistArray(array, from, to, diff) {\\n  for (var i = 0; i \\u003C array.length; ++i) {\\n    var sub = array[i], ok = true;\\n    if (sub.ranges) {\\n      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\\n      for (var j = 0; j \\u003C sub.ranges.length; j++) {\\n        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\\n        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\\n      }\\n      continue\\n    }\\n    for (var j$1 = 0; j$1 \\u003C sub.changes.length; ++j$1) {\\n      var cur = sub.changes[j$1];\\n      if (to \\u003C cur.from.line) {\\n        cur.from = Pos(cur.from.line + diff, cur.from.ch);\\n        cur.to = Pos(cur.to.line + diff, cur.to.ch);\\n      } else if (from \\u003C= cur.to.line) {\\n        ok = false;\\n        break\\n      }\\n    }\\n    if (!ok) {\\n      array.splice(0, i + 1);\\n      i = 0;\\n    }\\n  }\\n}\\n\\nfunction rebaseHist(hist, change) {\\n  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\\n  rebaseHistArray(hist.done, from, to, diff);\\n  rebaseHistArray(hist.undone, from, to, diff);\\n}\\n\\n\\u002F\\u002F Utility for applying a change to a line by handle or number,\\n\\u002F\\u002F returning the number and optionally registering the line as\\n\\u002F\\u002F changed.\\nfunction changeLine(doc, handle, changeType, op) {\\n  var no = handle, line = handle;\\n  if (typeof handle == \\\"number\\\") { line = getLine(doc, clipLine(doc, handle)); }\\n  else { no = lineNo(handle); }\\n  if (no == null) { return null }\\n  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\\n  return line\\n}\\n\\n\\u002F\\u002F The document is represented as a BTree consisting of leaves, with\\n\\u002F\\u002F chunk of lines in them, and branches, with up to ten leaves or\\n\\u002F\\u002F other branch nodes below them. The top node is always a branch\\n\\u002F\\u002F node, and is the document object itself (meaning it has\\n\\u002F\\u002F additional methods and properties).\\n\\u002F\\u002F\\n\\u002F\\u002F All nodes have parent links. The tree is used both to go from\\n\\u002F\\u002F line numbers to line objects, and to go from objects to numbers.\\n\\u002F\\u002F It also indexes by height, and is used to convert between height\\n\\u002F\\u002F and line object, and to find the total height of the document.\\n\\u002F\\u002F\\n\\u002F\\u002F See also http:\\u002F\\u002Fmarijnhaverbeke.nl\\u002Fblog\\u002Fcodemirror-line-tree.html\\n\\nfunction LeafChunk(lines) {\\n  var this$1 = this;\\n\\n  this.lines = lines;\\n  this.parent = null;\\n  var height = 0;\\n  for (var i = 0; i \\u003C lines.length; ++i) {\\n    lines[i].parent = this$1;\\n    height += lines[i].height;\\n  }\\n  this.height = height;\\n}\\n\\nLeafChunk.prototype = {\\n  chunkSize: function chunkSize() { return this.lines.length },\\n\\n  \\u002F\\u002F Remove the n lines at offset 'at'.\\n  removeInner: function removeInner(at, n) {\\n    var this$1 = this;\\n\\n    for (var i = at, e = at + n; i \\u003C e; ++i) {\\n      var line = this$1.lines[i];\\n      this$1.height -= line.height;\\n      cleanUpLine(line);\\n      signalLater(line, \\\"delete\\\");\\n    }\\n    this.lines.splice(at, n);\\n  },\\n\\n  \\u002F\\u002F Helper used to collapse a small branch into a single leaf.\\n  collapse: function collapse(lines) {\\n    lines.push.apply(lines, this.lines);\\n  },\\n\\n  \\u002F\\u002F Insert the given array of lines at offset 'at', count them as\\n  \\u002F\\u002F having the given height.\\n  insertInner: function insertInner(at, lines, height) {\\n    var this$1 = this;\\n\\n    this.height += height;\\n    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\\n    for (var i = 0; i \\u003C lines.length; ++i) { lines[i].parent = this$1; }\\n  },\\n\\n  \\u002F\\u002F Used to iterate over a part of the tree.\\n  iterN: function iterN(at, n, op) {\\n    var this$1 = this;\\n\\n    for (var e = at + n; at \\u003C e; ++at)\\n      { if (op(this$1.lines[at])) { return true } }\\n  }\\n};\\n\\nfunction BranchChunk(children) {\\n  var this$1 = this;\\n\\n  this.children = children;\\n  var size = 0, height = 0;\\n  for (var i = 0; i \\u003C children.length; ++i) {\\n    var ch = children[i];\\n    size += ch.chunkSize(); height += ch.height;\\n    ch.parent = this$1;\\n  }\\n  this.size = size;\\n  this.height = height;\\n  this.parent = null;\\n}\\n\\nBranchChunk.prototype = {\\n  chunkSize: function chunkSize() { return this.size },\\n\\n  removeInner: function removeInner(at, n) {\\n    var this$1 = this;\\n\\n    this.size -= n;\\n    for (var i = 0; i \\u003C this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize();\\n      if (at \\u003C sz) {\\n        var rm = Math.min(n, sz - at), oldHeight = child.height;\\n        child.removeInner(at, rm);\\n        this$1.height -= oldHeight - child.height;\\n        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\\n        if ((n -= rm) == 0) { break }\\n        at = 0;\\n      } else { at -= sz; }\\n    }\\n    \\u002F\\u002F If the result is smaller than 25 lines, ensure that it is a\\n    \\u002F\\u002F single leaf node.\\n    if (this.size - n \\u003C 25 &&\\n        (this.children.length \\u003E 1 || !(this.children[0] instanceof LeafChunk))) {\\n      var lines = [];\\n      this.collapse(lines);\\n      this.children = [new LeafChunk(lines)];\\n      this.children[0].parent = this;\\n    }\\n  },\\n\\n  collapse: function collapse(lines) {\\n    var this$1 = this;\\n\\n    for (var i = 0; i \\u003C this.children.length; ++i) { this$1.children[i].collapse(lines); }\\n  },\\n\\n  insertInner: function insertInner(at, lines, height) {\\n    var this$1 = this;\\n\\n    this.size += lines.length;\\n    this.height += height;\\n    for (var i = 0; i \\u003C this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize();\\n      if (at \\u003C= sz) {\\n        child.insertInner(at, lines, height);\\n        if (child.lines && child.lines.length \\u003E 50) {\\n          \\u002F\\u002F To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\\n          \\u002F\\u002F Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\\n          var remaining = child.lines.length % 25 + 25;\\n          for (var pos = remaining; pos \\u003C child.lines.length;) {\\n            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\\n            child.height -= leaf.height;\\n            this$1.children.splice(++i, 0, leaf);\\n            leaf.parent = this$1;\\n          }\\n          child.lines = child.lines.slice(0, remaining);\\n          this$1.maybeSpill();\\n        }\\n        break\\n      }\\n      at -= sz;\\n    }\\n  },\\n\\n  \\u002F\\u002F When a node has grown, check whether it should be split.\\n  maybeSpill: function maybeSpill() {\\n    if (this.children.length \\u003C= 10) { return }\\n    var me = this;\\n    do {\\n      var spilled = me.children.splice(me.children.length - 5, 5);\\n      var sibling = new BranchChunk(spilled);\\n      if (!me.parent) { \\u002F\\u002F Become the parent node\\n        var copy = new BranchChunk(me.children);\\n        copy.parent = me;\\n        me.children = [copy, sibling];\\n        me = copy;\\n     } else {\\n        me.size -= sibling.size;\\n        me.height -= sibling.height;\\n        var myIndex = indexOf(me.parent.children, me);\\n        me.parent.children.splice(myIndex + 1, 0, sibling);\\n      }\\n      sibling.parent = me.parent;\\n    } while (me.children.length \\u003E 10)\\n    me.parent.maybeSpill();\\n  },\\n\\n  iterN: function iterN(at, n, op) {\\n    var this$1 = this;\\n\\n    for (var i = 0; i \\u003C this.children.length; ++i) {\\n      var child = this$1.children[i], sz = child.chunkSize();\\n      if (at \\u003C sz) {\\n        var used = Math.min(n, sz - at);\\n        if (child.iterN(at, used, op)) { return true }\\n        if ((n -= used) == 0) { break }\\n        at = 0;\\n      } else { at -= sz; }\\n    }\\n  }\\n};\\n\\n\\u002F\\u002F Line widgets are block elements displayed above or below a line.\\n\\nvar LineWidget = function(doc, node, options) {\\n  var this$1 = this;\\n\\n  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\\n    { this$1[opt] = options[opt]; } } }\\n  this.doc = doc;\\n  this.node = node;\\n};\\n\\nLineWidget.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\\n  if (no == null || !ws) { return }\\n  for (var i = 0; i \\u003C ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\\n  if (!ws.length) { line.widgets = null; }\\n  var height = widgetHeight(this);\\n  updateLineHeight(line, Math.max(0, line.height - height));\\n  if (cm) {\\n    runInOp(cm, function () {\\n      adjustScrollWhenAboveVisible(cm, line, -height);\\n      regLineChange(cm, no, \\\"widget\\\");\\n    });\\n    signalLater(cm, \\\"lineWidgetCleared\\\", cm, this, no);\\n  }\\n};\\n\\nLineWidget.prototype.changed = function () {\\n    var this$1 = this;\\n\\n  var oldH = this.height, cm = this.doc.cm, line = this.line;\\n  this.height = null;\\n  var diff = widgetHeight(this) - oldH;\\n  if (!diff) { return }\\n  updateLineHeight(line, line.height + diff);\\n  if (cm) {\\n    runInOp(cm, function () {\\n      cm.curOp.forceUpdate = true;\\n      adjustScrollWhenAboveVisible(cm, line, diff);\\n      signalLater(cm, \\\"lineWidgetChanged\\\", cm, this$1, lineNo(line));\\n    });\\n  }\\n};\\neventMixin(LineWidget);\\n\\nfunction adjustScrollWhenAboveVisible(cm, line, diff) {\\n  if (heightAtLine(line) \\u003C ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\\n    { addToScrollTop(cm, diff); }\\n}\\n\\nfunction addLineWidget(doc, handle, node, options) {\\n  var widget = new LineWidget(doc, node, options);\\n  var cm = doc.cm;\\n  if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\\n  changeLine(doc, handle, \\\"widget\\\", function (line) {\\n    var widgets = line.widgets || (line.widgets = []);\\n    if (widget.insertAt == null) { widgets.push(widget); }\\n    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\\n    widget.line = line;\\n    if (cm && !lineIsHidden(doc, line)) {\\n      var aboveVisible = heightAtLine(line) \\u003C doc.scrollTop;\\n      updateLineHeight(line, line.height + widgetHeight(widget));\\n      if (aboveVisible) { addToScrollTop(cm, widget.height); }\\n      cm.curOp.forceUpdate = true;\\n    }\\n    return true\\n  });\\n  if (cm) { signalLater(cm, \\\"lineWidgetAdded\\\", cm, widget, typeof handle == \\\"number\\\" ? handle : lineNo(handle)); }\\n  return widget\\n}\\n\\n\\u002F\\u002F TEXTMARKERS\\n\\n\\u002F\\u002F Created with markText and setBookmark methods. A TextMarker is a\\n\\u002F\\u002F handle that can be used to clear or find a marked position in the\\n\\u002F\\u002F document. Line objects hold arrays (markedSpans) containing\\n\\u002F\\u002F {from, to, marker} object pointing to such marker objects, and\\n\\u002F\\u002F indicating that such a marker is present on that line. Multiple\\n\\u002F\\u002F lines may point to the same marker when it spans across lines.\\n\\u002F\\u002F The spans will have null for their from\\u002Fto properties when the\\n\\u002F\\u002F marker continues beyond the start\\u002Fend of the line. Markers have\\n\\u002F\\u002F links back to the lines they currently touch.\\n\\n\\u002F\\u002F Collapsed markers have unique ids, in order to be able to order\\n\\u002F\\u002F them, which is needed for uniquely determining an outer marker\\n\\u002F\\u002F when they overlap (they may nest, but not partially overlap).\\nvar nextMarkerId = 0;\\n\\nvar TextMarker = function(doc, type) {\\n  this.lines = [];\\n  this.type = type;\\n  this.doc = doc;\\n  this.id = ++nextMarkerId;\\n};\\n\\n\\u002F\\u002F Clear the marker.\\nTextMarker.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  var cm = this.doc.cm, withOp = cm && !cm.curOp;\\n  if (withOp) { startOperation(cm); }\\n  if (hasHandler(this, \\\"clear\\\")) {\\n    var found = this.find();\\n    if (found) { signalLater(this, \\\"clear\\\", found.from, found.to); }\\n  }\\n  var min = null, max = null;\\n  for (var i = 0; i \\u003C this.lines.length; ++i) {\\n    var line = this$1.lines[i];\\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\\n    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \\\"text\\\"); }\\n    else if (cm) {\\n      if (span.to != null) { max = lineNo(line); }\\n      if (span.from != null) { min = lineNo(line); }\\n    }\\n    line.markedSpans = removeMarkedSpan(line.markedSpans, span);\\n    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\\n      { updateLineHeight(line, textHeight(cm.display)); }\\n  }\\n  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 \\u003C this.lines.length; ++i$1) {\\n    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\\n    if (len \\u003E cm.display.maxLineLength) {\\n      cm.display.maxLine = visual;\\n      cm.display.maxLineLength = len;\\n      cm.display.maxLineChanged = true;\\n    }\\n  } }\\n\\n  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\\n  this.lines.length = 0;\\n  this.explicitlyCleared = true;\\n  if (this.atomic && this.doc.cantEdit) {\\n    this.doc.cantEdit = false;\\n    if (cm) { reCheckSelection(cm.doc); }\\n  }\\n  if (cm) { signalLater(cm, \\\"markerCleared\\\", cm, this, min, max); }\\n  if (withOp) { endOperation(cm); }\\n  if (this.parent) { this.parent.clear(); }\\n};\\n\\n\\u002F\\u002F Find the position of the marker in the document. Returns a {from,\\n\\u002F\\u002F to} object by default. Side can be passed to get a specific side\\n\\u002F\\u002F -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\\n\\u002F\\u002F Pos objects returned contain a line object, rather than a line\\n\\u002F\\u002F number (used to prevent looking up the same line twice).\\nTextMarker.prototype.find = function (side, lineObj) {\\n    var this$1 = this;\\n\\n  if (side == null && this.type == \\\"bookmark\\\") { side = 1; }\\n  var from, to;\\n  for (var i = 0; i \\u003C this.lines.length; ++i) {\\n    var line = this$1.lines[i];\\n    var span = getMarkedSpanFor(line.markedSpans, this$1);\\n    if (span.from != null) {\\n      from = Pos(lineObj ? line : lineNo(line), span.from);\\n      if (side == -1) { return from }\\n    }\\n    if (span.to != null) {\\n      to = Pos(lineObj ? line : lineNo(line), span.to);\\n      if (side == 1) { return to }\\n    }\\n  }\\n  return from && {from: from, to: to}\\n};\\n\\n\\u002F\\u002F Signals that the marker's widget changed, and surrounding layout\\n\\u002F\\u002F should be recomputed.\\nTextMarker.prototype.changed = function () {\\n    var this$1 = this;\\n\\n  var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\\n  if (!pos || !cm) { return }\\n  runInOp(cm, function () {\\n    var line = pos.line, lineN = lineNo(pos.line);\\n    var view = findViewForLine(cm, lineN);\\n    if (view) {\\n      clearLineMeasurementCacheFor(view);\\n      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\\n    }\\n    cm.curOp.updateMaxLine = true;\\n    if (!lineIsHidden(widget.doc, line) && widget.height != null) {\\n      var oldHeight = widget.height;\\n      widget.height = null;\\n      var dHeight = widgetHeight(widget) - oldHeight;\\n      if (dHeight)\\n        { updateLineHeight(line, line.height + dHeight); }\\n    }\\n    signalLater(cm, \\\"markerChanged\\\", cm, this$1);\\n  });\\n};\\n\\nTextMarker.prototype.attachLine = function (line) {\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp;\\n    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\\n      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\\n  }\\n  this.lines.push(line);\\n};\\n\\nTextMarker.prototype.detachLine = function (line) {\\n  this.lines.splice(indexOf(this.lines, line), 1);\\n  if (!this.lines.length && this.doc.cm) {\\n    var op = this.doc.cm.curOp;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\\n  }\\n};\\neventMixin(TextMarker);\\n\\n\\u002F\\u002F Create a marker, wire it up to the right lines, and\\nfunction markText(doc, from, to, options, type) {\\n  \\u002F\\u002F Shared markers (across linked documents) are handled separately\\n  \\u002F\\u002F (markTextShared will call out to this again, once per\\n  \\u002F\\u002F document).\\n  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\\n  \\u002F\\u002F Ensure we are in an operation.\\n  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\\n\\n  var marker = new TextMarker(doc, type), diff = cmp(from, to);\\n  if (options) { copyObj(options, marker, false); }\\n  \\u002F\\u002F Don't connect empty markers unless clearWhenEmpty is false\\n  if (diff \\u003E 0 || diff == 0 && marker.clearWhenEmpty !== false)\\n    { return marker }\\n  if (marker.replacedWith) {\\n    \\u002F\\u002F Showing up as a widget implies collapsed (widget replaces text)\\n    marker.collapsed = true;\\n    marker.widgetNode = eltP(\\\"span\\\", [marker.replacedWith], \\\"CodeMirror-widget\\\");\\n    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\"); }\\n    if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\\n  }\\n  if (marker.collapsed) {\\n    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\\n        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\\n      { throw new Error(\\\"Inserting collapsed marker partially overlapping an existing one\\\") }\\n    seeCollapsedSpans();\\n  }\\n\\n  if (marker.addToHistory)\\n    { addChangeToHistory(doc, {from: from, to: to, origin: \\\"markText\\\"}, doc.sel, NaN); }\\n\\n  var curLine = from.line, cm = doc.cm, updateMaxLine;\\n  doc.iter(curLine, to.line + 1, function (line) {\\n    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\\n      { updateMaxLine = true; }\\n    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\\n    addMarkedSpan(line, new MarkedSpan(marker,\\n                                       curLine == from.line ? from.ch : null,\\n                                       curLine == to.line ? to.ch : null));\\n    ++curLine;\\n  });\\n  \\u002F\\u002F lineIsHidden depends on the presence of the spans, so needs a second pass\\n  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\\n    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\\n  }); }\\n\\n  if (marker.clearOnEnter) { on(marker, \\\"beforeCursorEnter\\\", function () { return marker.clear(); }); }\\n\\n  if (marker.readOnly) {\\n    seeReadOnlySpans();\\n    if (doc.history.done.length || doc.history.undone.length)\\n      { doc.clearHistory(); }\\n  }\\n  if (marker.collapsed) {\\n    marker.id = ++nextMarkerId;\\n    marker.atomic = true;\\n  }\\n  if (cm) {\\n    \\u002F\\u002F Sync editor state\\n    if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\\n    if (marker.collapsed)\\n      { regChange(cm, from.line, to.line + 1); }\\n    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\\n      { for (var i = from.line; i \\u003C= to.line; i++) { regLineChange(cm, i, \\\"text\\\"); } }\\n    if (marker.atomic) { reCheckSelection(cm.doc); }\\n    signalLater(cm, \\\"markerAdded\\\", cm, marker);\\n  }\\n  return marker\\n}\\n\\n\\u002F\\u002F SHARED TEXTMARKERS\\n\\n\\u002F\\u002F A shared marker spans multiple linked documents. It is\\n\\u002F\\u002F implemented as a meta-marker-object controlling multiple normal\\n\\u002F\\u002F markers.\\nvar SharedTextMarker = function(markers, primary) {\\n  var this$1 = this;\\n\\n  this.markers = markers;\\n  this.primary = primary;\\n  for (var i = 0; i \\u003C markers.length; ++i)\\n    { markers[i].parent = this$1; }\\n};\\n\\nSharedTextMarker.prototype.clear = function () {\\n    var this$1 = this;\\n\\n  if (this.explicitlyCleared) { return }\\n  this.explicitlyCleared = true;\\n  for (var i = 0; i \\u003C this.markers.length; ++i)\\n    { this$1.markers[i].clear(); }\\n  signalLater(this, \\\"clear\\\");\\n};\\n\\nSharedTextMarker.prototype.find = function (side, lineObj) {\\n  return this.primary.find(side, lineObj)\\n};\\neventMixin(SharedTextMarker);\\n\\nfunction markTextShared(doc, from, to, options, type) {\\n  options = copyObj(options);\\n  options.shared = false;\\n  var markers = [markText(doc, from, to, options, type)], primary = markers[0];\\n  var widget = options.widgetNode;\\n  linkedDocs(doc, function (doc) {\\n    if (widget) { options.widgetNode = widget.cloneNode(true); }\\n    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\\n    for (var i = 0; i \\u003C doc.linked.length; ++i)\\n      { if (doc.linked[i].isParent) { return } }\\n    primary = lst(markers);\\n  });\\n  return new SharedTextMarker(markers, primary)\\n}\\n\\nfunction findSharedMarkers(doc) {\\n  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\\n}\\n\\nfunction copySharedMarkers(doc, markers) {\\n  for (var i = 0; i \\u003C markers.length; i++) {\\n    var marker = markers[i], pos = marker.find();\\n    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\\n    if (cmp(mFrom, mTo)) {\\n      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\\n      marker.markers.push(subMark);\\n      subMark.parent = marker;\\n    }\\n  }\\n}\\n\\nfunction detachSharedMarkers(markers) {\\n  var loop = function ( i ) {\\n    var marker = markers[i], linked = [marker.primary.doc];\\n    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\\n    for (var j = 0; j \\u003C marker.markers.length; j++) {\\n      var subMarker = marker.markers[j];\\n      if (indexOf(linked, subMarker.doc) == -1) {\\n        subMarker.parent = null;\\n        marker.markers.splice(j--, 1);\\n      }\\n    }\\n  };\\n\\n  for (var i = 0; i \\u003C markers.length; i++) loop( i );\\n}\\n\\nvar nextDocId = 0;\\nvar Doc = function(text, mode, firstLine, lineSep, direction) {\\n  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\\n  if (firstLine == null) { firstLine = 0; }\\n\\n  BranchChunk.call(this, [new LeafChunk([new Line(\\\"\\\", null)])]);\\n  this.first = firstLine;\\n  this.scrollTop = this.scrollLeft = 0;\\n  this.cantEdit = false;\\n  this.cleanGeneration = 1;\\n  this.modeFrontier = this.highlightFrontier = firstLine;\\n  var start = Pos(firstLine, 0);\\n  this.sel = simpleSelection(start);\\n  this.history = new History(null);\\n  this.id = ++nextDocId;\\n  this.modeOption = mode;\\n  this.lineSep = lineSep;\\n  this.direction = (direction == \\\"rtl\\\") ? \\\"rtl\\\" : \\\"ltr\\\";\\n  this.extend = false;\\n\\n  if (typeof text == \\\"string\\\") { text = this.splitLines(text); }\\n  updateDoc(this, {from: start, to: start, text: text});\\n  setSelection(this, simpleSelection(start), sel_dontScroll);\\n};\\n\\nDoc.prototype = createObj(BranchChunk.prototype, {\\n  constructor: Doc,\\n  \\u002F\\u002F Iterate over the document. Supports two forms -- with only one\\n  \\u002F\\u002F argument, it calls that for each line in the document. With\\n  \\u002F\\u002F three, it iterates over the range given by the first two (with\\n  \\u002F\\u002F the second being non-inclusive).\\n  iter: function(from, to, op) {\\n    if (op) { this.iterN(from - this.first, to - from, op); }\\n    else { this.iterN(this.first, this.first + this.size, from); }\\n  },\\n\\n  \\u002F\\u002F Non-public interface for adding and removing lines.\\n  insert: function(at, lines) {\\n    var height = 0;\\n    for (var i = 0; i \\u003C lines.length; ++i) { height += lines[i].height; }\\n    this.insertInner(at - this.first, lines, height);\\n  },\\n  remove: function(at, n) { this.removeInner(at - this.first, n); },\\n\\n  \\u002F\\u002F From here, the methods are part of the public interface. Most\\n  \\u002F\\u002F are also available from CodeMirror (editor) instances.\\n\\n  getValue: function(lineSep) {\\n    var lines = getLines(this, this.first, this.first + this.size);\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n  setValue: docMethodOp(function(code) {\\n    var top = Pos(this.first, 0), last = this.first + this.size - 1;\\n    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\\n                      text: this.splitLines(code), origin: \\\"setValue\\\", full: true}, true);\\n    if (this.cm) { scrollToCoords(this.cm, 0, 0); }\\n    setSelection(this, simpleSelection(top), sel_dontScroll);\\n  }),\\n  replaceRange: function(code, from, to, origin) {\\n    from = clipPos(this, from);\\n    to = to ? clipPos(this, to) : from;\\n    replaceRange(this, code, from, to, origin);\\n  },\\n  getRange: function(from, to, lineSep) {\\n    var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\\n    if (lineSep === false) { return lines }\\n    return lines.join(lineSep || this.lineSeparator())\\n  },\\n\\n  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\\n\\n  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\\n  getLineNumber: function(line) {return lineNo(line)},\\n\\n  getLineHandleVisualStart: function(line) {\\n    if (typeof line == \\\"number\\\") { line = getLine(this, line); }\\n    return visualLine(line)\\n  },\\n\\n  lineCount: function() {return this.size},\\n  firstLine: function() {return this.first},\\n  lastLine: function() {return this.first + this.size - 1},\\n\\n  clipPos: function(pos) {return clipPos(this, pos)},\\n\\n  getCursor: function(start) {\\n    var range$$1 = this.sel.primary(), pos;\\n    if (start == null || start == \\\"head\\\") { pos = range$$1.head; }\\n    else if (start == \\\"anchor\\\") { pos = range$$1.anchor; }\\n    else if (start == \\\"end\\\" || start == \\\"to\\\" || start === false) { pos = range$$1.to(); }\\n    else { pos = range$$1.from(); }\\n    return pos\\n  },\\n  listSelections: function() { return this.sel.ranges },\\n  somethingSelected: function() {return this.sel.somethingSelected()},\\n\\n  setCursor: docMethodOp(function(line, ch, options) {\\n    setSimpleSelection(this, clipPos(this, typeof line == \\\"number\\\" ? Pos(line, ch || 0) : line), null, options);\\n  }),\\n  setSelection: docMethodOp(function(anchor, head, options) {\\n    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\\n  }),\\n  extendSelection: docMethodOp(function(head, other, options) {\\n    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\\n  }),\\n  extendSelections: docMethodOp(function(heads, options) {\\n    extendSelections(this, clipPosArray(this, heads), options);\\n  }),\\n  extendSelectionsBy: docMethodOp(function(f, options) {\\n    var heads = map(this.sel.ranges, f);\\n    extendSelections(this, clipPosArray(this, heads), options);\\n  }),\\n  setSelections: docMethodOp(function(ranges, primary, options) {\\n    var this$1 = this;\\n\\n    if (!ranges.length) { return }\\n    var out = [];\\n    for (var i = 0; i \\u003C ranges.length; i++)\\n      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\\n                         clipPos(this$1, ranges[i].head)); }\\n    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\\n    setSelection(this, normalizeSelection(out, primary), options);\\n  }),\\n  addSelection: docMethodOp(function(anchor, head, options) {\\n    var ranges = this.sel.ranges.slice(0);\\n    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\\n    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\\n  }),\\n\\n  getSelection: function(lineSep) {\\n    var this$1 = this;\\n\\n    var ranges = this.sel.ranges, lines;\\n    for (var i = 0; i \\u003C ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\\n      lines = lines ? lines.concat(sel) : sel;\\n    }\\n    if (lineSep === false) { return lines }\\n    else { return lines.join(lineSep || this.lineSeparator()) }\\n  },\\n  getSelections: function(lineSep) {\\n    var this$1 = this;\\n\\n    var parts = [], ranges = this.sel.ranges;\\n    for (var i = 0; i \\u003C ranges.length; i++) {\\n      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\\n      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\\n      parts[i] = sel;\\n    }\\n    return parts\\n  },\\n  replaceSelection: function(code, collapse, origin) {\\n    var dup = [];\\n    for (var i = 0; i \\u003C this.sel.ranges.length; i++)\\n      { dup[i] = code; }\\n    this.replaceSelections(dup, collapse, origin || \\\"+input\\\");\\n  },\\n  replaceSelections: docMethodOp(function(code, collapse, origin) {\\n    var this$1 = this;\\n\\n    var changes = [], sel = this.sel;\\n    for (var i = 0; i \\u003C sel.ranges.length; i++) {\\n      var range$$1 = sel.ranges[i];\\n      changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\\n    }\\n    var newSel = collapse && collapse != \\\"end\\\" && computeReplacedSel(this, changes, collapse);\\n    for (var i$1 = changes.length - 1; i$1 \\u003E= 0; i$1--)\\n      { makeChange(this$1, changes[i$1]); }\\n    if (newSel) { setSelectionReplaceHistory(this, newSel); }\\n    else if (this.cm) { ensureCursorVisible(this.cm); }\\n  }),\\n  undo: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\");}),\\n  redo: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\");}),\\n  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"undo\\\", true);}),\\n  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \\\"redo\\\", true);}),\\n\\n  setExtending: function(val) {this.extend = val;},\\n  getExtending: function() {return this.extend},\\n\\n  historySize: function() {\\n    var hist = this.history, done = 0, undone = 0;\\n    for (var i = 0; i \\u003C hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\\n    for (var i$1 = 0; i$1 \\u003C hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\\n    return {undo: done, redo: undone}\\n  },\\n  clearHistory: function() {this.history = new History(this.history.maxGeneration);},\\n\\n  markClean: function() {\\n    this.cleanGeneration = this.changeGeneration(true);\\n  },\\n  changeGeneration: function(forceSplit) {\\n    if (forceSplit)\\n      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\\n    return this.history.generation\\n  },\\n  isClean: function (gen) {\\n    return this.history.generation == (gen || this.cleanGeneration)\\n  },\\n\\n  getHistory: function() {\\n    return {done: copyHistoryArray(this.history.done),\\n            undone: copyHistoryArray(this.history.undone)}\\n  },\\n  setHistory: function(histData) {\\n    var hist = this.history = new History(this.history.maxGeneration);\\n    hist.done = copyHistoryArray(histData.done.slice(0), null, true);\\n    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\\n  },\\n\\n  setGutterMarker: docMethodOp(function(line, gutterID, value) {\\n    return changeLine(this, line, \\\"gutter\\\", function (line) {\\n      var markers = line.gutterMarkers || (line.gutterMarkers = {});\\n      markers[gutterID] = value;\\n      if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\\n      return true\\n    })\\n  }),\\n\\n  clearGutter: docMethodOp(function(gutterID) {\\n    var this$1 = this;\\n\\n    this.iter(function (line) {\\n      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\\n        changeLine(this$1, line, \\\"gutter\\\", function () {\\n          line.gutterMarkers[gutterID] = null;\\n          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\\n          return true\\n        });\\n      }\\n    });\\n  }),\\n\\n  lineInfo: function(line) {\\n    var n;\\n    if (typeof line == \\\"number\\\") {\\n      if (!isLine(this, line)) { return null }\\n      n = line;\\n      line = getLine(this, line);\\n      if (!line) { return null }\\n    } else {\\n      n = lineNo(line);\\n      if (n == null) { return null }\\n    }\\n    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\\n            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\\n            widgets: line.widgets}\\n  },\\n\\n  addLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\";\\n      if (!line[prop]) { line[prop] = cls; }\\n      else if (classTest(cls).test(line[prop])) { return false }\\n      else { line[prop] += \\\" \\\" + cls; }\\n      return true\\n    })\\n  }),\\n  removeLineClass: docMethodOp(function(handle, where, cls) {\\n    return changeLine(this, handle, where == \\\"gutter\\\" ? \\\"gutter\\\" : \\\"class\\\", function (line) {\\n      var prop = where == \\\"text\\\" ? \\\"textClass\\\"\\n               : where == \\\"background\\\" ? \\\"bgClass\\\"\\n               : where == \\\"gutter\\\" ? \\\"gutterClass\\\" : \\\"wrapClass\\\";\\n      var cur = line[prop];\\n      if (!cur) { return false }\\n      else if (cls == null) { line[prop] = null; }\\n      else {\\n        var found = cur.match(classTest(cls));\\n        if (!found) { return false }\\n        var end = found.index + found[0].length;\\n        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \\\"\\\" : \\\" \\\") + cur.slice(end) || null;\\n      }\\n      return true\\n    })\\n  }),\\n\\n  addLineWidget: docMethodOp(function(handle, node, options) {\\n    return addLineWidget(this, handle, node, options)\\n  }),\\n  removeLineWidget: function(widget) { widget.clear(); },\\n\\n  markText: function(from, to, options) {\\n    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \\\"range\\\")\\n  },\\n  setBookmark: function(pos, options) {\\n    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\\n                    insertLeft: options && options.insertLeft,\\n                    clearWhenEmpty: false, shared: options && options.shared,\\n                    handleMouseEvents: options && options.handleMouseEvents};\\n    pos = clipPos(this, pos);\\n    return markText(this, pos, pos, realOpts, \\\"bookmark\\\")\\n  },\\n  findMarksAt: function(pos) {\\n    pos = clipPos(this, pos);\\n    var markers = [], spans = getLine(this, pos.line).markedSpans;\\n    if (spans) { for (var i = 0; i \\u003C spans.length; ++i) {\\n      var span = spans[i];\\n      if ((span.from == null || span.from \\u003C= pos.ch) &&\\n          (span.to == null || span.to \\u003E= pos.ch))\\n        { markers.push(span.marker.parent || span.marker); }\\n    } }\\n    return markers\\n  },\\n  findMarks: function(from, to, filter) {\\n    from = clipPos(this, from); to = clipPos(this, to);\\n    var found = [], lineNo$$1 = from.line;\\n    this.iter(from.line, to.line + 1, function (line) {\\n      var spans = line.markedSpans;\\n      if (spans) { for (var i = 0; i \\u003C spans.length; i++) {\\n        var span = spans[i];\\n        if (!(span.to != null && lineNo$$1 == from.line && from.ch \\u003E= span.to ||\\n              span.from == null && lineNo$$1 != from.line ||\\n              span.from != null && lineNo$$1 == to.line && span.from \\u003E= to.ch) &&\\n            (!filter || filter(span.marker)))\\n          { found.push(span.marker.parent || span.marker); }\\n      } }\\n      ++lineNo$$1;\\n    });\\n    return found\\n  },\\n  getAllMarks: function() {\\n    var markers = [];\\n    this.iter(function (line) {\\n      var sps = line.markedSpans;\\n      if (sps) { for (var i = 0; i \\u003C sps.length; ++i)\\n        { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\\n    });\\n    return markers\\n  },\\n\\n  posFromIndex: function(off) {\\n    var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\\n    this.iter(function (line) {\\n      var sz = line.text.length + sepSize;\\n      if (sz \\u003E off) { ch = off; return true }\\n      off -= sz;\\n      ++lineNo$$1;\\n    });\\n    return clipPos(this, Pos(lineNo$$1, ch))\\n  },\\n  indexFromPos: function (coords) {\\n    coords = clipPos(this, coords);\\n    var index = coords.ch;\\n    if (coords.line \\u003C this.first || coords.ch \\u003C 0) { return 0 }\\n    var sepSize = this.lineSeparator().length;\\n    this.iter(this.first, coords.line, function (line) { \\u002F\\u002F iter aborts when callback returns a truthy value\\n      index += line.text.length + sepSize;\\n    });\\n    return index\\n  },\\n\\n  copy: function(copyHistory) {\\n    var doc = new Doc(getLines(this, this.first, this.first + this.size),\\n                      this.modeOption, this.first, this.lineSep, this.direction);\\n    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\\n    doc.sel = this.sel;\\n    doc.extend = false;\\n    if (copyHistory) {\\n      doc.history.undoDepth = this.history.undoDepth;\\n      doc.setHistory(this.getHistory());\\n    }\\n    return doc\\n  },\\n\\n  linkedDoc: function(options) {\\n    if (!options) { options = {}; }\\n    var from = this.first, to = this.first + this.size;\\n    if (options.from != null && options.from \\u003E from) { from = options.from; }\\n    if (options.to != null && options.to \\u003C to) { to = options.to; }\\n    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\\n    if (options.sharedHist) { copy.history = this.history\\n    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\\n    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\\n    copySharedMarkers(copy, findSharedMarkers(this));\\n    return copy\\n  },\\n  unlinkDoc: function(other) {\\n    var this$1 = this;\\n\\n    if (other instanceof CodeMirror$1) { other = other.doc; }\\n    if (this.linked) { for (var i = 0; i \\u003C this.linked.length; ++i) {\\n      var link = this$1.linked[i];\\n      if (link.doc != other) { continue }\\n      this$1.linked.splice(i, 1);\\n      other.unlinkDoc(this$1);\\n      detachSharedMarkers(findSharedMarkers(this$1));\\n      break\\n    } }\\n    \\u002F\\u002F If the histories were shared, split them again\\n    if (other.history == this.history) {\\n      var splitIds = [other.id];\\n      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\\n      other.history = new History(null);\\n      other.history.done = copyHistoryArray(this.history.done, splitIds);\\n      other.history.undone = copyHistoryArray(this.history.undone, splitIds);\\n    }\\n  },\\n  iterLinkedDocs: function(f) {linkedDocs(this, f);},\\n\\n  getMode: function() {return this.mode},\\n  getEditor: function() {return this.cm},\\n\\n  splitLines: function(str) {\\n    if (this.lineSep) { return str.split(this.lineSep) }\\n    return splitLinesAuto(str)\\n  },\\n  lineSeparator: function() { return this.lineSep || \\\"\\\\n\\\" },\\n\\n  setDirection: docMethodOp(function (dir) {\\n    if (dir != \\\"rtl\\\") { dir = \\\"ltr\\\"; }\\n    if (dir == this.direction) { return }\\n    this.direction = dir;\\n    this.iter(function (line) { return line.order = null; });\\n    if (this.cm) { directionChanged(this.cm); }\\n  })\\n});\\n\\n\\u002F\\u002F Public alias.\\nDoc.prototype.eachLine = Doc.prototype.iter;\\n\\n\\u002F\\u002F Kludge to work around strange IE behavior where it'll sometimes\\n\\u002F\\u002F re-fire a series of drag-related events right after the drop (#1551)\\nvar lastDrop = 0;\\n\\nfunction onDrop(e) {\\n  var cm = this;\\n  clearDragCursor(cm);\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\\n    { return }\\n  e_preventDefault(e);\\n  if (ie) { lastDrop = +new Date; }\\n  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\\n  if (!pos || cm.isReadOnly()) { return }\\n  \\u002F\\u002F Might be a file drop, in which case we simply extract the text\\n  \\u002F\\u002F and insert it.\\n  if (files && files.length && window.FileReader && window.File) {\\n    var n = files.length, text = Array(n), read = 0;\\n    var loadFile = function (file, i) {\\n      if (cm.options.allowDropFileTypes &&\\n          indexOf(cm.options.allowDropFileTypes, file.type) == -1)\\n        { return }\\n\\n      var reader = new FileReader;\\n      reader.onload = operation(cm, function () {\\n        var content = reader.result;\\n        if (\\u002F[\\\\x00-\\\\x08\\\\x0e-\\\\x1f]{2}\\u002F.test(content)) { content = \\\"\\\"; }\\n        text[i] = content;\\n        if (++read == n) {\\n          pos = clipPos(cm.doc, pos);\\n          var change = {from: pos, to: pos,\\n                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\\n                        origin: \\\"paste\\\"};\\n          makeChange(cm.doc, change);\\n          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\\n        }\\n      });\\n      reader.readAsText(file);\\n    };\\n    for (var i = 0; i \\u003C n; ++i) { loadFile(files[i], i); }\\n  } else { \\u002F\\u002F Normal drop\\n    \\u002F\\u002F Don't do a replace if the drop happened inside of the selected text.\\n    if (cm.state.draggingText && cm.doc.sel.contains(pos) \\u003E -1) {\\n      cm.state.draggingText(e);\\n      \\u002F\\u002F Ensure the editor is re-focused\\n      setTimeout(function () { return cm.display.input.focus(); }, 20);\\n      return\\n    }\\n    try {\\n      var text$1 = e.dataTransfer.getData(\\\"Text\\\");\\n      if (text$1) {\\n        var selected;\\n        if (cm.state.draggingText && !cm.state.draggingText.copy)\\n          { selected = cm.listSelections(); }\\n        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\\n        if (selected) { for (var i$1 = 0; i$1 \\u003C selected.length; ++i$1)\\n          { replaceRange(cm.doc, \\\"\\\", selected[i$1].anchor, selected[i$1].head, \\\"drag\\\"); } }\\n        cm.replaceSelection(text$1, \\\"around\\\", \\\"paste\\\");\\n        cm.display.input.focus();\\n      }\\n    }\\n    catch(e){}\\n  }\\n}\\n\\nfunction onDragStart(cm, e) {\\n  if (ie && (!cm.state.draggingText || +new Date - lastDrop \\u003C 100)) { e_stop(e); return }\\n  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\\n\\n  e.dataTransfer.setData(\\\"Text\\\", cm.getSelection());\\n  e.dataTransfer.effectAllowed = \\\"copyMove\\\";\\n\\n  \\u002F\\u002F Use dummy image instead of default browsers image.\\n  \\u002F\\u002F Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\\n  if (e.dataTransfer.setDragImage && !safari) {\\n    var img = elt(\\\"img\\\", null, null, \\\"position: fixed; left: 0; top: 0;\\\");\\n    img.src = \\\"data:image\\u002Fgif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\\\";\\n    if (presto) {\\n      img.width = img.height = 1;\\n      cm.display.wrapper.appendChild(img);\\n      \\u002F\\u002F Force a relayout, or Opera won't use our image for some obscure reason\\n      img._top = img.offsetTop;\\n    }\\n    e.dataTransfer.setDragImage(img, 0, 0);\\n    if (presto) { img.parentNode.removeChild(img); }\\n  }\\n}\\n\\nfunction onDragOver(cm, e) {\\n  var pos = posFromMouse(cm, e);\\n  if (!pos) { return }\\n  var frag = document.createDocumentFragment();\\n  drawSelectionCursor(cm, pos, frag);\\n  if (!cm.display.dragCursor) {\\n    cm.display.dragCursor = elt(\\\"div\\\", null, \\\"CodeMirror-cursors CodeMirror-dragcursors\\\");\\n    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\\n  }\\n  removeChildrenAndAdd(cm.display.dragCursor, frag);\\n}\\n\\nfunction clearDragCursor(cm) {\\n  if (cm.display.dragCursor) {\\n    cm.display.lineSpace.removeChild(cm.display.dragCursor);\\n    cm.display.dragCursor = null;\\n  }\\n}\\n\\n\\u002F\\u002F These must be handled carefully, because naively registering a\\n\\u002F\\u002F handler for each editor will cause the editors to never be\\n\\u002F\\u002F garbage collected.\\n\\nfunction forEachCodeMirror(f) {\\n  if (!document.getElementsByClassName) { return }\\n  var byClass = document.getElementsByClassName(\\\"CodeMirror\\\");\\n  for (var i = 0; i \\u003C byClass.length; i++) {\\n    var cm = byClass[i].CodeMirror;\\n    if (cm) { f(cm); }\\n  }\\n}\\n\\nvar globalsRegistered = false;\\nfunction ensureGlobalHandlers() {\\n  if (globalsRegistered) { return }\\n  registerGlobalHandlers();\\n  globalsRegistered = true;\\n}\\nfunction registerGlobalHandlers() {\\n  \\u002F\\u002F When the window resizes, we need to refresh active editors.\\n  var resizeTimer;\\n  on(window, \\\"resize\\\", function () {\\n    if (resizeTimer == null) { resizeTimer = setTimeout(function () {\\n      resizeTimer = null;\\n      forEachCodeMirror(onResize);\\n    }, 100); }\\n  });\\n  \\u002F\\u002F When the window loses focus, we want to show the editor as blurred\\n  on(window, \\\"blur\\\", function () { return forEachCodeMirror(onBlur); });\\n}\\n\\u002F\\u002F Called when the window resizes\\nfunction onResize(cm) {\\n  var d = cm.display;\\n  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\\n    { return }\\n  \\u002F\\u002F Might be a text scaling operation, clear size caches.\\n  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\\n  d.scrollbarsClipped = false;\\n  cm.setSize();\\n}\\n\\nvar keyNames = {\\n  3: \\\"Pause\\\", 8: \\\"Backspace\\\", 9: \\\"Tab\\\", 13: \\\"Enter\\\", 16: \\\"Shift\\\", 17: \\\"Ctrl\\\", 18: \\\"Alt\\\",\\n  19: \\\"Pause\\\", 20: \\\"CapsLock\\\", 27: \\\"Esc\\\", 32: \\\"Space\\\", 33: \\\"PageUp\\\", 34: \\\"PageDown\\\", 35: \\\"End\\\",\\n  36: \\\"Home\\\", 37: \\\"Left\\\", 38: \\\"Up\\\", 39: \\\"Right\\\", 40: \\\"Down\\\", 44: \\\"PrintScrn\\\", 45: \\\"Insert\\\",\\n  46: \\\"Delete\\\", 59: \\\";\\\", 61: \\\"=\\\", 91: \\\"Mod\\\", 92: \\\"Mod\\\", 93: \\\"Mod\\\",\\n  106: \\\"*\\\", 107: \\\"=\\\", 109: \\\"-\\\", 110: \\\".\\\", 111: \\\"\\u002F\\\", 127: \\\"Delete\\\", 145: \\\"ScrollLock\\\",\\n  173: \\\"-\\\", 186: \\\";\\\", 187: \\\"=\\\", 188: \\\",\\\", 189: \\\"-\\\", 190: \\\".\\\", 191: \\\"\\u002F\\\", 192: \\\"`\\\", 219: \\\"[\\\", 220: \\\"\\\\\\\\\\\",\\n  221: \\\"]\\\", 222: \\\"'\\\", 63232: \\\"Up\\\", 63233: \\\"Down\\\", 63234: \\\"Left\\\", 63235: \\\"Right\\\", 63272: \\\"Delete\\\",\\n  63273: \\\"Home\\\", 63275: \\\"End\\\", 63276: \\\"PageUp\\\", 63277: \\\"PageDown\\\", 63302: \\\"Insert\\\"\\n};\\n\\n\\u002F\\u002F Number keys\\nfor (var i = 0; i \\u003C 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\\n\\u002F\\u002F Alphabetic keys\\nfor (var i$1 = 65; i$1 \\u003C= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\\n\\u002F\\u002F Function keys\\nfor (var i$2 = 1; i$2 \\u003C= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \\\"F\\\" + i$2; }\\n\\nvar keyMap = {};\\n\\nkeyMap.basic = {\\n  \\\"Left\\\": \\\"goCharLeft\\\", \\\"Right\\\": \\\"goCharRight\\\", \\\"Up\\\": \\\"goLineUp\\\", \\\"Down\\\": \\\"goLineDown\\\",\\n  \\\"End\\\": \\\"goLineEnd\\\", \\\"Home\\\": \\\"goLineStartSmart\\\", \\\"PageUp\\\": \\\"goPageUp\\\", \\\"PageDown\\\": \\\"goPageDown\\\",\\n  \\\"Delete\\\": \\\"delCharAfter\\\", \\\"Backspace\\\": \\\"delCharBefore\\\", \\\"Shift-Backspace\\\": \\\"delCharBefore\\\",\\n  \\\"Tab\\\": \\\"defaultTab\\\", \\\"Shift-Tab\\\": \\\"indentAuto\\\",\\n  \\\"Enter\\\": \\\"newlineAndIndent\\\", \\\"Insert\\\": \\\"toggleOverwrite\\\",\\n  \\\"Esc\\\": \\\"singleSelection\\\"\\n};\\n\\u002F\\u002F Note that the save and find-related commands aren't defined by\\n\\u002F\\u002F default. User code or addons can define them. Unknown commands\\n\\u002F\\u002F are simply ignored.\\nkeyMap.pcDefault = {\\n  \\\"Ctrl-A\\\": \\\"selectAll\\\", \\\"Ctrl-D\\\": \\\"deleteLine\\\", \\\"Ctrl-Z\\\": \\\"undo\\\", \\\"Shift-Ctrl-Z\\\": \\\"redo\\\", \\\"Ctrl-Y\\\": \\\"redo\\\",\\n  \\\"Ctrl-Home\\\": \\\"goDocStart\\\", \\\"Ctrl-End\\\": \\\"goDocEnd\\\", \\\"Ctrl-Up\\\": \\\"goLineUp\\\", \\\"Ctrl-Down\\\": \\\"goLineDown\\\",\\n  \\\"Ctrl-Left\\\": \\\"goGroupLeft\\\", \\\"Ctrl-Right\\\": \\\"goGroupRight\\\", \\\"Alt-Left\\\": \\\"goLineStart\\\", \\\"Alt-Right\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-Backspace\\\": \\\"delGroupBefore\\\", \\\"Ctrl-Delete\\\": \\\"delGroupAfter\\\", \\\"Ctrl-S\\\": \\\"save\\\", \\\"Ctrl-F\\\": \\\"find\\\",\\n  \\\"Ctrl-G\\\": \\\"findNext\\\", \\\"Shift-Ctrl-G\\\": \\\"findPrev\\\", \\\"Shift-Ctrl-F\\\": \\\"replace\\\", \\\"Shift-Ctrl-R\\\": \\\"replaceAll\\\",\\n  \\\"Ctrl-[\\\": \\\"indentLess\\\", \\\"Ctrl-]\\\": \\\"indentMore\\\",\\n  \\\"Ctrl-U\\\": \\\"undoSelection\\\", \\\"Shift-Ctrl-U\\\": \\\"redoSelection\\\", \\\"Alt-U\\\": \\\"redoSelection\\\",\\n  fallthrough: \\\"basic\\\"\\n};\\n\\u002F\\u002F Very basic readline\\u002Femacs-style bindings, which are standard on Mac.\\nkeyMap.emacsy = {\\n  \\\"Ctrl-F\\\": \\\"goCharRight\\\", \\\"Ctrl-B\\\": \\\"goCharLeft\\\", \\\"Ctrl-P\\\": \\\"goLineUp\\\", \\\"Ctrl-N\\\": \\\"goLineDown\\\",\\n  \\\"Alt-F\\\": \\\"goWordRight\\\", \\\"Alt-B\\\": \\\"goWordLeft\\\", \\\"Ctrl-A\\\": \\\"goLineStart\\\", \\\"Ctrl-E\\\": \\\"goLineEnd\\\",\\n  \\\"Ctrl-V\\\": \\\"goPageDown\\\", \\\"Shift-Ctrl-V\\\": \\\"goPageUp\\\", \\\"Ctrl-D\\\": \\\"delCharAfter\\\", \\\"Ctrl-H\\\": \\\"delCharBefore\\\",\\n  \\\"Alt-D\\\": \\\"delWordAfter\\\", \\\"Alt-Backspace\\\": \\\"delWordBefore\\\", \\\"Ctrl-K\\\": \\\"killLine\\\", \\\"Ctrl-T\\\": \\\"transposeChars\\\",\\n  \\\"Ctrl-O\\\": \\\"openLine\\\"\\n};\\nkeyMap.macDefault = {\\n  \\\"Cmd-A\\\": \\\"selectAll\\\", \\\"Cmd-D\\\": \\\"deleteLine\\\", \\\"Cmd-Z\\\": \\\"undo\\\", \\\"Shift-Cmd-Z\\\": \\\"redo\\\", \\\"Cmd-Y\\\": \\\"redo\\\",\\n  \\\"Cmd-Home\\\": \\\"goDocStart\\\", \\\"Cmd-Up\\\": \\\"goDocStart\\\", \\\"Cmd-End\\\": \\\"goDocEnd\\\", \\\"Cmd-Down\\\": \\\"goDocEnd\\\", \\\"Alt-Left\\\": \\\"goGroupLeft\\\",\\n  \\\"Alt-Right\\\": \\\"goGroupRight\\\", \\\"Cmd-Left\\\": \\\"goLineLeft\\\", \\\"Cmd-Right\\\": \\\"goLineRight\\\", \\\"Alt-Backspace\\\": \\\"delGroupBefore\\\",\\n  \\\"Ctrl-Alt-Backspace\\\": \\\"delGroupAfter\\\", \\\"Alt-Delete\\\": \\\"delGroupAfter\\\", \\\"Cmd-S\\\": \\\"save\\\", \\\"Cmd-F\\\": \\\"find\\\",\\n  \\\"Cmd-G\\\": \\\"findNext\\\", \\\"Shift-Cmd-G\\\": \\\"findPrev\\\", \\\"Cmd-Alt-F\\\": \\\"replace\\\", \\\"Shift-Cmd-Alt-F\\\": \\\"replaceAll\\\",\\n  \\\"Cmd-[\\\": \\\"indentLess\\\", \\\"Cmd-]\\\": \\\"indentMore\\\", \\\"Cmd-Backspace\\\": \\\"delWrappedLineLeft\\\", \\\"Cmd-Delete\\\": \\\"delWrappedLineRight\\\",\\n  \\\"Cmd-U\\\": \\\"undoSelection\\\", \\\"Shift-Cmd-U\\\": \\\"redoSelection\\\", \\\"Ctrl-Up\\\": \\\"goDocStart\\\", \\\"Ctrl-Down\\\": \\\"goDocEnd\\\",\\n  fallthrough: [\\\"basic\\\", \\\"emacsy\\\"]\\n};\\nkeyMap[\\\"default\\\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\\n\\n\\u002F\\u002F KEYMAP DISPATCH\\n\\nfunction normalizeKeyName(name) {\\n  var parts = name.split(\\u002F-(?!$)\\u002F);\\n  name = parts[parts.length - 1];\\n  var alt, ctrl, shift, cmd;\\n  for (var i = 0; i \\u003C parts.length - 1; i++) {\\n    var mod = parts[i];\\n    if (\\u002F^(cmd|meta|m)$\\u002Fi.test(mod)) { cmd = true; }\\n    else if (\\u002F^a(lt)?$\\u002Fi.test(mod)) { alt = true; }\\n    else if (\\u002F^(c|ctrl|control)$\\u002Fi.test(mod)) { ctrl = true; }\\n    else if (\\u002F^s(hift)?$\\u002Fi.test(mod)) { shift = true; }\\n    else { throw new Error(\\\"Unrecognized modifier name: \\\" + mod) }\\n  }\\n  if (alt) { name = \\\"Alt-\\\" + name; }\\n  if (ctrl) { name = \\\"Ctrl-\\\" + name; }\\n  if (cmd) { name = \\\"Cmd-\\\" + name; }\\n  if (shift) { name = \\\"Shift-\\\" + name; }\\n  return name\\n}\\n\\n\\u002F\\u002F This is a kludge to keep keymaps mostly working as raw objects\\n\\u002F\\u002F (backwards compatibility) while at the same time support features\\n\\u002F\\u002F like normalization and multi-stroke key bindings. It compiles a\\n\\u002F\\u002F new normalized keymap, and then updates the old object to reflect\\n\\u002F\\u002F this.\\nfunction normalizeKeyMap(keymap) {\\n  var copy = {};\\n  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\\n    var value = keymap[keyname];\\n    if (\\u002F^(name|fallthrough|(de|at)tach)$\\u002F.test(keyname)) { continue }\\n    if (value == \\\"...\\\") { delete keymap[keyname]; continue }\\n\\n    var keys = map(keyname.split(\\\" \\\"), normalizeKeyName);\\n    for (var i = 0; i \\u003C keys.length; i++) {\\n      var val = (void 0), name = (void 0);\\n      if (i == keys.length - 1) {\\n        name = keys.join(\\\" \\\");\\n        val = value;\\n      } else {\\n        name = keys.slice(0, i + 1).join(\\\" \\\");\\n        val = \\\"...\\\";\\n      }\\n      var prev = copy[name];\\n      if (!prev) { copy[name] = val; }\\n      else if (prev != val) { throw new Error(\\\"Inconsistent bindings for \\\" + name) }\\n    }\\n    delete keymap[keyname];\\n  } }\\n  for (var prop in copy) { keymap[prop] = copy[prop]; }\\n  return keymap\\n}\\n\\nfunction lookupKey(key, map$$1, handle, context) {\\n  map$$1 = getKeyMap(map$$1);\\n  var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\\n  if (found === false) { return \\\"nothing\\\" }\\n  if (found === \\\"...\\\") { return \\\"multi\\\" }\\n  if (found != null && handle(found)) { return \\\"handled\\\" }\\n\\n  if (map$$1.fallthrough) {\\n    if (Object.prototype.toString.call(map$$1.fallthrough) != \\\"[object Array]\\\")\\n      { return lookupKey(key, map$$1.fallthrough, handle, context) }\\n    for (var i = 0; i \\u003C map$$1.fallthrough.length; i++) {\\n      var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\\n      if (result) { return result }\\n    }\\n  }\\n}\\n\\n\\u002F\\u002F Modifier key presses don't count as 'real' key presses for the\\n\\u002F\\u002F purpose of keymap fallthrough.\\nfunction isModifierKey(value) {\\n  var name = typeof value == \\\"string\\\" ? value : keyNames[value.keyCode];\\n  return name == \\\"Ctrl\\\" || name == \\\"Alt\\\" || name == \\\"Shift\\\" || name == \\\"Mod\\\"\\n}\\n\\nfunction addModifierNames(name, event, noShift) {\\n  var base = name;\\n  if (event.altKey && base != \\\"Alt\\\") { name = \\\"Alt-\\\" + name; }\\n  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \\\"Ctrl\\\") { name = \\\"Ctrl-\\\" + name; }\\n  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \\\"Cmd\\\") { name = \\\"Cmd-\\\" + name; }\\n  if (!noShift && event.shiftKey && base != \\\"Shift\\\") { name = \\\"Shift-\\\" + name; }\\n  return name\\n}\\n\\n\\u002F\\u002F Look up the name of a key as indicated by an event object.\\nfunction keyName(event, noShift) {\\n  if (presto && event.keyCode == 34 && event[\\\"char\\\"]) { return false }\\n  var name = keyNames[event.keyCode];\\n  if (name == null || event.altGraphKey) { return false }\\n  \\u002F\\u002F Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\\n  \\u002F\\u002F so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\\n  if (event.keyCode == 3 && event.code) { name = event.code; }\\n  return addModifierNames(name, event, noShift)\\n}\\n\\nfunction getKeyMap(val) {\\n  return typeof val == \\\"string\\\" ? keyMap[val] : val\\n}\\n\\n\\u002F\\u002F Helper for deleting text near the selection(s), used to implement\\n\\u002F\\u002F backspace, delete, and similar functionality.\\nfunction deleteNearSelection(cm, compute) {\\n  var ranges = cm.doc.sel.ranges, kill = [];\\n  \\u002F\\u002F Build up a set of ranges to kill first, merging overlapping\\n  \\u002F\\u002F ranges.\\n  for (var i = 0; i \\u003C ranges.length; i++) {\\n    var toKill = compute(ranges[i]);\\n    while (kill.length && cmp(toKill.from, lst(kill).to) \\u003C= 0) {\\n      var replaced = kill.pop();\\n      if (cmp(replaced.from, toKill.from) \\u003C 0) {\\n        toKill.from = replaced.from;\\n        break\\n      }\\n    }\\n    kill.push(toKill);\\n  }\\n  \\u002F\\u002F Next, remove those actual ranges.\\n  runInOp(cm, function () {\\n    for (var i = kill.length - 1; i \\u003E= 0; i--)\\n      { replaceRange(cm.doc, \\\"\\\", kill[i].from, kill[i].to, \\\"+delete\\\"); }\\n    ensureCursorVisible(cm);\\n  });\\n}\\n\\nfunction moveCharLogically(line, ch, dir) {\\n  var target = skipExtendingChars(line.text, ch + dir, dir);\\n  return target \\u003C 0 || target \\u003E line.text.length ? null : target\\n}\\n\\nfunction moveLogically(line, start, dir) {\\n  var ch = moveCharLogically(line, start.ch, dir);\\n  return ch == null ? null : new Pos(start.line, ch, dir \\u003C 0 ? \\\"after\\\" : \\\"before\\\")\\n}\\n\\nfunction endOfLine(visually, cm, lineObj, lineNo, dir) {\\n  if (visually) {\\n    var order = getOrder(lineObj, cm.doc.direction);\\n    if (order) {\\n      var part = dir \\u003C 0 ? lst(order) : order[0];\\n      var moveInStorageOrder = (dir \\u003C 0) == (part.level == 1);\\n      var sticky = moveInStorageOrder ? \\\"after\\\" : \\\"before\\\";\\n      var ch;\\n      \\u002F\\u002F With a wrapped rtl chunk (possibly spanning multiple bidi parts),\\n      \\u002F\\u002F it could be that the last bidi part is not on the last visual line,\\n      \\u002F\\u002F since visual lines contain content order-consecutive chunks.\\n      \\u002F\\u002F Thus, in rtl, we are looking for the first (content-order) character\\n      \\u002F\\u002F in the rtl chunk that is on the last line (that is, the same line\\n      \\u002F\\u002F as the last (content-order) character).\\n      if (part.level \\u003E 0 || cm.doc.direction == \\\"rtl\\\") {\\n        var prep = prepareMeasureForLine(cm, lineObj);\\n        ch = dir \\u003C 0 ? lineObj.text.length - 1 : 0;\\n        var targetTop = measureCharPrepared(cm, prep, ch).top;\\n        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir \\u003C 0) == (part.level == 1) ? part.from : part.to - 1, ch);\\n        if (sticky == \\\"before\\\") { ch = moveCharLogically(lineObj, ch, 1); }\\n      } else { ch = dir \\u003C 0 ? part.to : part.from; }\\n      return new Pos(lineNo, ch, sticky)\\n    }\\n  }\\n  return new Pos(lineNo, dir \\u003C 0 ? lineObj.text.length : 0, dir \\u003C 0 ? \\\"before\\\" : \\\"after\\\")\\n}\\n\\nfunction moveVisually(cm, line, start, dir) {\\n  var bidi = getOrder(line, cm.doc.direction);\\n  if (!bidi) { return moveLogically(line, start, dir) }\\n  if (start.ch \\u003E= line.text.length) {\\n    start.ch = line.text.length;\\n    start.sticky = \\\"before\\\";\\n  } else if (start.ch \\u003C= 0) {\\n    start.ch = 0;\\n    start.sticky = \\\"after\\\";\\n  }\\n  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\\n  if (cm.doc.direction == \\\"ltr\\\" && part.level % 2 == 0 && (dir \\u003E 0 ? part.to \\u003E start.ch : part.from \\u003C start.ch)) {\\n    \\u002F\\u002F Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\\n    \\u002F\\u002F nothing interesting happens.\\n    return moveLogically(line, start, dir)\\n  }\\n\\n  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\\n  var prep;\\n  var getWrappedLineExtent = function (ch) {\\n    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\\n    prep = prep || prepareMeasureForLine(cm, line);\\n    return wrappedLineExtentChar(cm, line, prep, ch)\\n  };\\n  var wrappedLineExtent = getWrappedLineExtent(start.sticky == \\\"before\\\" ? mv(start, -1) : start.ch);\\n\\n  if (cm.doc.direction == \\\"rtl\\\" || part.level == 1) {\\n    var moveInStorageOrder = (part.level == 1) == (dir \\u003C 0);\\n    var ch = mv(start, moveInStorageOrder ? 1 : -1);\\n    if (ch != null && (!moveInStorageOrder ? ch \\u003E= part.from && ch \\u003E= wrappedLineExtent.begin : ch \\u003C= part.to && ch \\u003C= wrappedLineExtent.end)) {\\n      \\u002F\\u002F Case 2: We move within an rtl part or in an rtl editor on the same visual line\\n      var sticky = moveInStorageOrder ? \\\"before\\\" : \\\"after\\\";\\n      return new Pos(start.line, ch, sticky)\\n    }\\n  }\\n\\n  \\u002F\\u002F Case 3: Could not move within this bidi part in this visual line, so leave\\n  \\u002F\\u002F the current bidi part\\n\\n  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\\n    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\\n      ? new Pos(start.line, mv(ch, 1), \\\"before\\\")\\n      : new Pos(start.line, ch, \\\"after\\\"); };\\n\\n    for (; partPos \\u003E= 0 && partPos \\u003C bidi.length; partPos += dir) {\\n      var part = bidi[partPos];\\n      var moveInStorageOrder = (dir \\u003E 0) == (part.level != 1);\\n      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\\n      if (part.from \\u003C= ch && ch \\u003C part.to) { return getRes(ch, moveInStorageOrder) }\\n      ch = moveInStorageOrder ? part.from : mv(part.to, -1);\\n      if (wrappedLineExtent.begin \\u003C= ch && ch \\u003C wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\\n    }\\n  };\\n\\n  \\u002F\\u002F Case 3a: Look for other bidi parts on the same visual line\\n  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\\n  if (res) { return res }\\n\\n  \\u002F\\u002F Case 3b: Look for other bidi parts on the next visual line\\n  var nextCh = dir \\u003E 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\\n  if (nextCh != null && !(dir \\u003E 0 && nextCh == line.text.length)) {\\n    res = searchInVisualLine(dir \\u003E 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\\n    if (res) { return res }\\n  }\\n\\n  \\u002F\\u002F Case 4: Nowhere to move\\n  return null\\n}\\n\\n\\u002F\\u002F Commands are parameter-less actions that can be performed on an\\n\\u002F\\u002F editor, mostly used for keybindings.\\nvar commands = {\\n  selectAll: selectAll,\\n  singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\\\"anchor\\\"), cm.getCursor(\\\"head\\\"), sel_dontScroll); },\\n  killLine: function (cm) { return deleteNearSelection(cm, function (range) {\\n    if (range.empty()) {\\n      var len = getLine(cm.doc, range.head.line).text.length;\\n      if (range.head.ch == len && range.head.line \\u003C cm.lastLine())\\n        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\\n      else\\n        { return {from: range.head, to: Pos(range.head.line, len)} }\\n    } else {\\n      return {from: range.from(), to: range.to()}\\n    }\\n  }); },\\n  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0),\\n    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\\n  }); }); },\\n  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\\n    from: Pos(range.from().line, 0), to: range.from()\\n  }); }); },\\n  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n    var leftPos = cm.coordsChar({left: 0, top: top}, \\\"div\\\");\\n    return {from: leftPos, to: range.from()}\\n  }); },\\n  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\\n    var top = cm.charCoords(range.head, \\\"div\\\").top + 5;\\n    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\");\\n    return {from: range.from(), to: rightPos }\\n  }); },\\n  undo: function (cm) { return cm.undo(); },\\n  redo: function (cm) { return cm.redo(); },\\n  undoSelection: function (cm) { return cm.undoSelection(); },\\n  redoSelection: function (cm) { return cm.redoSelection(); },\\n  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\\n  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\\n  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\\n    {origin: \\\"+move\\\", bias: 1}\\n  ); },\\n  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\\n    {origin: \\\"+move\\\", bias: -1}\\n  ); },\\n  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.cursorCoords(range.head, \\\"div\\\").top + 5;\\n    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.cursorCoords(range.head, \\\"div\\\").top + 5;\\n    return cm.coordsChar({left: 0, top: top}, \\\"div\\\")\\n  }, sel_move); },\\n  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\\n    var top = cm.cursorCoords(range.head, \\\"div\\\").top + 5;\\n    var pos = cm.coordsChar({left: 0, top: top}, \\\"div\\\");\\n    if (pos.ch \\u003C cm.getLine(pos.line).search(\\u002F\\\\S\\u002F)) { return lineStartSmart(cm, range.head) }\\n    return pos\\n  }, sel_move); },\\n  goLineUp: function (cm) { return cm.moveV(-1, \\\"line\\\"); },\\n  goLineDown: function (cm) { return cm.moveV(1, \\\"line\\\"); },\\n  goPageUp: function (cm) { return cm.moveV(-1, \\\"page\\\"); },\\n  goPageDown: function (cm) { return cm.moveV(1, \\\"page\\\"); },\\n  goCharLeft: function (cm) { return cm.moveH(-1, \\\"char\\\"); },\\n  goCharRight: function (cm) { return cm.moveH(1, \\\"char\\\"); },\\n  goColumnLeft: function (cm) { return cm.moveH(-1, \\\"column\\\"); },\\n  goColumnRight: function (cm) { return cm.moveH(1, \\\"column\\\"); },\\n  goWordLeft: function (cm) { return cm.moveH(-1, \\\"word\\\"); },\\n  goGroupRight: function (cm) { return cm.moveH(1, \\\"group\\\"); },\\n  goGroupLeft: function (cm) { return cm.moveH(-1, \\\"group\\\"); },\\n  goWordRight: function (cm) { return cm.moveH(1, \\\"word\\\"); },\\n  delCharBefore: function (cm) { return cm.deleteH(-1, \\\"char\\\"); },\\n  delCharAfter: function (cm) { return cm.deleteH(1, \\\"char\\\"); },\\n  delWordBefore: function (cm) { return cm.deleteH(-1, \\\"word\\\"); },\\n  delWordAfter: function (cm) { return cm.deleteH(1, \\\"word\\\"); },\\n  delGroupBefore: function (cm) { return cm.deleteH(-1, \\\"group\\\"); },\\n  delGroupAfter: function (cm) { return cm.deleteH(1, \\\"group\\\"); },\\n  indentAuto: function (cm) { return cm.indentSelection(\\\"smart\\\"); },\\n  indentMore: function (cm) { return cm.indentSelection(\\\"add\\\"); },\\n  indentLess: function (cm) { return cm.indentSelection(\\\"subtract\\\"); },\\n  insertTab: function (cm) { return cm.replaceSelection(\\\"\\\\t\\\"); },\\n  insertSoftTab: function (cm) {\\n    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\\n    for (var i = 0; i \\u003C ranges.length; i++) {\\n      var pos = ranges[i].from();\\n      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\\n      spaces.push(spaceStr(tabSize - col % tabSize));\\n    }\\n    cm.replaceSelections(spaces);\\n  },\\n  defaultTab: function (cm) {\\n    if (cm.somethingSelected()) { cm.indentSelection(\\\"add\\\"); }\\n    else { cm.execCommand(\\\"insertTab\\\"); }\\n  },\\n  \\u002F\\u002F Swap the two chars left and right of each selection's head.\\n  \\u002F\\u002F Move cursor behind the two swapped characters afterwards.\\n  \\u002F\\u002F\\n  \\u002F\\u002F Doesn't consider line feeds a character.\\n  \\u002F\\u002F Doesn't scan more than one line above to find a character.\\n  \\u002F\\u002F Doesn't do anything on an empty line.\\n  \\u002F\\u002F Doesn't do anything with non-empty selections.\\n  transposeChars: function (cm) { return runInOp(cm, function () {\\n    var ranges = cm.listSelections(), newSel = [];\\n    for (var i = 0; i \\u003C ranges.length; i++) {\\n      if (!ranges[i].empty()) { continue }\\n      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\\n      if (line) {\\n        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\\n        if (cur.ch \\u003E 0) {\\n          cur = new Pos(cur.line, cur.ch + 1);\\n          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\\n                          Pos(cur.line, cur.ch - 2), cur, \\\"+transpose\\\");\\n        } else if (cur.line \\u003E cm.doc.first) {\\n          var prev = getLine(cm.doc, cur.line - 1).text;\\n          if (prev) {\\n            cur = new Pos(cur.line, 1);\\n            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\\n                            prev.charAt(prev.length - 1),\\n                            Pos(cur.line - 1, prev.length - 1), cur, \\\"+transpose\\\");\\n          }\\n        }\\n      }\\n      newSel.push(new Range(cur, cur));\\n    }\\n    cm.setSelections(newSel);\\n  }); },\\n  newlineAndIndent: function (cm) { return runInOp(cm, function () {\\n    var sels = cm.listSelections();\\n    for (var i = sels.length - 1; i \\u003E= 0; i--)\\n      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \\\"+input\\\"); }\\n    sels = cm.listSelections();\\n    for (var i$1 = 0; i$1 \\u003C sels.length; i$1++)\\n      { cm.indentLine(sels[i$1].from().line, null, true); }\\n    ensureCursorVisible(cm);\\n  }); },\\n  openLine: function (cm) { return cm.replaceSelection(\\\"\\\\n\\\", \\\"start\\\"); },\\n  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\\n};\\n\\n\\nfunction lineStart(cm, lineN) {\\n  var line = getLine(cm.doc, lineN);\\n  var visual = visualLine(line);\\n  if (visual != line) { lineN = lineNo(visual); }\\n  return endOfLine(true, cm, visual, lineN, 1)\\n}\\nfunction lineEnd(cm, lineN) {\\n  var line = getLine(cm.doc, lineN);\\n  var visual = visualLineEnd(line);\\n  if (visual != line) { lineN = lineNo(visual); }\\n  return endOfLine(true, cm, line, lineN, -1)\\n}\\nfunction lineStartSmart(cm, pos) {\\n  var start = lineStart(cm, pos.line);\\n  var line = getLine(cm.doc, start.line);\\n  var order = getOrder(line, cm.doc.direction);\\n  if (!order || order[0].level == 0) {\\n    var firstNonWS = Math.max(0, line.text.search(\\u002F\\\\S\\u002F));\\n    var inWS = pos.line == start.line && pos.ch \\u003C= firstNonWS && pos.ch;\\n    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\\n  }\\n  return start\\n}\\n\\n\\u002F\\u002F Run a handler that was bound to a key.\\nfunction doHandleBinding(cm, bound, dropShift) {\\n  if (typeof bound == \\\"string\\\") {\\n    bound = commands[bound];\\n    if (!bound) { return false }\\n  }\\n  \\u002F\\u002F Ensure previous input has been read, so that the handler sees a\\n  \\u002F\\u002F consistent view of the document\\n  cm.display.input.ensurePolled();\\n  var prevShift = cm.display.shift, done = false;\\n  try {\\n    if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\\n    if (dropShift) { cm.display.shift = false; }\\n    done = bound(cm) != Pass;\\n  } finally {\\n    cm.display.shift = prevShift;\\n    cm.state.suppressEdits = false;\\n  }\\n  return done\\n}\\n\\nfunction lookupKeyForEditor(cm, name, handle) {\\n  for (var i = 0; i \\u003C cm.state.keyMaps.length; i++) {\\n    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\\n    if (result) { return result }\\n  }\\n  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\\n    || lookupKey(name, cm.options.keyMap, handle, cm)\\n}\\n\\n\\u002F\\u002F Note that, despite the name, this function is also used to check\\n\\u002F\\u002F for bound mouse clicks.\\n\\nvar stopSeq = new Delayed;\\n\\nfunction dispatchKey(cm, name, e, handle) {\\n  var seq = cm.state.keySeq;\\n  if (seq) {\\n    if (isModifierKey(name)) { return \\\"handled\\\" }\\n    if (\\u002F\\\\'$\\u002F.test(name))\\n      { cm.state.keySeq = null; }\\n    else\\n      { stopSeq.set(50, function () {\\n        if (cm.state.keySeq == seq) {\\n          cm.state.keySeq = null;\\n          cm.display.input.reset();\\n        }\\n      }); }\\n    if (dispatchKeyInner(cm, seq + \\\" \\\" + name, e, handle)) { return true }\\n  }\\n  return dispatchKeyInner(cm, name, e, handle)\\n}\\n\\nfunction dispatchKeyInner(cm, name, e, handle) {\\n  var result = lookupKeyForEditor(cm, name, handle);\\n\\n  if (result == \\\"multi\\\")\\n    { cm.state.keySeq = name; }\\n  if (result == \\\"handled\\\")\\n    { signalLater(cm, \\\"keyHandled\\\", cm, name, e); }\\n\\n  if (result == \\\"handled\\\" || result == \\\"multi\\\") {\\n    e_preventDefault(e);\\n    restartBlink(cm);\\n  }\\n\\n  return !!result\\n}\\n\\n\\u002F\\u002F Handle a key from the keydown event.\\nfunction handleKeyBinding(cm, e) {\\n  var name = keyName(e, true);\\n  if (!name) { return false }\\n\\n  if (e.shiftKey && !cm.state.keySeq) {\\n    \\u002F\\u002F First try to resolve full name (including 'Shift-'). Failing\\n    \\u002F\\u002F that, see if there is a cursor-motion command (starting with\\n    \\u002F\\u002F 'go') bound to the keyname without 'Shift-'.\\n    return dispatchKey(cm, \\\"Shift-\\\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\\n        || dispatchKey(cm, name, e, function (b) {\\n             if (typeof b == \\\"string\\\" ? \\u002F^go[A-Z]\\u002F.test(b) : b.motion)\\n               { return doHandleBinding(cm, b) }\\n           })\\n  } else {\\n    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\\n  }\\n}\\n\\n\\u002F\\u002F Handle a key from the keypress event\\nfunction handleCharBinding(cm, e, ch) {\\n  return dispatchKey(cm, \\\"'\\\" + ch + \\\"'\\\", e, function (b) { return doHandleBinding(cm, b, true); })\\n}\\n\\nvar lastStoppedKey = null;\\nfunction onKeyDown(e) {\\n  var cm = this;\\n  cm.curOp.focus = activeElt();\\n  if (signalDOMEvent(cm, e)) { return }\\n  \\u002F\\u002F IE does strange things with escape.\\n  if (ie && ie_version \\u003C 11 && e.keyCode == 27) { e.returnValue = false; }\\n  var code = e.keyCode;\\n  cm.display.shift = code == 16 || e.shiftKey;\\n  var handled = handleKeyBinding(cm, e);\\n  if (presto) {\\n    lastStoppedKey = handled ? code : null;\\n    \\u002F\\u002F Opera has no cut event... we try to at least catch the key combo\\n    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\\n      { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\"); }\\n  }\\n\\n  \\u002F\\u002F Turn mouse into crosshair when Alt is held on Mac.\\n  if (code == 18 && !\\u002F\\\\bCodeMirror-crosshair\\\\b\\u002F.test(cm.display.lineDiv.className))\\n    { showCrossHair(cm); }\\n}\\n\\nfunction showCrossHair(cm) {\\n  var lineDiv = cm.display.lineDiv;\\n  addClass(lineDiv, \\\"CodeMirror-crosshair\\\");\\n\\n  function up(e) {\\n    if (e.keyCode == 18 || !e.altKey) {\\n      rmClass(lineDiv, \\\"CodeMirror-crosshair\\\");\\n      off(document, \\\"keyup\\\", up);\\n      off(document, \\\"mouseover\\\", up);\\n    }\\n  }\\n  on(document, \\\"keyup\\\", up);\\n  on(document, \\\"mouseover\\\", up);\\n}\\n\\nfunction onKeyUp(e) {\\n  if (e.keyCode == 16) { this.doc.sel.shift = false; }\\n  signalDOMEvent(this, e);\\n}\\n\\nfunction onKeyPress(e) {\\n  var cm = this;\\n  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\\n  var keyCode = e.keyCode, charCode = e.charCode;\\n  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\\n  if ((presto && (!e.which || e.which \\u003C 10)) && handleKeyBinding(cm, e)) { return }\\n  var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\\n  \\u002F\\u002F Some browsers fire keypress events for backspace\\n  if (ch == \\\"\\\\x08\\\") { return }\\n  if (handleCharBinding(cm, e, ch)) { return }\\n  cm.display.input.onKeyPress(e);\\n}\\n\\nvar DOUBLECLICK_DELAY = 400;\\n\\nvar PastClick = function(time, pos, button) {\\n  this.time = time;\\n  this.pos = pos;\\n  this.button = button;\\n};\\n\\nPastClick.prototype.compare = function (time, pos, button) {\\n  return this.time + DOUBLECLICK_DELAY \\u003E time &&\\n    cmp(pos, this.pos) == 0 && button == this.button\\n};\\n\\nvar lastClick;\\nvar lastDoubleClick;\\nfunction clickRepeat(pos, button) {\\n  var now = +new Date;\\n  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\\n    lastClick = lastDoubleClick = null;\\n    return \\\"triple\\\"\\n  } else if (lastClick && lastClick.compare(now, pos, button)) {\\n    lastDoubleClick = new PastClick(now, pos, button);\\n    lastClick = null;\\n    return \\\"double\\\"\\n  } else {\\n    lastClick = new PastClick(now, pos, button);\\n    lastDoubleClick = null;\\n    return \\\"single\\\"\\n  }\\n}\\n\\n\\u002F\\u002F A mouse down can be a single click, double click, triple click,\\n\\u002F\\u002F start of selection drag, start of text drag, new cursor\\n\\u002F\\u002F (ctrl-click), rectangle drag (alt-drag), or xwin\\n\\u002F\\u002F middle-click-paste. Or it might be a click on something we should\\n\\u002F\\u002F not interfere with, such as a scrollbar or widget.\\nfunction onMouseDown(e) {\\n  var cm = this, display = cm.display;\\n  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\\n  display.input.ensurePolled();\\n  display.shift = e.shiftKey;\\n\\n  if (eventInWidget(display, e)) {\\n    if (!webkit) {\\n      \\u002F\\u002F Briefly turn off draggability, to allow widgets to do\\n      \\u002F\\u002F normal dragging things.\\n      display.scroller.draggable = false;\\n      setTimeout(function () { return display.scroller.draggable = true; }, 100);\\n    }\\n    return\\n  }\\n  if (clickInGutter(cm, e)) { return }\\n  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \\\"single\\\";\\n  window.focus();\\n\\n  \\u002F\\u002F #3261: make sure, that we're not starting a second selection\\n  if (button == 1 && cm.state.selectingText)\\n    { cm.state.selectingText(e); }\\n\\n  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\\n\\n  if (button == 1) {\\n    if (pos) { leftButtonDown(cm, pos, repeat, e); }\\n    else if (e_target(e) == display.scroller) { e_preventDefault(e); }\\n  } else if (button == 2) {\\n    if (pos) { extendSelection(cm.doc, pos); }\\n    setTimeout(function () { return display.input.focus(); }, 20);\\n  } else if (button == 3) {\\n    if (captureRightClick) { onContextMenu(cm, e); }\\n    else { delayBlurEvent(cm); }\\n  }\\n}\\n\\nfunction handleMappedButton(cm, button, pos, repeat, event) {\\n  var name = \\\"Click\\\";\\n  if (repeat == \\\"double\\\") { name = \\\"Double\\\" + name; }\\n  else if (repeat == \\\"triple\\\") { name = \\\"Triple\\\" + name; }\\n  name = (button == 1 ? \\\"Left\\\" : button == 2 ? \\\"Middle\\\" : \\\"Right\\\") + name;\\n\\n  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\\n    if (typeof bound == \\\"string\\\") { bound = commands[bound]; }\\n    if (!bound) { return false }\\n    var done = false;\\n    try {\\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\\n      done = bound(cm, pos) != Pass;\\n    } finally {\\n      cm.state.suppressEdits = false;\\n    }\\n    return done\\n  })\\n}\\n\\nfunction configureMouse(cm, repeat, event) {\\n  var option = cm.getOption(\\\"configureMouse\\\");\\n  var value = option ? option(cm, repeat, event) : {};\\n  if (value.unit == null) {\\n    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\\n    value.unit = rect ? \\\"rectangle\\\" : repeat == \\\"single\\\" ? \\\"char\\\" : repeat == \\\"double\\\" ? \\\"word\\\" : \\\"line\\\";\\n  }\\n  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\\n  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\\n  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\\n  return value\\n}\\n\\nfunction leftButtonDown(cm, pos, repeat, event) {\\n  if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\\n  else { cm.curOp.focus = activeElt(); }\\n\\n  var behavior = configureMouse(cm, repeat, event);\\n\\n  var sel = cm.doc.sel, contained;\\n  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\\n      repeat == \\\"single\\\" && (contained = sel.contains(pos)) \\u003E -1 &&\\n      (cmp((contained = sel.ranges[contained]).from(), pos) \\u003C 0 || pos.xRel \\u003E 0) &&\\n      (cmp(contained.to(), pos) \\u003E 0 || pos.xRel \\u003C 0))\\n    { leftButtonStartDrag(cm, event, pos, behavior); }\\n  else\\n    { leftButtonSelect(cm, event, pos, behavior); }\\n}\\n\\n\\u002F\\u002F Start a text drag. When it ends, see if any dragging actually\\n\\u002F\\u002F happen, and treat as a click if it didn't.\\nfunction leftButtonStartDrag(cm, event, pos, behavior) {\\n  var display = cm.display, moved = false;\\n  var dragEnd = operation(cm, function (e) {\\n    if (webkit) { display.scroller.draggable = false; }\\n    cm.state.draggingText = false;\\n    off(document, \\\"mouseup\\\", dragEnd);\\n    off(document, \\\"mousemove\\\", mouseMove);\\n    off(display.scroller, \\\"dragstart\\\", dragStart);\\n    off(display.scroller, \\\"drop\\\", dragEnd);\\n    if (!moved) {\\n      e_preventDefault(e);\\n      if (!behavior.addNew)\\n        { extendSelection(cm.doc, pos, null, null, behavior.extend); }\\n      \\u002F\\u002F Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\\n      if (webkit || ie && ie_version == 9)\\n        { setTimeout(function () {document.body.focus(); display.input.focus();}, 20); }\\n      else\\n        { display.input.focus(); }\\n    }\\n  });\\n  var mouseMove = function(e2) {\\n    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) \\u003E= 10;\\n  };\\n  var dragStart = function () { return moved = true; };\\n  \\u002F\\u002F Let the drag handler handle this.\\n  if (webkit) { display.scroller.draggable = true; }\\n  cm.state.draggingText = dragEnd;\\n  dragEnd.copy = !behavior.moveOnDrag;\\n  \\u002F\\u002F IE's approach to draggable\\n  if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\\n  on(document, \\\"mouseup\\\", dragEnd);\\n  on(document, \\\"mousemove\\\", mouseMove);\\n  on(display.scroller, \\\"dragstart\\\", dragStart);\\n  on(display.scroller, \\\"drop\\\", dragEnd);\\n\\n  delayBlurEvent(cm);\\n  setTimeout(function () { return display.input.focus(); }, 20);\\n}\\n\\nfunction rangeForUnit(cm, pos, unit) {\\n  if (unit == \\\"char\\\") { return new Range(pos, pos) }\\n  if (unit == \\\"word\\\") { return cm.findWordAt(pos) }\\n  if (unit == \\\"line\\\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\\n  var result = unit(cm, pos);\\n  return new Range(result.from, result.to)\\n}\\n\\n\\u002F\\u002F Normal selection, as opposed to text dragging.\\nfunction leftButtonSelect(cm, event, start, behavior) {\\n  var display = cm.display, doc = cm.doc;\\n  e_preventDefault(event);\\n\\n  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\\n  if (behavior.addNew && !behavior.extend) {\\n    ourIndex = doc.sel.contains(start);\\n    if (ourIndex \\u003E -1)\\n      { ourRange = ranges[ourIndex]; }\\n    else\\n      { ourRange = new Range(start, start); }\\n  } else {\\n    ourRange = doc.sel.primary();\\n    ourIndex = doc.sel.primIndex;\\n  }\\n\\n  if (behavior.unit == \\\"rectangle\\\") {\\n    if (!behavior.addNew) { ourRange = new Range(start, start); }\\n    start = posFromMouse(cm, event, true, true);\\n    ourIndex = -1;\\n  } else {\\n    var range$$1 = rangeForUnit(cm, start, behavior.unit);\\n    if (behavior.extend)\\n      { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\\n    else\\n      { ourRange = range$$1; }\\n  }\\n\\n  if (!behavior.addNew) {\\n    ourIndex = 0;\\n    setSelection(doc, new Selection([ourRange], 0), sel_mouse);\\n    startSel = doc.sel;\\n  } else if (ourIndex == -1) {\\n    ourIndex = ranges.length;\\n    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\\n                 {scroll: false, origin: \\\"*mouse\\\"});\\n  } else if (ranges.length \\u003E 1 && ranges[ourIndex].empty() && behavior.unit == \\\"char\\\" && !behavior.extend) {\\n    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\\n                 {scroll: false, origin: \\\"*mouse\\\"});\\n    startSel = doc.sel;\\n  } else {\\n    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\\n  }\\n\\n  var lastPos = start;\\n  function extendTo(pos) {\\n    if (cmp(lastPos, pos) == 0) { return }\\n    lastPos = pos;\\n\\n    if (behavior.unit == \\\"rectangle\\\") {\\n      var ranges = [], tabSize = cm.options.tabSize;\\n      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\\n      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\\n      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\\n      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\\n           line \\u003C= end; line++) {\\n        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\\n        if (left == right)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\\n        else if (text.length \\u003E leftPos)\\n          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\\n      }\\n      if (!ranges.length) { ranges.push(new Range(start, start)); }\\n      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\\n                   {origin: \\\"*mouse\\\", scroll: false});\\n      cm.scrollIntoView(pos);\\n    } else {\\n      var oldRange = ourRange;\\n      var range$$1 = rangeForUnit(cm, pos, behavior.unit);\\n      var anchor = oldRange.anchor, head;\\n      if (cmp(range$$1.anchor, anchor) \\u003E 0) {\\n        head = range$$1.head;\\n        anchor = minPos(oldRange.from(), range$$1.anchor);\\n      } else {\\n        head = range$$1.anchor;\\n        anchor = maxPos(oldRange.to(), range$$1.head);\\n      }\\n      var ranges$1 = startSel.ranges.slice(0);\\n      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\\n      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse);\\n    }\\n  }\\n\\n  var editorSize = display.wrapper.getBoundingClientRect();\\n  \\u002F\\u002F Used to ensure timeout re-tries don't fire when another extend\\n  \\u002F\\u002F happened in the meantime (clearTimeout isn't reliable -- at\\n  \\u002F\\u002F least on Chrome, the timeouts still happen even when cleared,\\n  \\u002F\\u002F if the clear happens after their scheduled firing time).\\n  var counter = 0;\\n\\n  function extend(e) {\\n    var curCount = ++counter;\\n    var cur = posFromMouse(cm, e, true, behavior.unit == \\\"rectangle\\\");\\n    if (!cur) { return }\\n    if (cmp(cur, lastPos) != 0) {\\n      cm.curOp.focus = activeElt();\\n      extendTo(cur);\\n      var visible = visibleLines(display, doc);\\n      if (cur.line \\u003E= visible.to || cur.line \\u003C visible.from)\\n        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\\n    } else {\\n      var outside = e.clientY \\u003C editorSize.top ? -20 : e.clientY \\u003E editorSize.bottom ? 20 : 0;\\n      if (outside) { setTimeout(operation(cm, function () {\\n        if (counter != curCount) { return }\\n        display.scroller.scrollTop += outside;\\n        extend(e);\\n      }), 50); }\\n    }\\n  }\\n\\n  function done(e) {\\n    cm.state.selectingText = false;\\n    counter = Infinity;\\n    e_preventDefault(e);\\n    display.input.focus();\\n    off(document, \\\"mousemove\\\", move);\\n    off(document, \\\"mouseup\\\", up);\\n    doc.history.lastSelOrigin = null;\\n  }\\n\\n  var move = operation(cm, function (e) {\\n    if (!e_button(e)) { done(e); }\\n    else { extend(e); }\\n  });\\n  var up = operation(cm, done);\\n  cm.state.selectingText = up;\\n  on(document, \\\"mousemove\\\", move);\\n  on(document, \\\"mouseup\\\", up);\\n}\\n\\n\\u002F\\u002F Used when mouse-selecting to adjust the anchor to the proper side\\n\\u002F\\u002F of a bidi jump depending on the visual position of the head.\\nfunction bidiSimplify(cm, range$$1) {\\n  var anchor = range$$1.anchor;\\n  var head = range$$1.head;\\n  var anchorLine = getLine(cm.doc, anchor.line);\\n  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\\n  var order = getOrder(anchorLine);\\n  if (!order) { return range$$1 }\\n  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\\n  if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\\n  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\\n  if (boundary == 0 || boundary == order.length) { return range$$1 }\\n\\n  \\u002F\\u002F Compute the relative visual position of the head compared to the\\n  \\u002F\\u002F anchor (\\u003C0 is to the left, \\u003E0 to the right)\\n  var leftSide;\\n  if (head.line != anchor.line) {\\n    leftSide = (head.line - anchor.line) * (cm.doc.direction == \\\"ltr\\\" ? 1 : -1) \\u003E 0;\\n  } else {\\n    var headIndex = getBidiPartAt(order, head.ch, head.sticky);\\n    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\\n    if (headIndex == boundary - 1 || headIndex == boundary)\\n      { leftSide = dir \\u003C 0; }\\n    else\\n      { leftSide = dir \\u003E 0; }\\n  }\\n\\n  var usePart = order[boundary + (leftSide ? -1 : 0)];\\n  var from = leftSide == (usePart.level == 1);\\n  var ch = from ? usePart.from : usePart.to, sticky = from ? \\\"after\\\" : \\\"before\\\";\\n  return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\\n}\\n\\n\\n\\u002F\\u002F Determines whether an event happened in the gutter, and fires the\\n\\u002F\\u002F handlers for the corresponding event.\\nfunction gutterEvent(cm, e, type, prevent) {\\n  var mX, mY;\\n  if (e.touches) {\\n    mX = e.touches[0].clientX;\\n    mY = e.touches[0].clientY;\\n  } else {\\n    try { mX = e.clientX; mY = e.clientY; }\\n    catch(e) { return false }\\n  }\\n  if (mX \\u003E= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\\n  if (prevent) { e_preventDefault(e); }\\n\\n  var display = cm.display;\\n  var lineBox = display.lineDiv.getBoundingClientRect();\\n\\n  if (mY \\u003E lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\\n  mY -= lineBox.top - display.viewOffset;\\n\\n  for (var i = 0; i \\u003C cm.options.gutters.length; ++i) {\\n    var g = display.gutters.childNodes[i];\\n    if (g && g.getBoundingClientRect().right \\u003E= mX) {\\n      var line = lineAtHeight(cm.doc, mY);\\n      var gutter = cm.options.gutters[i];\\n      signal(cm, type, cm, line, gutter, e);\\n      return e_defaultPrevented(e)\\n    }\\n  }\\n}\\n\\nfunction clickInGutter(cm, e) {\\n  return gutterEvent(cm, e, \\\"gutterClick\\\", true)\\n}\\n\\n\\u002F\\u002F CONTEXT MENU HANDLING\\n\\n\\u002F\\u002F To make the context menu work, we need to briefly unhide the\\n\\u002F\\u002F textarea (making it as unobtrusive as possible) to let the\\n\\u002F\\u002F right-click take effect on it.\\nfunction onContextMenu(cm, e) {\\n  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\\n  if (signalDOMEvent(cm, e, \\\"contextmenu\\\")) { return }\\n  cm.display.input.onContextMenu(e);\\n}\\n\\nfunction contextMenuInGutter(cm, e) {\\n  if (!hasHandler(cm, \\\"gutterContextMenu\\\")) { return false }\\n  return gutterEvent(cm, e, \\\"gutterContextMenu\\\", false)\\n}\\n\\nfunction themeChanged(cm) {\\n  cm.display.wrapper.className = cm.display.wrapper.className.replace(\\u002F\\\\s*cm-s-\\\\S+\\u002Fg, \\\"\\\") +\\n    cm.options.theme.replace(\\u002F(^|\\\\s)\\\\s*\\u002Fg, \\\" cm-s-\\\");\\n  clearCaches(cm);\\n}\\n\\nvar Init = {toString: function(){return \\\"CodeMirror.Init\\\"}};\\n\\nvar defaults = {};\\nvar optionHandlers = {};\\n\\nfunction defineOptions(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers;\\n\\n  function option(name, deflt, handle, notOnInit) {\\n    CodeMirror.defaults[name] = deflt;\\n    if (handle) { optionHandlers[name] =\\n      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\\n  }\\n\\n  CodeMirror.defineOption = option;\\n\\n  \\u002F\\u002F Passed to option handlers when there is no old value.\\n  CodeMirror.Init = Init;\\n\\n  \\u002F\\u002F These two are, on init, called from the constructor because they\\n  \\u002F\\u002F have to be initialized before the editor can start at all.\\n  option(\\\"value\\\", \\\"\\\", function (cm, val) { return cm.setValue(val); }, true);\\n  option(\\\"mode\\\", null, function (cm, val) {\\n    cm.doc.modeOption = val;\\n    loadMode(cm);\\n  }, true);\\n\\n  option(\\\"indentUnit\\\", 2, loadMode, true);\\n  option(\\\"indentWithTabs\\\", false);\\n  option(\\\"smartIndent\\\", true);\\n  option(\\\"tabSize\\\", 4, function (cm) {\\n    resetModeState(cm);\\n    clearCaches(cm);\\n    regChange(cm);\\n  }, true);\\n\\n  option(\\\"lineSeparator\\\", null, function (cm, val) {\\n    cm.doc.lineSep = val;\\n    if (!val) { return }\\n    var newBreaks = [], lineNo = cm.doc.first;\\n    cm.doc.iter(function (line) {\\n      for (var pos = 0;;) {\\n        var found = line.text.indexOf(val, pos);\\n        if (found == -1) { break }\\n        pos = found + val.length;\\n        newBreaks.push(Pos(lineNo, found));\\n      }\\n      lineNo++;\\n    });\\n    for (var i = newBreaks.length - 1; i \\u003E= 0; i--)\\n      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\\n  });\\n  option(\\\"specialChars\\\", \\u002F[\\\\u0000-\\\\u001f\\\\u007f-\\\\u009f\\\\u00ad\\\\u061c\\\\u200b-\\\\u200f\\\\u2028\\\\u2029\\\\ufeff]\\u002Fg, function (cm, val, old) {\\n    cm.state.specialChars = new RegExp(val.source + (val.test(\\\"\\\\t\\\") ? \\\"\\\" : \\\"|\\\\t\\\"), \\\"g\\\");\\n    if (old != Init) { cm.refresh(); }\\n  });\\n  option(\\\"specialCharPlaceholder\\\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\\n  option(\\\"electricChars\\\", true);\\n  option(\\\"inputStyle\\\", mobile ? \\\"contenteditable\\\" : \\\"textarea\\\", function () {\\n    throw new Error(\\\"inputStyle can not (yet) be changed in a running editor\\\") \\u002F\\u002F FIXME\\n  }, true);\\n  option(\\\"spellcheck\\\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\\n  option(\\\"rtlMoveVisually\\\", !windows);\\n  option(\\\"wholeLineUpdateBefore\\\", true);\\n\\n  option(\\\"theme\\\", \\\"default\\\", function (cm) {\\n    themeChanged(cm);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"keyMap\\\", \\\"default\\\", function (cm, val, old) {\\n    var next = getKeyMap(val);\\n    var prev = old != Init && getKeyMap(old);\\n    if (prev && prev.detach) { prev.detach(cm, next); }\\n    if (next.attach) { next.attach(cm, prev || null); }\\n  });\\n  option(\\\"extraKeys\\\", null);\\n  option(\\\"configureMouse\\\", null);\\n\\n  option(\\\"lineWrapping\\\", false, wrappingChanged, true);\\n  option(\\\"gutters\\\", [], function (cm) {\\n    setGuttersForLineNumbers(cm.options);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"fixedGutter\\\", true, function (cm, val) {\\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \\\"px\\\" : \\\"0\\\";\\n    cm.refresh();\\n  }, true);\\n  option(\\\"coverGutterNextToScrollbar\\\", false, function (cm) { return updateScrollbars(cm); }, true);\\n  option(\\\"scrollbarStyle\\\", \\\"native\\\", function (cm) {\\n    initScrollbars(cm);\\n    updateScrollbars(cm);\\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\\n  }, true);\\n  option(\\\"lineNumbers\\\", false, function (cm) {\\n    setGuttersForLineNumbers(cm.options);\\n    guttersChanged(cm);\\n  }, true);\\n  option(\\\"firstLineNumber\\\", 1, guttersChanged, true);\\n  option(\\\"lineNumberFormatter\\\", function (integer) { return integer; }, guttersChanged, true);\\n  option(\\\"showCursorWhenSelecting\\\", false, updateSelection, true);\\n\\n  option(\\\"resetSelectionOnContextMenu\\\", true);\\n  option(\\\"lineWiseCopyCut\\\", true);\\n  option(\\\"pasteLinesPerSelection\\\", true);\\n\\n  option(\\\"readOnly\\\", false, function (cm, val) {\\n    if (val == \\\"nocursor\\\") {\\n      onBlur(cm);\\n      cm.display.input.blur();\\n    }\\n    cm.display.input.readOnlyChanged(val);\\n  });\\n  option(\\\"disableInput\\\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\\n  option(\\\"dragDrop\\\", true, dragDropChanged);\\n  option(\\\"allowDropFileTypes\\\", null);\\n\\n  option(\\\"cursorBlinkRate\\\", 530);\\n  option(\\\"cursorScrollMargin\\\", 0);\\n  option(\\\"cursorHeight\\\", 1, updateSelection, true);\\n  option(\\\"singleCursorHeightPerLine\\\", true, updateSelection, true);\\n  option(\\\"workTime\\\", 100);\\n  option(\\\"workDelay\\\", 100);\\n  option(\\\"flattenSpans\\\", true, resetModeState, true);\\n  option(\\\"addModeClass\\\", false, resetModeState, true);\\n  option(\\\"pollInterval\\\", 100);\\n  option(\\\"undoDepth\\\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\\n  option(\\\"historyEventDelay\\\", 1250);\\n  option(\\\"viewportMargin\\\", 10, function (cm) { return cm.refresh(); }, true);\\n  option(\\\"maxHighlightLength\\\", 10000, resetModeState, true);\\n  option(\\\"moveInputWithCursor\\\", true, function (cm, val) {\\n    if (!val) { cm.display.input.resetPosition(); }\\n  });\\n\\n  option(\\\"tabindex\\\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \\\"\\\"; });\\n  option(\\\"autofocus\\\", null);\\n  option(\\\"direction\\\", \\\"ltr\\\", function (cm, val) { return cm.doc.setDirection(val); }, true);\\n}\\n\\nfunction guttersChanged(cm) {\\n  updateGutters(cm);\\n  regChange(cm);\\n  alignHorizontally(cm);\\n}\\n\\nfunction dragDropChanged(cm, value, old) {\\n  var wasOn = old && old != Init;\\n  if (!value != !wasOn) {\\n    var funcs = cm.display.dragFunctions;\\n    var toggle = value ? on : off;\\n    toggle(cm.display.scroller, \\\"dragstart\\\", funcs.start);\\n    toggle(cm.display.scroller, \\\"dragenter\\\", funcs.enter);\\n    toggle(cm.display.scroller, \\\"dragover\\\", funcs.over);\\n    toggle(cm.display.scroller, \\\"dragleave\\\", funcs.leave);\\n    toggle(cm.display.scroller, \\\"drop\\\", funcs.drop);\\n  }\\n}\\n\\nfunction wrappingChanged(cm) {\\n  if (cm.options.lineWrapping) {\\n    addClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\");\\n    cm.display.sizer.style.minWidth = \\\"\\\";\\n    cm.display.sizerWidth = null;\\n  } else {\\n    rmClass(cm.display.wrapper, \\\"CodeMirror-wrap\\\");\\n    findMaxLine(cm);\\n  }\\n  estimateLineHeights(cm);\\n  regChange(cm);\\n  clearCaches(cm);\\n  setTimeout(function () { return updateScrollbars(cm); }, 100);\\n}\\n\\n\\u002F\\u002F A CodeMirror instance represents an editor. This is the object\\n\\u002F\\u002F that user code is usually dealing with.\\n\\nfunction CodeMirror$1(place, options) {\\n  var this$1 = this;\\n\\n  if (!(this instanceof CodeMirror$1)) { return new CodeMirror$1(place, options) }\\n\\n  this.options = options = options ? copyObj(options) : {};\\n  \\u002F\\u002F Determine effective options based on given values and defaults.\\n  copyObj(defaults, options, false);\\n  setGuttersForLineNumbers(options);\\n\\n  var doc = options.value;\\n  if (typeof doc == \\\"string\\\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\\n  this.doc = doc;\\n\\n  var input = new CodeMirror$1.inputStyles[options.inputStyle](this);\\n  var display = this.display = new Display(place, doc, input);\\n  display.wrapper.CodeMirror = this;\\n  updateGutters(this);\\n  themeChanged(this);\\n  if (options.lineWrapping)\\n    { this.display.wrapper.className += \\\" CodeMirror-wrap\\\"; }\\n  initScrollbars(this);\\n\\n  this.state = {\\n    keyMaps: [],  \\u002F\\u002F stores maps added by addKeyMap\\n    overlays: [], \\u002F\\u002F highlighting overlays, as added by addOverlay\\n    modeGen: 0,   \\u002F\\u002F bumped when mode\\u002Foverlay changes, used to invalidate highlighting info\\n    overwrite: false,\\n    delayingBlurEvent: false,\\n    focused: false,\\n    suppressEdits: false, \\u002F\\u002F used to disable editing during key handlers when in readOnly mode\\n    pasteIncoming: false, cutIncoming: false, \\u002F\\u002F help recognize paste\\u002Fcut edits in input.poll\\n    selectingText: false,\\n    draggingText: false,\\n    highlight: new Delayed(), \\u002F\\u002F stores highlight worker timeout\\n    keySeq: null,  \\u002F\\u002F Unfinished key sequence\\n    specialChars: null\\n  };\\n\\n  if (options.autofocus && !mobile) { display.input.focus(); }\\n\\n  \\u002F\\u002F Override magic textarea content restore that IE sometimes does\\n  \\u002F\\u002F on our hidden textarea on reload\\n  if (ie && ie_version \\u003C 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\\n\\n  registerEventHandlers(this);\\n  ensureGlobalHandlers();\\n\\n  startOperation(this);\\n  this.curOp.forceUpdate = true;\\n  attachDoc(this, doc);\\n\\n  if ((options.autofocus && !mobile) || this.hasFocus())\\n    { setTimeout(bind(onFocus, this), 20); }\\n  else\\n    { onBlur(this); }\\n\\n  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\\n    { optionHandlers[opt](this$1, options[opt], Init); } }\\n  maybeUpdateLineNumberWidth(this);\\n  if (options.finishInit) { options.finishInit(this); }\\n  for (var i = 0; i \\u003C initHooks.length; ++i) { initHooks[i](this$1); }\\n  endOperation(this);\\n  \\u002F\\u002F Suppress optimizelegibility in Webkit, since it breaks text\\n  \\u002F\\u002F measuring on line wrapping boundaries.\\n  if (webkit && options.lineWrapping &&\\n      getComputedStyle(display.lineDiv).textRendering == \\\"optimizelegibility\\\")\\n    { display.lineDiv.style.textRendering = \\\"auto\\\"; }\\n}\\n\\n\\u002F\\u002F The default configuration options.\\nCodeMirror$1.defaults = defaults;\\n\\u002F\\u002F Functions to run when options are changed.\\nCodeMirror$1.optionHandlers = optionHandlers;\\n\\n\\u002F\\u002F Attach the necessary event handlers when initializing the editor\\nfunction registerEventHandlers(cm) {\\n  var d = cm.display;\\n  on(d.scroller, \\\"mousedown\\\", operation(cm, onMouseDown));\\n  \\u002F\\u002F Older IE's will not fire a second mousedown for a double click\\n  if (ie && ie_version \\u003C 11)\\n    { on(d.scroller, \\\"dblclick\\\", operation(cm, function (e) {\\n      if (signalDOMEvent(cm, e)) { return }\\n      var pos = posFromMouse(cm, e);\\n      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\\n      e_preventDefault(e);\\n      var word = cm.findWordAt(pos);\\n      extendSelection(cm.doc, word.anchor, word.head);\\n    })); }\\n  else\\n    { on(d.scroller, \\\"dblclick\\\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\\n  \\u002F\\u002F Some browsers fire contextmenu *after* opening the menu, at\\n  \\u002F\\u002F which point we can't mess with it anymore. Context menu is\\n  \\u002F\\u002F handled in onMouseDown for these browsers.\\n  if (!captureRightClick) { on(d.scroller, \\\"contextmenu\\\", function (e) { return onContextMenu(cm, e); }); }\\n\\n  \\u002F\\u002F Used to suppress mouse event handling when a touch happens\\n  var touchFinished, prevTouch = {end: 0};\\n  function finishTouch() {\\n    if (d.activeTouch) {\\n      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\\n      prevTouch = d.activeTouch;\\n      prevTouch.end = +new Date;\\n    }\\n  }\\n  function isMouseLikeTouchEvent(e) {\\n    if (e.touches.length != 1) { return false }\\n    var touch = e.touches[0];\\n    return touch.radiusX \\u003C= 1 && touch.radiusY \\u003C= 1\\n  }\\n  function farAway(touch, other) {\\n    if (other.left == null) { return true }\\n    var dx = other.left - touch.left, dy = other.top - touch.top;\\n    return dx * dx + dy * dy \\u003E 20 * 20\\n  }\\n  on(d.scroller, \\\"touchstart\\\", function (e) {\\n    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\\n      d.input.ensurePolled();\\n      clearTimeout(touchFinished);\\n      var now = +new Date;\\n      d.activeTouch = {start: now, moved: false,\\n                       prev: now - prevTouch.end \\u003C= 300 ? prevTouch : null};\\n      if (e.touches.length == 1) {\\n        d.activeTouch.left = e.touches[0].pageX;\\n        d.activeTouch.top = e.touches[0].pageY;\\n      }\\n    }\\n  });\\n  on(d.scroller, \\\"touchmove\\\", function () {\\n    if (d.activeTouch) { d.activeTouch.moved = true; }\\n  });\\n  on(d.scroller, \\\"touchend\\\", function (e) {\\n    var touch = d.activeTouch;\\n    if (touch && !eventInWidget(d, e) && touch.left != null &&\\n        !touch.moved && new Date - touch.start \\u003C 300) {\\n      var pos = cm.coordsChar(d.activeTouch, \\\"page\\\"), range;\\n      if (!touch.prev || farAway(touch, touch.prev)) \\u002F\\u002F Single tap\\n        { range = new Range(pos, pos); }\\n      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) \\u002F\\u002F Double tap\\n        { range = cm.findWordAt(pos); }\\n      else \\u002F\\u002F Triple tap\\n        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\\n      cm.setSelection(range.anchor, range.head);\\n      cm.focus();\\n      e_preventDefault(e);\\n    }\\n    finishTouch();\\n  });\\n  on(d.scroller, \\\"touchcancel\\\", finishTouch);\\n\\n  \\u002F\\u002F Sync scrolling between fake scrollbars and real scrollable\\n  \\u002F\\u002F area, ensure viewport is updated when scrolling.\\n  on(d.scroller, \\\"scroll\\\", function () {\\n    if (d.scroller.clientHeight) {\\n      updateScrollTop(cm, d.scroller.scrollTop);\\n      setScrollLeft(cm, d.scroller.scrollLeft, true);\\n      signal(cm, \\\"scroll\\\", cm);\\n    }\\n  });\\n\\n  \\u002F\\u002F Listen to wheel events in order to try and update the viewport on time.\\n  on(d.scroller, \\\"mousewheel\\\", function (e) { return onScrollWheel(cm, e); });\\n  on(d.scroller, \\\"DOMMouseScroll\\\", function (e) { return onScrollWheel(cm, e); });\\n\\n  \\u002F\\u002F Prevent wrapper from ever scrolling\\n  on(d.wrapper, \\\"scroll\\\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\\n\\n  d.dragFunctions = {\\n    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\\n    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\\n    start: function (e) { return onDragStart(cm, e); },\\n    drop: operation(cm, onDrop),\\n    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\\n  };\\n\\n  var inp = d.input.getField();\\n  on(inp, \\\"keyup\\\", function (e) { return onKeyUp.call(cm, e); });\\n  on(inp, \\\"keydown\\\", operation(cm, onKeyDown));\\n  on(inp, \\\"keypress\\\", operation(cm, onKeyPress));\\n  on(inp, \\\"focus\\\", function (e) { return onFocus(cm, e); });\\n  on(inp, \\\"blur\\\", function (e) { return onBlur(cm, e); });\\n}\\n\\nvar initHooks = [];\\nCodeMirror$1.defineInitHook = function (f) { return initHooks.push(f); };\\n\\n\\u002F\\u002F Indent the given line. The how parameter can be \\\"smart\\\",\\n\\u002F\\u002F \\\"add\\\"\\u002Fnull, \\\"subtract\\\", or \\\"prev\\\". When aggressive is false\\n\\u002F\\u002F (typically set to true for forced single-line indents), empty\\n\\u002F\\u002F lines are not indented, and places where the mode returns Pass\\n\\u002F\\u002F are left alone.\\nfunction indentLine(cm, n, how, aggressive) {\\n  var doc = cm.doc, state;\\n  if (how == null) { how = \\\"add\\\"; }\\n  if (how == \\\"smart\\\") {\\n    \\u002F\\u002F Fall back to \\\"prev\\\" when the mode doesn't have an indentation\\n    \\u002F\\u002F method.\\n    if (!doc.mode.indent) { how = \\\"prev\\\"; }\\n    else { state = getContextBefore(cm, n).state; }\\n  }\\n\\n  var tabSize = cm.options.tabSize;\\n  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\\n  if (line.stateAfter) { line.stateAfter = null; }\\n  var curSpaceString = line.text.match(\\u002F^\\\\s*\\u002F)[0], indentation;\\n  if (!aggressive && !\\u002F\\\\S\\u002F.test(line.text)) {\\n    indentation = 0;\\n    how = \\\"not\\\";\\n  } else if (how == \\\"smart\\\") {\\n    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\\n    if (indentation == Pass || indentation \\u003E 150) {\\n      if (!aggressive) { return }\\n      how = \\\"prev\\\";\\n    }\\n  }\\n  if (how == \\\"prev\\\") {\\n    if (n \\u003E doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\\n    else { indentation = 0; }\\n  } else if (how == \\\"add\\\") {\\n    indentation = curSpace + cm.options.indentUnit;\\n  } else if (how == \\\"subtract\\\") {\\n    indentation = curSpace - cm.options.indentUnit;\\n  } else if (typeof how == \\\"number\\\") {\\n    indentation = curSpace + how;\\n  }\\n  indentation = Math.max(0, indentation);\\n\\n  var indentString = \\\"\\\", pos = 0;\\n  if (cm.options.indentWithTabs)\\n    { for (var i = Math.floor(indentation \\u002F tabSize); i; --i) {pos += tabSize; indentString += \\\"\\\\t\\\";} }\\n  if (pos \\u003C indentation) { indentString += spaceStr(indentation - pos); }\\n\\n  if (indentString != curSpaceString) {\\n    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \\\"+input\\\");\\n    line.stateAfter = null;\\n    return true\\n  } else {\\n    \\u002F\\u002F Ensure that, if the cursor was in the whitespace at the start\\n    \\u002F\\u002F of the line, it is moved to the end of that space.\\n    for (var i$1 = 0; i$1 \\u003C doc.sel.ranges.length; i$1++) {\\n      var range = doc.sel.ranges[i$1];\\n      if (range.head.line == n && range.head.ch \\u003C curSpaceString.length) {\\n        var pos$1 = Pos(n, curSpaceString.length);\\n        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\\n        break\\n      }\\n    }\\n  }\\n}\\n\\n\\u002F\\u002F This will be set to a {lineWise: bool, text: [string]} object, so\\n\\u002F\\u002F that, when pasting, we know what kind of selections the copied\\n\\u002F\\u002F text was made out of.\\nvar lastCopied = null;\\n\\nfunction setLastCopied(newLastCopied) {\\n  lastCopied = newLastCopied;\\n}\\n\\nfunction applyTextInput(cm, inserted, deleted, sel, origin) {\\n  var doc = cm.doc;\\n  cm.display.shift = false;\\n  if (!sel) { sel = doc.sel; }\\n\\n  var paste = cm.state.pasteIncoming || origin == \\\"paste\\\";\\n  var textLines = splitLinesAuto(inserted), multiPaste = null;\\n  \\u002F\\u002F When pasting N lines into N selections, insert one line per selection\\n  if (paste && sel.ranges.length \\u003E 1) {\\n    if (lastCopied && lastCopied.text.join(\\\"\\\\n\\\") == inserted) {\\n      if (sel.ranges.length % lastCopied.text.length == 0) {\\n        multiPaste = [];\\n        for (var i = 0; i \\u003C lastCopied.text.length; i++)\\n          { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\\n      }\\n    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\\n      multiPaste = map(textLines, function (l) { return [l]; });\\n    }\\n  }\\n\\n  var updateInput;\\n  \\u002F\\u002F Normal behavior is to insert the new text into every selection\\n  for (var i$1 = sel.ranges.length - 1; i$1 \\u003E= 0; i$1--) {\\n    var range$$1 = sel.ranges[i$1];\\n    var from = range$$1.from(), to = range$$1.to();\\n    if (range$$1.empty()) {\\n      if (deleted && deleted \\u003E 0) \\u002F\\u002F Handle deletion\\n        { from = Pos(from.line, from.ch - deleted); }\\n      else if (cm.state.overwrite && !paste) \\u002F\\u002F Handle overwrite\\n        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\\n      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\\\"\\\\n\\\") == inserted)\\n        { from = to = Pos(from.line, 0); }\\n    }\\n    updateInput = cm.curOp.updateInput;\\n    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\\n                       origin: origin || (paste ? \\\"paste\\\" : cm.state.cutIncoming ? \\\"cut\\\" : \\\"+input\\\")};\\n    makeChange(cm.doc, changeEvent);\\n    signalLater(cm, \\\"inputRead\\\", cm, changeEvent);\\n  }\\n  if (inserted && !paste)\\n    { triggerElectric(cm, inserted); }\\n\\n  ensureCursorVisible(cm);\\n  cm.curOp.updateInput = updateInput;\\n  cm.curOp.typing = true;\\n  cm.state.pasteIncoming = cm.state.cutIncoming = false;\\n}\\n\\nfunction handlePaste(e, cm) {\\n  var pasted = e.clipboardData && e.clipboardData.getData(\\\"Text\\\");\\n  if (pasted) {\\n    e.preventDefault();\\n    if (!cm.isReadOnly() && !cm.options.disableInput)\\n      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \\\"paste\\\"); }); }\\n    return true\\n  }\\n}\\n\\nfunction triggerElectric(cm, inserted) {\\n  \\u002F\\u002F When an 'electric' character is inserted, immediately trigger a reindent\\n  if (!cm.options.electricChars || !cm.options.smartIndent) { return }\\n  var sel = cm.doc.sel;\\n\\n  for (var i = sel.ranges.length - 1; i \\u003E= 0; i--) {\\n    var range$$1 = sel.ranges[i];\\n    if (range$$1.head.ch \\u003E 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\\n    var mode = cm.getModeAt(range$$1.head);\\n    var indented = false;\\n    if (mode.electricChars) {\\n      for (var j = 0; j \\u003C mode.electricChars.length; j++)\\n        { if (inserted.indexOf(mode.electricChars.charAt(j)) \\u003E -1) {\\n          indented = indentLine(cm, range$$1.head.line, \\\"smart\\\");\\n          break\\n        } }\\n    } else if (mode.electricInput) {\\n      if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\\n        { indented = indentLine(cm, range$$1.head.line, \\\"smart\\\"); }\\n    }\\n    if (indented) { signalLater(cm, \\\"electricInput\\\", cm, range$$1.head.line); }\\n  }\\n}\\n\\nfunction copyableRanges(cm) {\\n  var text = [], ranges = [];\\n  for (var i = 0; i \\u003C cm.doc.sel.ranges.length; i++) {\\n    var line = cm.doc.sel.ranges[i].head.line;\\n    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\\n    ranges.push(lineRange);\\n    text.push(cm.getRange(lineRange.anchor, lineRange.head));\\n  }\\n  return {text: text, ranges: ranges}\\n}\\n\\nfunction disableBrowserMagic(field, spellcheck) {\\n  field.setAttribute(\\\"autocorrect\\\", \\\"off\\\");\\n  field.setAttribute(\\\"autocapitalize\\\", \\\"off\\\");\\n  field.setAttribute(\\\"spellcheck\\\", !!spellcheck);\\n}\\n\\nfunction hiddenTextarea() {\\n  var te = elt(\\\"textarea\\\", null, null, \\\"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\\\");\\n  var div = elt(\\\"div\\\", [te], null, \\\"overflow: hidden; position: relative; width: 3px; height: 0px;\\\");\\n  \\u002F\\u002F The textarea is kept positioned near the cursor to prevent the\\n  \\u002F\\u002F fact that it'll be scrolled into view on input from scrolling\\n  \\u002F\\u002F our fake cursor out of view. On webkit, when wrap=off, paste is\\n  \\u002F\\u002F very slow. So make the area wide instead.\\n  if (webkit) { te.style.width = \\\"1000px\\\"; }\\n  else { te.setAttribute(\\\"wrap\\\", \\\"off\\\"); }\\n  \\u002F\\u002F If border: 0; -- iOS fails to open keyboard (issue #1287)\\n  if (ios) { te.style.border = \\\"1px solid black\\\"; }\\n  disableBrowserMagic(te);\\n  return div\\n}\\n\\n\\u002F\\u002F The publicly visible API. Note that methodOp(f) means\\n\\u002F\\u002F 'wrap f in an operation, performed on its `this` parameter'.\\n\\n\\u002F\\u002F This is not the complete set of editor methods. Most of the\\n\\u002F\\u002F methods defined on the Doc type are also injected into\\n\\u002F\\u002F CodeMirror.prototype, for backwards compatibility and\\n\\u002F\\u002F convenience.\\n\\nvar addEditorMethods = function(CodeMirror) {\\n  var optionHandlers = CodeMirror.optionHandlers;\\n\\n  var helpers = CodeMirror.helpers = {};\\n\\n  CodeMirror.prototype = {\\n    constructor: CodeMirror,\\n    focus: function(){window.focus(); this.display.input.focus();},\\n\\n    setOption: function(option, value) {\\n      var options = this.options, old = options[option];\\n      if (options[option] == value && option != \\\"mode\\\") { return }\\n      options[option] = value;\\n      if (optionHandlers.hasOwnProperty(option))\\n        { operation(this, optionHandlers[option])(this, value, old); }\\n      signal(this, \\\"optionChange\\\", this, option);\\n    },\\n\\n    getOption: function(option) {return this.options[option]},\\n    getDoc: function() {return this.doc},\\n\\n    addKeyMap: function(map$$1, bottom) {\\n      this.state.keyMaps[bottom ? \\\"push\\\" : \\\"unshift\\\"](getKeyMap(map$$1));\\n    },\\n    removeKeyMap: function(map$$1) {\\n      var maps = this.state.keyMaps;\\n      for (var i = 0; i \\u003C maps.length; ++i)\\n        { if (maps[i] == map$$1 || maps[i].name == map$$1) {\\n          maps.splice(i, 1);\\n          return true\\n        } }\\n    },\\n\\n    addOverlay: methodOp(function(spec, options) {\\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\\n      if (mode.startState) { throw new Error(\\\"Overlays may not be stateful.\\\") }\\n      insertSorted(this.state.overlays,\\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\\n                    priority: (options && options.priority) || 0},\\n                   function (overlay) { return overlay.priority; });\\n      this.state.modeGen++;\\n      regChange(this);\\n    }),\\n    removeOverlay: methodOp(function(spec) {\\n      var this$1 = this;\\n\\n      var overlays = this.state.overlays;\\n      for (var i = 0; i \\u003C overlays.length; ++i) {\\n        var cur = overlays[i].modeSpec;\\n        if (cur == spec || typeof spec == \\\"string\\\" && cur.name == spec) {\\n          overlays.splice(i, 1);\\n          this$1.state.modeGen++;\\n          regChange(this$1);\\n          return\\n        }\\n      }\\n    }),\\n\\n    indentLine: methodOp(function(n, dir, aggressive) {\\n      if (typeof dir != \\\"string\\\" && typeof dir != \\\"number\\\") {\\n        if (dir == null) { dir = this.options.smartIndent ? \\\"smart\\\" : \\\"prev\\\"; }\\n        else { dir = dir ? \\\"add\\\" : \\\"subtract\\\"; }\\n      }\\n      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\\n    }),\\n    indentSelection: methodOp(function(how) {\\n      var this$1 = this;\\n\\n      var ranges = this.doc.sel.ranges, end = -1;\\n      for (var i = 0; i \\u003C ranges.length; i++) {\\n        var range$$1 = ranges[i];\\n        if (!range$$1.empty()) {\\n          var from = range$$1.from(), to = range$$1.to();\\n          var start = Math.max(end, from.line);\\n          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\\n          for (var j = start; j \\u003C end; ++j)\\n            { indentLine(this$1, j, how); }\\n          var newRanges = this$1.doc.sel.ranges;\\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch \\u003E 0)\\n            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\\n        } else if (range$$1.head.line \\u003E end) {\\n          indentLine(this$1, range$$1.head.line, how, true);\\n          end = range$$1.head.line;\\n          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\\n        }\\n      }\\n    }),\\n\\n    \\u002F\\u002F Fetch the parser token for a given character. Useful for hacks\\n    \\u002F\\u002F that want to inspect the mode state (say, for completion).\\n    getTokenAt: function(pos, precise) {\\n      return takeToken(this, pos, precise)\\n    },\\n\\n    getLineTokens: function(line, precise) {\\n      return takeToken(this, Pos(line), precise, true)\\n    },\\n\\n    getTokenTypeAt: function(pos) {\\n      pos = clipPos(this.doc, pos);\\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\\n      var before = 0, after = (styles.length - 1) \\u002F 2, ch = pos.ch;\\n      var type;\\n      if (ch == 0) { type = styles[2]; }\\n      else { for (;;) {\\n        var mid = (before + after) \\u003E\\u003E 1;\\n        if ((mid ? styles[mid * 2 - 1] : 0) \\u003E= ch) { after = mid; }\\n        else if (styles[mid * 2 + 1] \\u003C ch) { before = mid + 1; }\\n        else { type = styles[mid * 2 + 2]; break }\\n      } }\\n      var cut = type ? type.indexOf(\\\"overlay \\\") : -1;\\n      return cut \\u003C 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\\n    },\\n\\n    getModeAt: function(pos) {\\n      var mode = this.doc.mode;\\n      if (!mode.innerMode) { return mode }\\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\\n    },\\n\\n    getHelper: function(pos, type) {\\n      return this.getHelpers(pos, type)[0]\\n    },\\n\\n    getHelpers: function(pos, type) {\\n      var this$1 = this;\\n\\n      var found = [];\\n      if (!helpers.hasOwnProperty(type)) { return found }\\n      var help = helpers[type], mode = this.getModeAt(pos);\\n      if (typeof mode[type] == \\\"string\\\") {\\n        if (help[mode[type]]) { found.push(help[mode[type]]); }\\n      } else if (mode[type]) {\\n        for (var i = 0; i \\u003C mode[type].length; i++) {\\n          var val = help[mode[type][i]];\\n          if (val) { found.push(val); }\\n        }\\n      } else if (mode.helperType && help[mode.helperType]) {\\n        found.push(help[mode.helperType]);\\n      } else if (help[mode.name]) {\\n        found.push(help[mode.name]);\\n      }\\n      for (var i$1 = 0; i$1 \\u003C help._global.length; i$1++) {\\n        var cur = help._global[i$1];\\n        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\\n          { found.push(cur.val); }\\n      }\\n      return found\\n    },\\n\\n    getStateAfter: function(line, precise) {\\n      var doc = this.doc;\\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\\n      return getContextBefore(this, line + 1, precise).state\\n    },\\n\\n    cursorCoords: function(start, mode) {\\n      var pos, range$$1 = this.doc.sel.primary();\\n      if (start == null) { pos = range$$1.head; }\\n      else if (typeof start == \\\"object\\\") { pos = clipPos(this.doc, start); }\\n      else { pos = start ? range$$1.from() : range$$1.to(); }\\n      return cursorCoords(this, pos, mode || \\\"page\\\")\\n    },\\n\\n    charCoords: function(pos, mode) {\\n      return charCoords(this, clipPos(this.doc, pos), mode || \\\"page\\\")\\n    },\\n\\n    coordsChar: function(coords, mode) {\\n      coords = fromCoordSystem(this, coords, mode || \\\"page\\\");\\n      return coordsChar(this, coords.left, coords.top)\\n    },\\n\\n    lineAtHeight: function(height, mode) {\\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \\\"page\\\").top;\\n      return lineAtHeight(this.doc, height + this.display.viewOffset)\\n    },\\n    heightAtLine: function(line, mode, includeWidgets) {\\n      var end = false, lineObj;\\n      if (typeof line == \\\"number\\\") {\\n        var last = this.doc.first + this.doc.size - 1;\\n        if (line \\u003C this.doc.first) { line = this.doc.first; }\\n        else if (line \\u003E last) { line = last; end = true; }\\n        lineObj = getLine(this.doc, line);\\n      } else {\\n        lineObj = line;\\n      }\\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \\\"page\\\", includeWidgets || end).top +\\n        (end ? this.doc.height - heightAtLine(lineObj) : 0)\\n    },\\n\\n    defaultTextHeight: function() { return textHeight(this.display) },\\n    defaultCharWidth: function() { return charWidth(this.display) },\\n\\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\\n\\n    addWidget: function(pos, node, scroll, vert, horiz) {\\n      var display = this.display;\\n      pos = cursorCoords(this, clipPos(this.doc, pos));\\n      var top = pos.bottom, left = pos.left;\\n      node.style.position = \\\"absolute\\\";\\n      node.setAttribute(\\\"cm-ignore-events\\\", \\\"true\\\");\\n      this.display.input.setUneditable(node);\\n      display.sizer.appendChild(node);\\n      if (vert == \\\"over\\\") {\\n        top = pos.top;\\n      } else if (vert == \\\"above\\\" || vert == \\\"near\\\") {\\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\\n        \\u002F\\u002F Default to positioning above (if specified and possible); otherwise default to positioning below\\n        if ((vert == 'above' || pos.bottom + node.offsetHeight \\u003E vspace) && pos.top \\u003E node.offsetHeight)\\n          { top = pos.top - node.offsetHeight; }\\n        else if (pos.bottom + node.offsetHeight \\u003C= vspace)\\n          { top = pos.bottom; }\\n        if (left + node.offsetWidth \\u003E hspace)\\n          { left = hspace - node.offsetWidth; }\\n      }\\n      node.style.top = top + \\\"px\\\";\\n      node.style.left = node.style.right = \\\"\\\";\\n      if (horiz == \\\"right\\\") {\\n        left = display.sizer.clientWidth - node.offsetWidth;\\n        node.style.right = \\\"0px\\\";\\n      } else {\\n        if (horiz == \\\"left\\\") { left = 0; }\\n        else if (horiz == \\\"middle\\\") { left = (display.sizer.clientWidth - node.offsetWidth) \\u002F 2; }\\n        node.style.left = left + \\\"px\\\";\\n      }\\n      if (scroll)\\n        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\\n    },\\n\\n    triggerOnKeyDown: methodOp(onKeyDown),\\n    triggerOnKeyPress: methodOp(onKeyPress),\\n    triggerOnKeyUp: onKeyUp,\\n    triggerOnMouseDown: methodOp(onMouseDown),\\n\\n    execCommand: function(cmd) {\\n      if (commands.hasOwnProperty(cmd))\\n        { return commands[cmd].call(null, this) }\\n    },\\n\\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\\n\\n    findPosH: function(from, amount, unit, visually) {\\n      var this$1 = this;\\n\\n      var dir = 1;\\n      if (amount \\u003C 0) { dir = -1; amount = -amount; }\\n      var cur = clipPos(this.doc, from);\\n      for (var i = 0; i \\u003C amount; ++i) {\\n        cur = findPosH(this$1.doc, cur, dir, unit, visually);\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveH: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      this.extendSelectionsBy(function (range$$1) {\\n        if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\\n          { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\\n        else\\n          { return dir \\u003C 0 ? range$$1.from() : range$$1.to() }\\n      }, sel_move);\\n    }),\\n\\n    deleteH: methodOp(function(dir, unit) {\\n      var sel = this.doc.sel, doc = this.doc;\\n      if (sel.somethingSelected())\\n        { doc.replaceSelection(\\\"\\\", null, \\\"+delete\\\"); }\\n      else\\n        { deleteNearSelection(this, function (range$$1) {\\n          var other = findPosH(doc, range$$1.head, dir, unit, false);\\n          return dir \\u003C 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\\n        }); }\\n    }),\\n\\n    findPosV: function(from, amount, unit, goalColumn) {\\n      var this$1 = this;\\n\\n      var dir = 1, x = goalColumn;\\n      if (amount \\u003C 0) { dir = -1; amount = -amount; }\\n      var cur = clipPos(this.doc, from);\\n      for (var i = 0; i \\u003C amount; ++i) {\\n        var coords = cursorCoords(this$1, cur, \\\"div\\\");\\n        if (x == null) { x = coords.left; }\\n        else { coords.left = x; }\\n        cur = findPosV(this$1, coords, dir, unit);\\n        if (cur.hitSide) { break }\\n      }\\n      return cur\\n    },\\n\\n    moveV: methodOp(function(dir, unit) {\\n      var this$1 = this;\\n\\n      var doc = this.doc, goals = [];\\n      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\\n      doc.extendSelectionsBy(function (range$$1) {\\n        if (collapse)\\n          { return dir \\u003C 0 ? range$$1.from() : range$$1.to() }\\n        var headPos = cursorCoords(this$1, range$$1.head, \\\"div\\\");\\n        if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\\n        goals.push(headPos.left);\\n        var pos = findPosV(this$1, headPos, dir, unit);\\n        if (unit == \\\"page\\\" && range$$1 == doc.sel.primary())\\n          { addToScrollTop(this$1, charCoords(this$1, pos, \\\"div\\\").top - headPos.top); }\\n        return pos\\n      }, sel_move);\\n      if (goals.length) { for (var i = 0; i \\u003C doc.sel.ranges.length; i++)\\n        { doc.sel.ranges[i].goalColumn = goals[i]; } }\\n    }),\\n\\n    \\u002F\\u002F Find the word at the given position (as returned by coordsChar).\\n    findWordAt: function(pos) {\\n      var doc = this.doc, line = getLine(doc, pos.line).text;\\n      var start = pos.ch, end = pos.ch;\\n      if (line) {\\n        var helper = this.getHelper(pos, \\\"wordChars\\\");\\n        if ((pos.sticky == \\\"before\\\" || end == line.length) && start) { --start; } else { ++end; }\\n        var startChar = line.charAt(start);\\n        var check = isWordChar(startChar, helper)\\n          ? function (ch) { return isWordChar(ch, helper); }\\n          : \\u002F\\\\s\\u002F.test(startChar) ? function (ch) { return \\u002F\\\\s\\u002F.test(ch); }\\n          : function (ch) { return (!\\u002F\\\\s\\u002F.test(ch) && !isWordChar(ch)); };\\n        while (start \\u003E 0 && check(line.charAt(start - 1))) { --start; }\\n        while (end \\u003C line.length && check(line.charAt(end))) { ++end; }\\n      }\\n      return new Range(Pos(pos.line, start), Pos(pos.line, end))\\n    },\\n\\n    toggleOverwrite: function(value) {\\n      if (value != null && value == this.state.overwrite) { return }\\n      if (this.state.overwrite = !this.state.overwrite)\\n        { addClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\"); }\\n      else\\n        { rmClass(this.display.cursorDiv, \\\"CodeMirror-overwrite\\\"); }\\n\\n      signal(this, \\\"overwriteToggle\\\", this, this.state.overwrite);\\n    },\\n    hasFocus: function() { return this.display.input.getField() == activeElt() },\\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\\n\\n    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\\n    getScrollInfo: function() {\\n      var scroller = this.display.scroller;\\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\\n    },\\n\\n    scrollIntoView: methodOp(function(range$$1, margin) {\\n      if (range$$1 == null) {\\n        range$$1 = {from: this.doc.sel.primary().head, to: null};\\n        if (margin == null) { margin = this.options.cursorScrollMargin; }\\n      } else if (typeof range$$1 == \\\"number\\\") {\\n        range$$1 = {from: Pos(range$$1, 0), to: null};\\n      } else if (range$$1.from == null) {\\n        range$$1 = {from: range$$1, to: null};\\n      }\\n      if (!range$$1.to) { range$$1.to = range$$1.from; }\\n      range$$1.margin = margin || 0;\\n\\n      if (range$$1.from.line != null) {\\n        scrollToRange(this, range$$1);\\n      } else {\\n        scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\\n      }\\n    }),\\n\\n    setSize: methodOp(function(width, height) {\\n      var this$1 = this;\\n\\n      var interpret = function (val) { return typeof val == \\\"number\\\" || \\u002F^\\\\d+$\\u002F.test(String(val)) ? val + \\\"px\\\" : val; };\\n      if (width != null) { this.display.wrapper.style.width = interpret(width); }\\n      if (height != null) { this.display.wrapper.style.height = interpret(height); }\\n      if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\\n      var lineNo$$1 = this.display.viewFrom;\\n      this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\\n        if (line.widgets) { for (var i = 0; i \\u003C line.widgets.length; i++)\\n          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \\\"widget\\\"); break } } }\\n        ++lineNo$$1;\\n      });\\n      this.curOp.forceUpdate = true;\\n      signal(this, \\\"refresh\\\", this);\\n    }),\\n\\n    operation: function(f){return runInOp(this, f)},\\n    startOperation: function(){return startOperation(this)},\\n    endOperation: function(){return endOperation(this)},\\n\\n    refresh: methodOp(function() {\\n      var oldHeight = this.display.cachedTextHeight;\\n      regChange(this);\\n      this.curOp.forceUpdate = true;\\n      clearCaches(this);\\n      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\\n      updateGutterSpace(this);\\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) \\u003E .5)\\n        { estimateLineHeights(this); }\\n      signal(this, \\\"refresh\\\", this);\\n    }),\\n\\n    swapDoc: methodOp(function(doc) {\\n      var old = this.doc;\\n      old.cm = null;\\n      attachDoc(this, doc);\\n      clearCaches(this);\\n      this.display.input.reset();\\n      scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\\n      this.curOp.forceScroll = true;\\n      signalLater(this, \\\"swapDoc\\\", this, old);\\n      return old\\n    }),\\n\\n    getInputField: function(){return this.display.input.getField()},\\n    getWrapperElement: function(){return this.display.wrapper},\\n    getScrollerElement: function(){return this.display.scroller},\\n    getGutterElement: function(){return this.display.gutters}\\n  };\\n  eventMixin(CodeMirror);\\n\\n  CodeMirror.registerHelper = function(type, name, value) {\\n    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\\n    helpers[type][name] = value;\\n  };\\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\\n    CodeMirror.registerHelper(type, name, value);\\n    helpers[type]._global.push({pred: predicate, val: value});\\n  };\\n};\\n\\n\\u002F\\u002F Used for horizontal relative motion. Dir is -1 or 1 (left or\\n\\u002F\\u002F right), unit can be \\\"char\\\", \\\"column\\\" (like char, but doesn't\\n\\u002F\\u002F cross line boundaries), \\\"word\\\" (across next word), or \\\"group\\\" (to\\n\\u002F\\u002F the start of next group of word or non-word-non-whitespace\\n\\u002F\\u002F chars). The visually param controls whether, in right-to-left\\n\\u002F\\u002F text, direction 1 means to move towards the next index in the\\n\\u002F\\u002F string, or towards the character to the right of the current\\n\\u002F\\u002F position. The resulting position will have a hitSide=true\\n\\u002F\\u002F property if it reached the end of the document.\\nfunction findPosH(doc, pos, dir, unit, visually) {\\n  var oldPos = pos;\\n  var origDir = dir;\\n  var lineObj = getLine(doc, pos.line);\\n  function findNextLine() {\\n    var l = pos.line + dir;\\n    if (l \\u003C doc.first || l \\u003E= doc.first + doc.size) { return false }\\n    pos = new Pos(l, pos.ch, pos.sticky);\\n    return lineObj = getLine(doc, l)\\n  }\\n  function moveOnce(boundToLine) {\\n    var next;\\n    if (visually) {\\n      next = moveVisually(doc.cm, lineObj, pos, dir);\\n    } else {\\n      next = moveLogically(lineObj, pos, dir);\\n    }\\n    if (next == null) {\\n      if (!boundToLine && findNextLine())\\n        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\\n      else\\n        { return false }\\n    } else {\\n      pos = next;\\n    }\\n    return true\\n  }\\n\\n  if (unit == \\\"char\\\") {\\n    moveOnce();\\n  } else if (unit == \\\"column\\\") {\\n    moveOnce(true);\\n  } else if (unit == \\\"word\\\" || unit == \\\"group\\\") {\\n    var sawType = null, group = unit == \\\"group\\\";\\n    var helper = doc.cm && doc.cm.getHelper(pos, \\\"wordChars\\\");\\n    for (var first = true;; first = false) {\\n      if (dir \\u003C 0 && !moveOnce(!first)) { break }\\n      var cur = lineObj.text.charAt(pos.ch) || \\\"\\\\n\\\";\\n      var type = isWordChar(cur, helper) ? \\\"w\\\"\\n        : group && cur == \\\"\\\\n\\\" ? \\\"n\\\"\\n        : !group || \\u002F\\\\s\\u002F.test(cur) ? null\\n        : \\\"p\\\";\\n      if (group && !first && !type) { type = \\\"s\\\"; }\\n      if (sawType && sawType != type) {\\n        if (dir \\u003C 0) {dir = 1; moveOnce(); pos.sticky = \\\"after\\\";}\\n        break\\n      }\\n\\n      if (type) { sawType = type; }\\n      if (dir \\u003E 0 && !moveOnce(!first)) { break }\\n    }\\n  }\\n  var result = skipAtomic(doc, pos, oldPos, origDir, true);\\n  if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\\n  return result\\n}\\n\\n\\u002F\\u002F For relative vertical movement. Dir may be -1 or 1. Unit can be\\n\\u002F\\u002F \\\"page\\\" or \\\"line\\\". The resulting position will have a hitSide=true\\n\\u002F\\u002F property if it reached the end of the document.\\nfunction findPosV(cm, pos, dir, unit) {\\n  var doc = cm.doc, x = pos.left, y;\\n  if (unit == \\\"page\\\") {\\n    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\\n    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\\n    y = (dir \\u003E 0 ? pos.bottom : pos.top) + dir * moveAmount;\\n\\n  } else if (unit == \\\"line\\\") {\\n    y = dir \\u003E 0 ? pos.bottom + 3 : pos.top - 3;\\n  }\\n  var target;\\n  for (;;) {\\n    target = coordsChar(cm, x, y);\\n    if (!target.outside) { break }\\n    if (dir \\u003C 0 ? y \\u003C= 0 : y \\u003E= doc.height) { target.hitSide = true; break }\\n    y += dir * 5;\\n  }\\n  return target\\n}\\n\\n\\u002F\\u002F CONTENTEDITABLE INPUT STYLE\\n\\nvar ContentEditableInput = function(cm) {\\n  this.cm = cm;\\n  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\\n  this.polling = new Delayed();\\n  this.composing = null;\\n  this.gracePeriod = false;\\n  this.readDOMTimeout = null;\\n};\\n\\nContentEditableInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = input.cm;\\n  var div = input.div = display.lineDiv;\\n  disableBrowserMagic(div, cm.options.spellcheck);\\n\\n  on(div, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n    \\u002F\\u002F IE doesn't fire input events, so we schedule a read for the pasted content in this way\\n    if (ie_version \\u003C= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\\n  });\\n\\n  on(div, \\\"compositionstart\\\", function (e) {\\n    this$1.composing = {data: e.data, done: false};\\n  });\\n  on(div, \\\"compositionupdate\\\", function (e) {\\n    if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\\n  });\\n  on(div, \\\"compositionend\\\", function (e) {\\n    if (this$1.composing) {\\n      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\\n      this$1.composing.done = true;\\n    }\\n  });\\n\\n  on(div, \\\"touchstart\\\", function () { return input.forceCompositionEnd(); });\\n\\n  on(div, \\\"input\\\", function () {\\n    if (!this$1.composing) { this$1.readFromDOMSoon(); }\\n  });\\n\\n  function onCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()});\\n      if (e.type == \\\"cut\\\") { cm.replaceSelection(\\\"\\\", null, \\\"cut\\\"); }\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm);\\n      setLastCopied({lineWise: true, text: ranges.text});\\n      if (e.type == \\\"cut\\\") {\\n        cm.operation(function () {\\n          cm.setSelections(ranges.ranges, 0, sel_dontScroll);\\n          cm.replaceSelection(\\\"\\\", null, \\\"cut\\\");\\n        });\\n      }\\n    }\\n    if (e.clipboardData) {\\n      e.clipboardData.clearData();\\n      var content = lastCopied.text.join(\\\"\\\\n\\\");\\n      \\u002F\\u002F iOS exposes the clipboard API, but seems to discard content inserted into it\\n      e.clipboardData.setData(\\\"Text\\\", content);\\n      if (e.clipboardData.getData(\\\"Text\\\") == content) {\\n        e.preventDefault();\\n        return\\n      }\\n    }\\n    \\u002F\\u002F Old-fashioned briefly-focus-a-textarea hack\\n    var kludge = hiddenTextarea(), te = kludge.firstChild;\\n    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\\n    te.value = lastCopied.text.join(\\\"\\\\n\\\");\\n    var hadFocus = document.activeElement;\\n    selectInput(te);\\n    setTimeout(function () {\\n      cm.display.lineSpace.removeChild(kludge);\\n      hadFocus.focus();\\n      if (hadFocus == div) { input.showPrimarySelection(); }\\n    }, 50);\\n  }\\n  on(div, \\\"copy\\\", onCopyCut);\\n  on(div, \\\"cut\\\", onCopyCut);\\n};\\n\\nContentEditableInput.prototype.prepareSelection = function () {\\n  var result = prepareSelection(this.cm, false);\\n  result.focus = this.cm.state.focused;\\n  return result\\n};\\n\\nContentEditableInput.prototype.showSelection = function (info, takeFocus) {\\n  if (!info || !this.cm.display.view.length) { return }\\n  if (info.focus || takeFocus) { this.showPrimarySelection(); }\\n  this.showMultipleSelections(info);\\n};\\n\\nContentEditableInput.prototype.showPrimarySelection = function () {\\n  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\\n  var from = prim.from(), to = prim.to();\\n\\n  if (cm.display.viewTo == cm.display.viewFrom || from.line \\u003E= cm.display.viewTo || to.line \\u003C cm.display.viewFrom) {\\n    sel.removeAllRanges();\\n    return\\n  }\\n\\n  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\\n  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\\n  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\\n      cmp(minPos(curAnchor, curFocus), from) == 0 &&\\n      cmp(maxPos(curAnchor, curFocus), to) == 0)\\n    { return }\\n\\n  var view = cm.display.view;\\n  var start = (from.line \\u003E= cm.display.viewFrom && posToDOM(cm, from)) ||\\n      {node: view[0].measure.map[2], offset: 0};\\n  var end = to.line \\u003C cm.display.viewTo && posToDOM(cm, to);\\n  if (!end) {\\n    var measure = view[view.length - 1].measure;\\n    var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\\n    end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\\n  }\\n\\n  if (!start || !end) {\\n    sel.removeAllRanges();\\n    return\\n  }\\n\\n  var old = sel.rangeCount && sel.getRangeAt(0), rng;\\n  try { rng = range(start.node, start.offset, end.offset, end.node); }\\n  catch(e) {} \\u002F\\u002F Our model of the DOM might be outdated, in which case the range we try to set can be impossible\\n  if (rng) {\\n    if (!gecko && cm.state.focused) {\\n      sel.collapse(start.node, start.offset);\\n      if (!rng.collapsed) {\\n        sel.removeAllRanges();\\n        sel.addRange(rng);\\n      }\\n    } else {\\n      sel.removeAllRanges();\\n      sel.addRange(rng);\\n    }\\n    if (old && sel.anchorNode == null) { sel.addRange(old); }\\n    else if (gecko) { this.startGracePeriod(); }\\n  }\\n  this.rememberSelection();\\n};\\n\\nContentEditableInput.prototype.startGracePeriod = function () {\\n    var this$1 = this;\\n\\n  clearTimeout(this.gracePeriod);\\n  this.gracePeriod = setTimeout(function () {\\n    this$1.gracePeriod = false;\\n    if (this$1.selectionChanged())\\n      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\\n  }, 20);\\n};\\n\\nContentEditableInput.prototype.showMultipleSelections = function (info) {\\n  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\\n  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\\n};\\n\\nContentEditableInput.prototype.rememberSelection = function () {\\n  var sel = window.getSelection();\\n  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\\n  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\\n};\\n\\nContentEditableInput.prototype.selectionInEditor = function () {\\n  var sel = window.getSelection();\\n  if (!sel.rangeCount) { return false }\\n  var node = sel.getRangeAt(0).commonAncestorContainer;\\n  return contains(this.div, node)\\n};\\n\\nContentEditableInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\") {\\n    if (!this.selectionInEditor())\\n      { this.showSelection(this.prepareSelection(), true); }\\n    this.div.focus();\\n  }\\n};\\nContentEditableInput.prototype.blur = function () { this.div.blur(); };\\nContentEditableInput.prototype.getField = function () { return this.div };\\n\\nContentEditableInput.prototype.supportsTouch = function () { return true };\\n\\nContentEditableInput.prototype.receivedFocus = function () {\\n  var input = this;\\n  if (this.selectionInEditor())\\n    { this.pollSelection(); }\\n  else\\n    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\\n\\n  function poll() {\\n    if (input.cm.state.focused) {\\n      input.pollSelection();\\n      input.polling.set(input.cm.options.pollInterval, poll);\\n    }\\n  }\\n  this.polling.set(this.cm.options.pollInterval, poll);\\n};\\n\\nContentEditableInput.prototype.selectionChanged = function () {\\n  var sel = window.getSelection();\\n  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\\n    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\\n};\\n\\nContentEditableInput.prototype.pollSelection = function () {\\n  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\\n  var sel = window.getSelection(), cm = this.cm;\\n  \\u002F\\u002F On Android Chrome (version 56, at least), backspacing into an\\n  \\u002F\\u002F uneditable block element will put the cursor in that element,\\n  \\u002F\\u002F and then, because it's not editable, hide the virtual keyboard.\\n  \\u002F\\u002F Because Android doesn't allow us to actually detect backspace\\n  \\u002F\\u002F presses in a sane way, this code checks for when that happens\\n  \\u002F\\u002F and simulates a backspace press in this case.\\n  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\\n    this.cm.triggerOnKeyDown({type: \\\"keydown\\\", keyCode: 8, preventDefault: Math.abs});\\n    this.blur();\\n    this.focus();\\n    return\\n  }\\n  if (this.composing) { return }\\n  this.rememberSelection();\\n  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\\n  var head = domToPos(cm, sel.focusNode, sel.focusOffset);\\n  if (anchor && head) { runInOp(cm, function () {\\n    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\\n    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\\n  }); }\\n};\\n\\nContentEditableInput.prototype.pollContent = function () {\\n  if (this.readDOMTimeout != null) {\\n    clearTimeout(this.readDOMTimeout);\\n    this.readDOMTimeout = null;\\n  }\\n\\n  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\\n  var from = sel.from(), to = sel.to();\\n  if (from.ch == 0 && from.line \\u003E cm.firstLine())\\n    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\\n  if (to.ch == getLine(cm.doc, to.line).text.length && to.line \\u003C cm.lastLine())\\n    { to = Pos(to.line + 1, 0); }\\n  if (from.line \\u003C display.viewFrom || to.line \\u003E display.viewTo - 1) { return false }\\n\\n  var fromIndex, fromLine, fromNode;\\n  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\\n    fromLine = lineNo(display.view[0].line);\\n    fromNode = display.view[0].node;\\n  } else {\\n    fromLine = lineNo(display.view[fromIndex].line);\\n    fromNode = display.view[fromIndex - 1].node.nextSibling;\\n  }\\n  var toIndex = findViewIndex(cm, to.line);\\n  var toLine, toNode;\\n  if (toIndex == display.view.length - 1) {\\n    toLine = display.viewTo - 1;\\n    toNode = display.lineDiv.lastChild;\\n  } else {\\n    toLine = lineNo(display.view[toIndex + 1].line) - 1;\\n    toNode = display.view[toIndex + 1].node.previousSibling;\\n  }\\n\\n  if (!fromNode) { return false }\\n  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\\n  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\\n  while (newText.length \\u003E 1 && oldText.length \\u003E 1) {\\n    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\\n    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\\n    else { break }\\n  }\\n\\n  var cutFront = 0, cutEnd = 0;\\n  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\\n  while (cutFront \\u003C maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\\n    { ++cutFront; }\\n  var newBot = lst(newText), oldBot = lst(oldText);\\n  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\\n                           oldBot.length - (oldText.length == 1 ? cutFront : 0));\\n  while (cutEnd \\u003C maxCutEnd &&\\n         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\\n    { ++cutEnd; }\\n  \\u002F\\u002F Try to move start of change to start of selection if ambiguous\\n  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\\n    while (cutFront && cutFront \\u003E from.ch &&\\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\\n      cutFront--;\\n      cutEnd++;\\n    }\\n  }\\n\\n  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(\\u002F^\\\\u200b+\\u002F, \\\"\\\");\\n  newText[0] = newText[0].slice(cutFront).replace(\\u002F\\\\u200b+$\\u002F, \\\"\\\");\\n\\n  var chFrom = Pos(fromLine, cutFront);\\n  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\\n  if (newText.length \\u003E 1 || newText[0] || cmp(chFrom, chTo)) {\\n    replaceRange(cm.doc, newText, chFrom, chTo, \\\"+input\\\");\\n    return true\\n  }\\n};\\n\\nContentEditableInput.prototype.ensurePolled = function () {\\n  this.forceCompositionEnd();\\n};\\nContentEditableInput.prototype.reset = function () {\\n  this.forceCompositionEnd();\\n};\\nContentEditableInput.prototype.forceCompositionEnd = function () {\\n  if (!this.composing) { return }\\n  clearTimeout(this.readDOMTimeout);\\n  this.composing = null;\\n  this.updateFromDOM();\\n  this.div.blur();\\n  this.div.focus();\\n};\\nContentEditableInput.prototype.readFromDOMSoon = function () {\\n    var this$1 = this;\\n\\n  if (this.readDOMTimeout != null) { return }\\n  this.readDOMTimeout = setTimeout(function () {\\n    this$1.readDOMTimeout = null;\\n    if (this$1.composing) {\\n      if (this$1.composing.done) { this$1.composing = null; }\\n      else { return }\\n    }\\n    this$1.updateFromDOM();\\n  }, 80);\\n};\\n\\nContentEditableInput.prototype.updateFromDOM = function () {\\n    var this$1 = this;\\n\\n  if (this.cm.isReadOnly() || !this.pollContent())\\n    { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\\n};\\n\\nContentEditableInput.prototype.setUneditable = function (node) {\\n  node.contentEditable = \\\"false\\\";\\n};\\n\\nContentEditableInput.prototype.onKeyPress = function (e) {\\n  if (e.charCode == 0) { return }\\n  e.preventDefault();\\n  if (!this.cm.isReadOnly())\\n    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\\n};\\n\\nContentEditableInput.prototype.readOnlyChanged = function (val) {\\n  this.div.contentEditable = String(val != \\\"nocursor\\\");\\n};\\n\\nContentEditableInput.prototype.onContextMenu = function () {};\\nContentEditableInput.prototype.resetPosition = function () {};\\n\\nContentEditableInput.prototype.needsContentAttribute = true;\\n\\nfunction posToDOM(cm, pos) {\\n  var view = findViewForLine(cm, pos.line);\\n  if (!view || view.hidden) { return null }\\n  var line = getLine(cm.doc, pos.line);\\n  var info = mapFromLineView(view, line, pos.line);\\n\\n  var order = getOrder(line, cm.doc.direction), side = \\\"left\\\";\\n  if (order) {\\n    var partPos = getBidiPartAt(order, pos.ch);\\n    side = partPos % 2 ? \\\"right\\\" : \\\"left\\\";\\n  }\\n  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\\n  result.offset = result.collapse == \\\"right\\\" ? result.end : result.start;\\n  return result\\n}\\n\\nfunction isInGutter(node) {\\n  for (var scan = node; scan; scan = scan.parentNode)\\n    { if (\\u002FCodeMirror-gutter-wrapper\\u002F.test(scan.className)) { return true } }\\n  return false\\n}\\n\\nfunction badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\\n\\nfunction domTextBetween(cm, from, to, fromLine, toLine) {\\n  var text = \\\"\\\", closing = false, lineSep = cm.doc.lineSeparator();\\n  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\\n  function close() {\\n    if (closing) {\\n      text += lineSep;\\n      closing = false;\\n    }\\n  }\\n  function addText(str) {\\n    if (str) {\\n      close();\\n      text += str;\\n    }\\n  }\\n  function walk(node) {\\n    if (node.nodeType == 1) {\\n      var cmText = node.getAttribute(\\\"cm-text\\\");\\n      if (cmText != null) {\\n        addText(cmText || node.textContent.replace(\\u002F\\\\u200b\\u002Fg, \\\"\\\"));\\n        return\\n      }\\n      var markerID = node.getAttribute(\\\"cm-marker\\\"), range$$1;\\n      if (markerID) {\\n        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\\n        if (found.length && (range$$1 = found[0].find(0)))\\n          { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\\n        return\\n      }\\n      if (node.getAttribute(\\\"contenteditable\\\") == \\\"false\\\") { return }\\n      var isBlock = \\u002F^(pre|div|p)$\\u002Fi.test(node.nodeName);\\n      if (isBlock) { close(); }\\n      for (var i = 0; i \\u003C node.childNodes.length; i++)\\n        { walk(node.childNodes[i]); }\\n      if (isBlock) { closing = true; }\\n    } else if (node.nodeType == 3) {\\n      addText(node.nodeValue);\\n    }\\n  }\\n  for (;;) {\\n    walk(from);\\n    if (from == to) { break }\\n    from = from.nextSibling;\\n  }\\n  return text\\n}\\n\\nfunction domToPos(cm, node, offset) {\\n  var lineNode;\\n  if (node == cm.display.lineDiv) {\\n    lineNode = cm.display.lineDiv.childNodes[offset];\\n    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\\n    node = null; offset = 0;\\n  } else {\\n    for (lineNode = node;; lineNode = lineNode.parentNode) {\\n      if (!lineNode || lineNode == cm.display.lineDiv) { return null }\\n      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\\n    }\\n  }\\n  for (var i = 0; i \\u003C cm.display.view.length; i++) {\\n    var lineView = cm.display.view[i];\\n    if (lineView.node == lineNode)\\n      { return locateNodeInLineView(lineView, node, offset) }\\n  }\\n}\\n\\nfunction locateNodeInLineView(lineView, node, offset) {\\n  var wrapper = lineView.text.firstChild, bad = false;\\n  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\\n  if (node == wrapper) {\\n    bad = true;\\n    node = wrapper.childNodes[offset];\\n    offset = 0;\\n    if (!node) {\\n      var line = lineView.rest ? lst(lineView.rest) : lineView.line;\\n      return badPos(Pos(lineNo(line), line.text.length), bad)\\n    }\\n  }\\n\\n  var textNode = node.nodeType == 3 ? node : null, topNode = node;\\n  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\\n    textNode = node.firstChild;\\n    if (offset) { offset = textNode.nodeValue.length; }\\n  }\\n  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\\n  var measure = lineView.measure, maps = measure.maps;\\n\\n  function find(textNode, topNode, offset) {\\n    for (var i = -1; i \\u003C (maps ? maps.length : 0); i++) {\\n      var map$$1 = i \\u003C 0 ? measure.map : maps[i];\\n      for (var j = 0; j \\u003C map$$1.length; j += 3) {\\n        var curNode = map$$1[j + 2];\\n        if (curNode == textNode || curNode == topNode) {\\n          var line = lineNo(i \\u003C 0 ? lineView.line : lineView.rest[i]);\\n          var ch = map$$1[j] + offset;\\n          if (offset \\u003C 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\\n          return Pos(line, ch)\\n        }\\n      }\\n    }\\n  }\\n  var found = find(textNode, topNode, offset);\\n  if (found) { return badPos(found, bad) }\\n\\n  \\u002F\\u002F FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\\n  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\\n    found = find(after, after.firstChild, 0);\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch - dist), bad) }\\n    else\\n      { dist += after.textContent.length; }\\n  }\\n  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\\n    found = find(before, before.firstChild, -1);\\n    if (found)\\n      { return badPos(Pos(found.line, found.ch + dist$1), bad) }\\n    else\\n      { dist$1 += before.textContent.length; }\\n  }\\n}\\n\\n\\u002F\\u002F TEXTAREA INPUT STYLE\\n\\nvar TextareaInput = function(cm) {\\n  this.cm = cm;\\n  \\u002F\\u002F See input.poll and input.reset\\n  this.prevInput = \\\"\\\";\\n\\n  \\u002F\\u002F Flag that indicates whether we expect input to appear real soon\\n  \\u002F\\u002F now (after some event like 'keypress' or 'input') and are\\n  \\u002F\\u002F polling intensively.\\n  this.pollingFast = false;\\n  \\u002F\\u002F Self-resetting timeout for the poller\\n  this.polling = new Delayed();\\n  \\u002F\\u002F Used to work around IE issue with selection being forgotten when focus moves away from textarea\\n  this.hasSelection = false;\\n  this.composing = null;\\n};\\n\\nTextareaInput.prototype.init = function (display) {\\n    var this$1 = this;\\n\\n  var input = this, cm = this.cm;\\n\\n  \\u002F\\u002F Wraps and hides input textarea\\n  var div = this.wrapper = hiddenTextarea();\\n  \\u002F\\u002F The semihidden textarea that is focused when the editor is\\n  \\u002F\\u002F focused, and receives input.\\n  var te = this.textarea = div.firstChild;\\n  display.wrapper.insertBefore(div, display.wrapper.firstChild);\\n\\n  \\u002F\\u002F Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\\n  if (ios) { te.style.width = \\\"0px\\\"; }\\n\\n  on(te, \\\"input\\\", function () {\\n    if (ie && ie_version \\u003E= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\\n    input.poll();\\n  });\\n\\n  on(te, \\\"paste\\\", function (e) {\\n    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\\n\\n    cm.state.pasteIncoming = true;\\n    input.fastPoll();\\n  });\\n\\n  function prepareCopyCut(e) {\\n    if (signalDOMEvent(cm, e)) { return }\\n    if (cm.somethingSelected()) {\\n      setLastCopied({lineWise: false, text: cm.getSelections()});\\n    } else if (!cm.options.lineWiseCopyCut) {\\n      return\\n    } else {\\n      var ranges = copyableRanges(cm);\\n      setLastCopied({lineWise: true, text: ranges.text});\\n      if (e.type == \\\"cut\\\") {\\n        cm.setSelections(ranges.ranges, null, sel_dontScroll);\\n      } else {\\n        input.prevInput = \\\"\\\";\\n        te.value = ranges.text.join(\\\"\\\\n\\\");\\n        selectInput(te);\\n      }\\n    }\\n    if (e.type == \\\"cut\\\") { cm.state.cutIncoming = true; }\\n  }\\n  on(te, \\\"cut\\\", prepareCopyCut);\\n  on(te, \\\"copy\\\", prepareCopyCut);\\n\\n  on(display.scroller, \\\"paste\\\", function (e) {\\n    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\\n    cm.state.pasteIncoming = true;\\n    input.focus();\\n  });\\n\\n  \\u002F\\u002F Prevent normal selection in the editor (we handle our own)\\n  on(display.lineSpace, \\\"selectstart\\\", function (e) {\\n    if (!eventInWidget(display, e)) { e_preventDefault(e); }\\n  });\\n\\n  on(te, \\\"compositionstart\\\", function () {\\n    var start = cm.getCursor(\\\"from\\\");\\n    if (input.composing) { input.composing.range.clear(); }\\n    input.composing = {\\n      start: start,\\n      range: cm.markText(start, cm.getCursor(\\\"to\\\"), {className: \\\"CodeMirror-composing\\\"})\\n    };\\n  });\\n  on(te, \\\"compositionend\\\", function () {\\n    if (input.composing) {\\n      input.poll();\\n      input.composing.range.clear();\\n      input.composing = null;\\n    }\\n  });\\n};\\n\\nTextareaInput.prototype.prepareSelection = function () {\\n  \\u002F\\u002F Redraw the selection and\\u002For cursor\\n  var cm = this.cm, display = cm.display, doc = cm.doc;\\n  var result = prepareSelection(cm);\\n\\n  \\u002F\\u002F Move the hidden textarea near the cursor to prevent scrolling artifacts\\n  if (cm.options.moveInputWithCursor) {\\n    var headPos = cursorCoords(cm, doc.sel.primary().head, \\\"div\\\");\\n    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\\n    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\\n                                        headPos.top + lineOff.top - wrapOff.top));\\n    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\\n                                         headPos.left + lineOff.left - wrapOff.left));\\n  }\\n\\n  return result\\n};\\n\\nTextareaInput.prototype.showSelection = function (drawn) {\\n  var cm = this.cm, display = cm.display;\\n  removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\\n  removeChildrenAndAdd(display.selectionDiv, drawn.selection);\\n  if (drawn.teTop != null) {\\n    this.wrapper.style.top = drawn.teTop + \\\"px\\\";\\n    this.wrapper.style.left = drawn.teLeft + \\\"px\\\";\\n  }\\n};\\n\\n\\u002F\\u002F Reset the input to correspond to the selection (or to be empty,\\n\\u002F\\u002F when not typing and nothing is selected)\\nTextareaInput.prototype.reset = function (typing) {\\n  if (this.contextMenuPending || this.composing) { return }\\n  var cm = this.cm;\\n  if (cm.somethingSelected()) {\\n    this.prevInput = \\\"\\\";\\n    var content = cm.getSelection();\\n    this.textarea.value = content;\\n    if (cm.state.focused) { selectInput(this.textarea); }\\n    if (ie && ie_version \\u003E= 9) { this.hasSelection = content; }\\n  } else if (!typing) {\\n    this.prevInput = this.textarea.value = \\\"\\\";\\n    if (ie && ie_version \\u003E= 9) { this.hasSelection = null; }\\n  }\\n};\\n\\nTextareaInput.prototype.getField = function () { return this.textarea };\\n\\nTextareaInput.prototype.supportsTouch = function () { return false };\\n\\nTextareaInput.prototype.focus = function () {\\n  if (this.cm.options.readOnly != \\\"nocursor\\\" && (!mobile || activeElt() != this.textarea)) {\\n    try { this.textarea.focus(); }\\n    catch (e) {} \\u002F\\u002F IE8 will throw if the textarea is display: none or not in DOM\\n  }\\n};\\n\\nTextareaInput.prototype.blur = function () { this.textarea.blur(); };\\n\\nTextareaInput.prototype.resetPosition = function () {\\n  this.wrapper.style.top = this.wrapper.style.left = 0;\\n};\\n\\nTextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\\n\\n\\u002F\\u002F Poll for input changes, using the normal rate of polling. This\\n\\u002F\\u002F runs as long as the editor is focused.\\nTextareaInput.prototype.slowPoll = function () {\\n    var this$1 = this;\\n\\n  if (this.pollingFast) { return }\\n  this.polling.set(this.cm.options.pollInterval, function () {\\n    this$1.poll();\\n    if (this$1.cm.state.focused) { this$1.slowPoll(); }\\n  });\\n};\\n\\n\\u002F\\u002F When an event has just come in that is likely to add or change\\n\\u002F\\u002F something in the input textarea, we poll faster, to ensure that\\n\\u002F\\u002F the change appears on the screen quickly.\\nTextareaInput.prototype.fastPoll = function () {\\n  var missed = false, input = this;\\n  input.pollingFast = true;\\n  function p() {\\n    var changed = input.poll();\\n    if (!changed && !missed) {missed = true; input.polling.set(60, p);}\\n    else {input.pollingFast = false; input.slowPoll();}\\n  }\\n  input.polling.set(20, p);\\n};\\n\\n\\u002F\\u002F Read input from the textarea, and update the document to match.\\n\\u002F\\u002F When something is selected, it is present in the textarea, and\\n\\u002F\\u002F selected (unless it is huge, in which case a placeholder is\\n\\u002F\\u002F used). When nothing is selected, the cursor sits after previously\\n\\u002F\\u002F seen text (can be empty), which is stored in prevInput (we must\\n\\u002F\\u002F not reset the textarea when typing, because that breaks IME).\\nTextareaInput.prototype.poll = function () {\\n    var this$1 = this;\\n\\n  var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\\n  \\u002F\\u002F Since this is called a *lot*, try to bail out as cheaply as\\n  \\u002F\\u002F possible when it is clear that nothing happened. hasSelection\\n  \\u002F\\u002F will be the case when there is a lot of text in the textarea,\\n  \\u002F\\u002F in which case reading its value would be expensive.\\n  if (this.contextMenuPending || !cm.state.focused ||\\n      (hasSelection(input) && !prevInput && !this.composing) ||\\n      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\\n    { return false }\\n\\n  var text = input.value;\\n  \\u002F\\u002F If nothing changed, bail.\\n  if (text == prevInput && !cm.somethingSelected()) { return false }\\n  \\u002F\\u002F Work around nonsensical selection resetting in IE9\\u002F10, and\\n  \\u002F\\u002F inexplicable appearance of private area unicode characters on\\n  \\u002F\\u002F some key combos in Mac (#2689).\\n  if (ie && ie_version \\u003E= 9 && this.hasSelection === text ||\\n      mac && \\u002F[\\\\uf700-\\\\uf7ff]\\u002F.test(text)) {\\n    cm.display.input.reset();\\n    return false\\n  }\\n\\n  if (cm.doc.sel == cm.display.selForContextMenu) {\\n    var first = text.charCodeAt(0);\\n    if (first == 0x200b && !prevInput) { prevInput = \\\"\\\\u200b\\\"; }\\n    if (first == 0x21da) { this.reset(); return this.cm.execCommand(\\\"undo\\\") }\\n  }\\n  \\u002F\\u002F Find the part of the input that is actually new\\n  var same = 0, l = Math.min(prevInput.length, text.length);\\n  while (same \\u003C l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\\n\\n  runInOp(cm, function () {\\n    applyTextInput(cm, text.slice(same), prevInput.length - same,\\n                   null, this$1.composing ? \\\"*compose\\\" : null);\\n\\n    \\u002F\\u002F Don't leave long text in the textarea, since it makes further polling slow\\n    if (text.length \\u003E 1000 || text.indexOf(\\\"\\\\n\\\") \\u003E -1) { input.value = this$1.prevInput = \\\"\\\"; }\\n    else { this$1.prevInput = text; }\\n\\n    if (this$1.composing) {\\n      this$1.composing.range.clear();\\n      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\\\"to\\\"),\\n                                         {className: \\\"CodeMirror-composing\\\"});\\n    }\\n  });\\n  return true\\n};\\n\\nTextareaInput.prototype.ensurePolled = function () {\\n  if (this.pollingFast && this.poll()) { this.pollingFast = false; }\\n};\\n\\nTextareaInput.prototype.onKeyPress = function () {\\n  if (ie && ie_version \\u003E= 9) { this.hasSelection = null; }\\n  this.fastPoll();\\n};\\n\\nTextareaInput.prototype.onContextMenu = function (e) {\\n  var input = this, cm = input.cm, display = cm.display, te = input.textarea;\\n  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\\n  if (!pos || presto) { return } \\u002F\\u002F Opera is difficult.\\n\\n  \\u002F\\u002F Reset the current text selection only if the click is done outside of the selection\\n  \\u002F\\u002F and 'resetSelectionOnContextMenu' option is true.\\n  var reset = cm.options.resetSelectionOnContextMenu;\\n  if (reset && cm.doc.sel.contains(pos) == -1)\\n    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\\n\\n  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\\n  input.wrapper.style.cssText = \\\"position: absolute\\\";\\n  var wrapperBox = input.wrapper.getBoundingClientRect();\\n  te.style.cssText = \\\"position: absolute; width: 30px; height: 30px;\\\\n      top: \\\" + (e.clientY - wrapperBox.top - 5) + \\\"px; left: \\\" + (e.clientX - wrapperBox.left - 5) + \\\"px;\\\\n      z-index: 1000; background: \\\" + (ie ? \\\"rgba(255, 255, 255, .05)\\\" : \\\"transparent\\\") + \\\";\\\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\\\";\\n  var oldScrollY;\\n  if (webkit) { oldScrollY = window.scrollY; } \\u002F\\u002F Work around Chrome issue (#2712)\\n  display.input.focus();\\n  if (webkit) { window.scrollTo(null, oldScrollY); }\\n  display.input.reset();\\n  \\u002F\\u002F Adds \\\"Select all\\\" to context menu in FF\\n  if (!cm.somethingSelected()) { te.value = input.prevInput = \\\" \\\"; }\\n  input.contextMenuPending = true;\\n  display.selForContextMenu = cm.doc.sel;\\n  clearTimeout(display.detectingSelectAll);\\n\\n  \\u002F\\u002F Select-all will be greyed out if there's nothing to select, so\\n  \\u002F\\u002F this adds a zero-width space so that we can later check whether\\n  \\u002F\\u002F it got selected.\\n  function prepareSelectAllHack() {\\n    if (te.selectionStart != null) {\\n      var selected = cm.somethingSelected();\\n      var extval = \\\"\\\\u200b\\\" + (selected ? te.value : \\\"\\\");\\n      te.value = \\\"\\\\u21da\\\"; \\u002F\\u002F Used to catch context-menu undo\\n      te.value = extval;\\n      input.prevInput = selected ? \\\"\\\" : \\\"\\\\u200b\\\";\\n      te.selectionStart = 1; te.selectionEnd = extval.length;\\n      \\u002F\\u002F Re-set this, in case some other handler touched the\\n      \\u002F\\u002F selection in the meantime.\\n      display.selForContextMenu = cm.doc.sel;\\n    }\\n  }\\n  function rehide() {\\n    input.contextMenuPending = false;\\n    input.wrapper.style.cssText = oldWrapperCSS;\\n    te.style.cssText = oldCSS;\\n    if (ie && ie_version \\u003C 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\\n\\n    \\u002F\\u002F Try to detect the user choosing select-all\\n    if (te.selectionStart != null) {\\n      if (!ie || (ie && ie_version \\u003C 9)) { prepareSelectAllHack(); }\\n      var i = 0, poll = function () {\\n        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\\n            te.selectionEnd \\u003E 0 && input.prevInput == \\\"\\\\u200b\\\") {\\n          operation(cm, selectAll)(cm);\\n        } else if (i++ \\u003C 10) {\\n          display.detectingSelectAll = setTimeout(poll, 500);\\n        } else {\\n          display.selForContextMenu = null;\\n          display.input.reset();\\n        }\\n      };\\n      display.detectingSelectAll = setTimeout(poll, 200);\\n    }\\n  }\\n\\n  if (ie && ie_version \\u003E= 9) { prepareSelectAllHack(); }\\n  if (captureRightClick) {\\n    e_stop(e);\\n    var mouseup = function () {\\n      off(window, \\\"mouseup\\\", mouseup);\\n      setTimeout(rehide, 20);\\n    };\\n    on(window, \\\"mouseup\\\", mouseup);\\n  } else {\\n    setTimeout(rehide, 50);\\n  }\\n};\\n\\nTextareaInput.prototype.readOnlyChanged = function (val) {\\n  if (!val) { this.reset(); }\\n  this.textarea.disabled = val == \\\"nocursor\\\";\\n};\\n\\nTextareaInput.prototype.setUneditable = function () {};\\n\\nTextareaInput.prototype.needsContentAttribute = false;\\n\\nfunction fromTextArea(textarea, options) {\\n  options = options ? copyObj(options) : {};\\n  options.value = textarea.value;\\n  if (!options.tabindex && textarea.tabIndex)\\n    { options.tabindex = textarea.tabIndex; }\\n  if (!options.placeholder && textarea.placeholder)\\n    { options.placeholder = textarea.placeholder; }\\n  \\u002F\\u002F Set autofocus to true if this textarea is focused, or if it has\\n  \\u002F\\u002F autofocus and no other element is focused.\\n  if (options.autofocus == null) {\\n    var hasFocus = activeElt();\\n    options.autofocus = hasFocus == textarea ||\\n      textarea.getAttribute(\\\"autofocus\\\") != null && hasFocus == document.body;\\n  }\\n\\n  function save() {textarea.value = cm.getValue();}\\n\\n  var realSubmit;\\n  if (textarea.form) {\\n    on(textarea.form, \\\"submit\\\", save);\\n    \\u002F\\u002F Deplorable hack to make the submit method do the right thing.\\n    if (!options.leaveSubmitMethodAlone) {\\n      var form = textarea.form;\\n      realSubmit = form.submit;\\n      try {\\n        var wrappedSubmit = form.submit = function () {\\n          save();\\n          form.submit = realSubmit;\\n          form.submit();\\n          form.submit = wrappedSubmit;\\n        };\\n      } catch(e) {}\\n    }\\n  }\\n\\n  options.finishInit = function (cm) {\\n    cm.save = save;\\n    cm.getTextArea = function () { return textarea; };\\n    cm.toTextArea = function () {\\n      cm.toTextArea = isNaN; \\u002F\\u002F Prevent this from being ran twice\\n      save();\\n      textarea.parentNode.removeChild(cm.getWrapperElement());\\n      textarea.style.display = \\\"\\\";\\n      if (textarea.form) {\\n        off(textarea.form, \\\"submit\\\", save);\\n        if (typeof textarea.form.submit == \\\"function\\\")\\n          { textarea.form.submit = realSubmit; }\\n      }\\n    };\\n  };\\n\\n  textarea.style.display = \\\"none\\\";\\n  var cm = CodeMirror$1(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\\n    options);\\n  return cm\\n}\\n\\nfunction addLegacyProps(CodeMirror) {\\n  CodeMirror.off = off;\\n  CodeMirror.on = on;\\n  CodeMirror.wheelEventPixels = wheelEventPixels;\\n  CodeMirror.Doc = Doc;\\n  CodeMirror.splitLines = splitLinesAuto;\\n  CodeMirror.countColumn = countColumn;\\n  CodeMirror.findColumn = findColumn;\\n  CodeMirror.isWordChar = isWordCharBasic;\\n  CodeMirror.Pass = Pass;\\n  CodeMirror.signal = signal;\\n  CodeMirror.Line = Line;\\n  CodeMirror.changeEnd = changeEnd;\\n  CodeMirror.scrollbarModel = scrollbarModel;\\n  CodeMirror.Pos = Pos;\\n  CodeMirror.cmpPos = cmp;\\n  CodeMirror.modes = modes;\\n  CodeMirror.mimeModes = mimeModes;\\n  CodeMirror.resolveMode = resolveMode;\\n  CodeMirror.getMode = getMode;\\n  CodeMirror.modeExtensions = modeExtensions;\\n  CodeMirror.extendMode = extendMode;\\n  CodeMirror.copyState = copyState;\\n  CodeMirror.startState = startState;\\n  CodeMirror.innerMode = innerMode;\\n  CodeMirror.commands = commands;\\n  CodeMirror.keyMap = keyMap;\\n  CodeMirror.keyName = keyName;\\n  CodeMirror.isModifierKey = isModifierKey;\\n  CodeMirror.lookupKey = lookupKey;\\n  CodeMirror.normalizeKeyMap = normalizeKeyMap;\\n  CodeMirror.StringStream = StringStream;\\n  CodeMirror.SharedTextMarker = SharedTextMarker;\\n  CodeMirror.TextMarker = TextMarker;\\n  CodeMirror.LineWidget = LineWidget;\\n  CodeMirror.e_preventDefault = e_preventDefault;\\n  CodeMirror.e_stopPropagation = e_stopPropagation;\\n  CodeMirror.e_stop = e_stop;\\n  CodeMirror.addClass = addClass;\\n  CodeMirror.contains = contains;\\n  CodeMirror.rmClass = rmClass;\\n  CodeMirror.keyNames = keyNames;\\n}\\n\\n\\u002F\\u002F EDITOR CONSTRUCTOR\\n\\ndefineOptions(CodeMirror$1);\\n\\naddEditorMethods(CodeMirror$1);\\n\\n\\u002F\\u002F Set up methods on CodeMirror's prototype to redirect to the editor's document.\\nvar dontDelegate = \\\"iter insert remove copy getEditor constructor\\\".split(\\\" \\\");\\nfor (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) \\u003C 0)\\n  { CodeMirror$1.prototype[prop] = (function(method) {\\n    return function() {return method.apply(this.doc, arguments)}\\n  })(Doc.prototype[prop]); } }\\n\\neventMixin(Doc);\\n\\n\\u002F\\u002F INPUT HANDLING\\n\\nCodeMirror$1.inputStyles = {\\\"textarea\\\": TextareaInput, \\\"contenteditable\\\": ContentEditableInput};\\n\\n\\u002F\\u002F MODE DEFINITION AND QUERYING\\n\\n\\u002F\\u002F Extra arguments are stored as the mode's dependencies, which is\\n\\u002F\\u002F used by (legacy) mechanisms like loadmode.js to automatically\\n\\u002F\\u002F load a mode. (Preferred mechanism is the require\\u002Fdefine calls.)\\nCodeMirror$1.defineMode = function(name\\u002F*, mode, *\\u002F) {\\n  if (!CodeMirror$1.defaults.mode && name != \\\"null\\\") { CodeMirror$1.defaults.mode = name; }\\n  defineMode.apply(this, arguments);\\n};\\n\\nCodeMirror$1.defineMIME = defineMIME;\\n\\n\\u002F\\u002F Minimal default mode.\\nCodeMirror$1.defineMode(\\\"null\\\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\\nCodeMirror$1.defineMIME(\\\"text\\u002Fplain\\\", \\\"null\\\");\\n\\n\\u002F\\u002F EXTENSIONS\\n\\nCodeMirror$1.defineExtension = function (name, func) {\\n  CodeMirror$1.prototype[name] = func;\\n};\\nCodeMirror$1.defineDocExtension = function (name, func) {\\n  Doc.prototype[name] = func;\\n};\\n\\nCodeMirror$1.fromTextArea = fromTextArea;\\n\\naddLegacyProps(CodeMirror$1);\\n\\nCodeMirror$1.version = \\\"5.35.0\\\";\\n\\nreturn CodeMirror$1;\\n\\n})));\\n\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Fmode\\u002Fjavascript\\u002Fjavascript.js\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F CodeMirror, copyright (c) by Marijn Haverbeke and others\\n\\u002F\\u002F Distributed under an MIT license: http:\\u002F\\u002Fcodemirror.net\\u002FLICENSE\\n\\n(function(mod) {\\n  if (true) \\u002F\\u002F CommonJS\\n    mod(__webpack_require__(\\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.js\\\"));\\n  else if (typeof define == \\\"function\\\" && define.amd) \\u002F\\u002F AMD\\n    define([\\\"..\\u002F..\\u002Flib\\u002Fcodemirror\\\"], mod);\\n  else \\u002F\\u002F Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nCodeMirror.defineMode(\\\"javascript\\\", function(config, parserConfig) {\\n  var indentUnit = config.indentUnit;\\n  var statementIndent = parserConfig.statementIndent;\\n  var jsonldMode = parserConfig.jsonld;\\n  var jsonMode = parserConfig.json || jsonldMode;\\n  var isTS = parserConfig.typescript;\\n  var wordRE = parserConfig.wordCharacters || \\u002F[\\\\w$\\\\xa1-\\\\uffff]\\u002F;\\n\\n  \\u002F\\u002F Tokenizer\\n\\n  var keywords = function(){\\n    function kw(type) {return {type: type, style: \\\"keyword\\\"};}\\n    var A = kw(\\\"keyword a\\\"), B = kw(\\\"keyword b\\\"), C = kw(\\\"keyword c\\\"), D = kw(\\\"keyword d\\\");\\n    var operator = kw(\\\"operator\\\"), atom = {type: \\\"atom\\\", style: \\\"atom\\\"};\\n\\n    return {\\n      \\\"if\\\": kw(\\\"if\\\"), \\\"while\\\": A, \\\"with\\\": A, \\\"else\\\": B, \\\"do\\\": B, \\\"try\\\": B, \\\"finally\\\": B,\\n      \\\"return\\\": D, \\\"break\\\": D, \\\"continue\\\": D, \\\"new\\\": kw(\\\"new\\\"), \\\"delete\\\": C, \\\"void\\\": C, \\\"throw\\\": C,\\n      \\\"debugger\\\": kw(\\\"debugger\\\"), \\\"var\\\": kw(\\\"var\\\"), \\\"const\\\": kw(\\\"var\\\"), \\\"let\\\": kw(\\\"var\\\"),\\n      \\\"function\\\": kw(\\\"function\\\"), \\\"catch\\\": kw(\\\"catch\\\"),\\n      \\\"for\\\": kw(\\\"for\\\"), \\\"switch\\\": kw(\\\"switch\\\"), \\\"case\\\": kw(\\\"case\\\"), \\\"default\\\": kw(\\\"default\\\"),\\n      \\\"in\\\": operator, \\\"typeof\\\": operator, \\\"instanceof\\\": operator,\\n      \\\"true\\\": atom, \\\"false\\\": atom, \\\"null\\\": atom, \\\"undefined\\\": atom, \\\"NaN\\\": atom, \\\"Infinity\\\": atom,\\n      \\\"this\\\": kw(\\\"this\\\"), \\\"class\\\": kw(\\\"class\\\"), \\\"super\\\": kw(\\\"atom\\\"),\\n      \\\"yield\\\": C, \\\"export\\\": kw(\\\"export\\\"), \\\"import\\\": kw(\\\"import\\\"), \\\"extends\\\": C,\\n      \\\"await\\\": C\\n    };\\n  }();\\n\\n  var isOperatorChar = \\u002F[+\\\\-*&%=\\u003C\\u003E!?|~^@]\\u002F;\\n  var isJsonldKeyword = \\u002F^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\\\"\\u002F;\\n\\n  function readRegexp(stream) {\\n    var escaped = false, next, inSet = false;\\n    while ((next = stream.next()) != null) {\\n      if (!escaped) {\\n        if (next == \\\"\\u002F\\\" && !inSet) return;\\n        if (next == \\\"[\\\") inSet = true;\\n        else if (inSet && next == \\\"]\\\") inSet = false;\\n      }\\n      escaped = !escaped && next == \\\"\\\\\\\\\\\";\\n    }\\n  }\\n\\n  \\u002F\\u002F Used as scratch variables to communicate multiple values without\\n  \\u002F\\u002F consing up tons of objects.\\n  var type, content;\\n  function ret(tp, style, cont) {\\n    type = tp; content = cont;\\n    return style;\\n  }\\n  function tokenBase(stream, state) {\\n    var ch = stream.next();\\n    if (ch == '\\\"' || ch == \\\"'\\\") {\\n      state.tokenize = tokenString(ch);\\n      return state.tokenize(stream, state);\\n    } else if (ch == \\\".\\\" && stream.match(\\u002F^\\\\d+(?:[eE][+\\\\-]?\\\\d+)?\\u002F)) {\\n      return ret(\\\"number\\\", \\\"number\\\");\\n    } else if (ch == \\\".\\\" && stream.match(\\\"..\\\")) {\\n      return ret(\\\"spread\\\", \\\"meta\\\");\\n    } else if (\\u002F[\\\\[\\\\]{}\\\\(\\\\),;\\\\:\\\\.]\\u002F.test(ch)) {\\n      return ret(ch);\\n    } else if (ch == \\\"=\\\" && stream.eat(\\\"\\u003E\\\")) {\\n      return ret(\\\"=\\u003E\\\", \\\"operator\\\");\\n    } else if (ch == \\\"0\\\" && stream.eat(\\u002Fx\\u002Fi)) {\\n      stream.eatWhile(\\u002F[\\\\da-f]\\u002Fi);\\n      return ret(\\\"number\\\", \\\"number\\\");\\n    } else if (ch == \\\"0\\\" && stream.eat(\\u002Fo\\u002Fi)) {\\n      stream.eatWhile(\\u002F[0-7]\\u002Fi);\\n      return ret(\\\"number\\\", \\\"number\\\");\\n    } else if (ch == \\\"0\\\" && stream.eat(\\u002Fb\\u002Fi)) {\\n      stream.eatWhile(\\u002F[01]\\u002Fi);\\n      return ret(\\\"number\\\", \\\"number\\\");\\n    } else if (\\u002F\\\\d\\u002F.test(ch)) {\\n      stream.match(\\u002F^\\\\d*(?:\\\\.\\\\d*)?(?:[eE][+\\\\-]?\\\\d+)?\\u002F);\\n      return ret(\\\"number\\\", \\\"number\\\");\\n    } else if (ch == \\\"\\u002F\\\") {\\n      if (stream.eat(\\\"*\\\")) {\\n        state.tokenize = tokenComment;\\n        return tokenComment(stream, state);\\n      } else if (stream.eat(\\\"\\u002F\\\")) {\\n        stream.skipToEnd();\\n        return ret(\\\"comment\\\", \\\"comment\\\");\\n      } else if (expressionAllowed(stream, state, 1)) {\\n        readRegexp(stream);\\n        stream.match(\\u002F^\\\\b(([gimyu])(?![gimyu]*\\\\2))+\\\\b\\u002F);\\n        return ret(\\\"regexp\\\", \\\"string-2\\\");\\n      } else {\\n        stream.eat(\\\"=\\\");\\n        return ret(\\\"operator\\\", \\\"operator\\\", stream.current());\\n      }\\n    } else if (ch == \\\"`\\\") {\\n      state.tokenize = tokenQuasi;\\n      return tokenQuasi(stream, state);\\n    } else if (ch == \\\"#\\\") {\\n      stream.skipToEnd();\\n      return ret(\\\"error\\\", \\\"error\\\");\\n    } else if (isOperatorChar.test(ch)) {\\n      if (ch != \\\"\\u003E\\\" || !state.lexical || state.lexical.type != \\\"\\u003E\\\") {\\n        if (stream.eat(\\\"=\\\")) {\\n          if (ch == \\\"!\\\" || ch == \\\"=\\\") stream.eat(\\\"=\\\")\\n        } else if (\\u002F[\\u003C\\u003E*+\\\\-]\\u002F.test(ch)) {\\n          stream.eat(ch)\\n          if (ch == \\\"\\u003E\\\") stream.eat(ch)\\n        }\\n      }\\n      return ret(\\\"operator\\\", \\\"operator\\\", stream.current());\\n    } else if (wordRE.test(ch)) {\\n      stream.eatWhile(wordRE);\\n      var word = stream.current()\\n      if (state.lastType != \\\".\\\") {\\n        if (keywords.propertyIsEnumerable(word)) {\\n          var kw = keywords[word]\\n          return ret(kw.type, kw.style, word)\\n        }\\n        if (word == \\\"async\\\" && stream.match(\\u002F^(\\\\s|\\\\\\u002F\\\\*.*?\\\\*\\\\\\u002F)*[\\\\(\\\\w]\\u002F, false))\\n          return ret(\\\"async\\\", \\\"keyword\\\", word)\\n      }\\n      return ret(\\\"variable\\\", \\\"variable\\\", word)\\n    }\\n  }\\n\\n  function tokenString(quote) {\\n    return function(stream, state) {\\n      var escaped = false, next;\\n      if (jsonldMode && stream.peek() == \\\"@\\\" && stream.match(isJsonldKeyword)){\\n        state.tokenize = tokenBase;\\n        return ret(\\\"jsonld-keyword\\\", \\\"meta\\\");\\n      }\\n      while ((next = stream.next()) != null) {\\n        if (next == quote && !escaped) break;\\n        escaped = !escaped && next == \\\"\\\\\\\\\\\";\\n      }\\n      if (!escaped) state.tokenize = tokenBase;\\n      return ret(\\\"string\\\", \\\"string\\\");\\n    };\\n  }\\n\\n  function tokenComment(stream, state) {\\n    var maybeEnd = false, ch;\\n    while (ch = stream.next()) {\\n      if (ch == \\\"\\u002F\\\" && maybeEnd) {\\n        state.tokenize = tokenBase;\\n        break;\\n      }\\n      maybeEnd = (ch == \\\"*\\\");\\n    }\\n    return ret(\\\"comment\\\", \\\"comment\\\");\\n  }\\n\\n  function tokenQuasi(stream, state) {\\n    var escaped = false, next;\\n    while ((next = stream.next()) != null) {\\n      if (!escaped && (next == \\\"`\\\" || next == \\\"$\\\" && stream.eat(\\\"{\\\"))) {\\n        state.tokenize = tokenBase;\\n        break;\\n      }\\n      escaped = !escaped && next == \\\"\\\\\\\\\\\";\\n    }\\n    return ret(\\\"quasi\\\", \\\"string-2\\\", stream.current());\\n  }\\n\\n  var brackets = \\\"([{}])\\\";\\n  \\u002F\\u002F This is a crude lookahead trick to try and notice that we're\\n  \\u002F\\u002F parsing the argument patterns for a fat-arrow function before we\\n  \\u002F\\u002F actually hit the arrow token. It only works if the arrow is on\\n  \\u002F\\u002F the same line as the arguments and there's no strange noise\\n  \\u002F\\u002F (comments) in between. Fallback is to only notice when we hit the\\n  \\u002F\\u002F arrow, and not declare the arguments as locals for the arrow\\n  \\u002F\\u002F body.\\n  function findFatArrow(stream, state) {\\n    if (state.fatArrowAt) state.fatArrowAt = null;\\n    var arrow = stream.string.indexOf(\\\"=\\u003E\\\", stream.start);\\n    if (arrow \\u003C 0) return;\\n\\n    if (isTS) { \\u002F\\u002F Try to skip TypeScript return type declarations after the arguments\\n      var m = \\u002F:\\\\s*(?:\\\\w+(?:\\u003C[^\\u003E]*\\u003E|\\\\[\\\\])?|\\\\{[^}]*\\\\})\\\\s*$\\u002F.exec(stream.string.slice(stream.start, arrow))\\n      if (m) arrow = m.index\\n    }\\n\\n    var depth = 0, sawSomething = false;\\n    for (var pos = arrow - 1; pos \\u003E= 0; --pos) {\\n      var ch = stream.string.charAt(pos);\\n      var bracket = brackets.indexOf(ch);\\n      if (bracket \\u003E= 0 && bracket \\u003C 3) {\\n        if (!depth) { ++pos; break; }\\n        if (--depth == 0) { if (ch == \\\"(\\\") sawSomething = true; break; }\\n      } else if (bracket \\u003E= 3 && bracket \\u003C 6) {\\n        ++depth;\\n      } else if (wordRE.test(ch)) {\\n        sawSomething = true;\\n      } else if (\\u002F[\\\"'\\\\\\u002F]\\u002F.test(ch)) {\\n        return;\\n      } else if (sawSomething && !depth) {\\n        ++pos;\\n        break;\\n      }\\n    }\\n    if (sawSomething && !depth) state.fatArrowAt = pos;\\n  }\\n\\n  \\u002F\\u002F Parser\\n\\n  var atomicTypes = {\\\"atom\\\": true, \\\"number\\\": true, \\\"variable\\\": true, \\\"string\\\": true, \\\"regexp\\\": true, \\\"this\\\": true, \\\"jsonld-keyword\\\": true};\\n\\n  function JSLexical(indented, column, type, align, prev, info) {\\n    this.indented = indented;\\n    this.column = column;\\n    this.type = type;\\n    this.prev = prev;\\n    this.info = info;\\n    if (align != null) this.align = align;\\n  }\\n\\n  function inScope(state, varname) {\\n    for (var v = state.localVars; v; v = v.next)\\n      if (v.name == varname) return true;\\n    for (var cx = state.context; cx; cx = cx.prev) {\\n      for (var v = cx.vars; v; v = v.next)\\n        if (v.name == varname) return true;\\n    }\\n  }\\n\\n  function parseJS(state, style, type, content, stream) {\\n    var cc = state.cc;\\n    \\u002F\\u002F Communicate our context to the combinators.\\n    \\u002F\\u002F (Less wasteful than consing up a hundred closures on every call.)\\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\\n\\n    if (!state.lexical.hasOwnProperty(\\\"align\\\"))\\n      state.lexical.align = true;\\n\\n    while(true) {\\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\\n      if (combinator(type, content)) {\\n        while(cc.length && cc[cc.length - 1].lex)\\n          cc.pop()();\\n        if (cx.marked) return cx.marked;\\n        if (type == \\\"variable\\\" && inScope(state, content)) return \\\"variable-2\\\";\\n        return style;\\n      }\\n    }\\n  }\\n\\n  \\u002F\\u002F Combinator utils\\n\\n  var cx = {state: null, column: null, marked: null, cc: null};\\n  function pass() {\\n    for (var i = arguments.length - 1; i \\u003E= 0; i--) cx.cc.push(arguments[i]);\\n  }\\n  function cont() {\\n    pass.apply(null, arguments);\\n    return true;\\n  }\\n  function register(varname) {\\n    function inList(list) {\\n      for (var v = list; v; v = v.next)\\n        if (v.name == varname) return true;\\n      return false;\\n    }\\n    var state = cx.state;\\n    cx.marked = \\\"def\\\";\\n    if (state.context) {\\n      if (inList(state.localVars)) return;\\n      state.localVars = {name: varname, next: state.localVars};\\n    } else {\\n      if (inList(state.globalVars)) return;\\n      if (parserConfig.globalVars)\\n        state.globalVars = {name: varname, next: state.globalVars};\\n    }\\n  }\\n\\n  function isModifier(name) {\\n    return name == \\\"public\\\" || name == \\\"private\\\" || name == \\\"protected\\\" || name == \\\"abstract\\\" || name == \\\"readonly\\\"\\n  }\\n\\n  \\u002F\\u002F Combinators\\n\\n  var defaultVars = {name: \\\"this\\\", next: {name: \\\"arguments\\\"}};\\n  function pushcontext() {\\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\\n    cx.state.localVars = defaultVars;\\n  }\\n  function popcontext() {\\n    cx.state.localVars = cx.state.context.vars;\\n    cx.state.context = cx.state.context.prev;\\n  }\\n  function pushlex(type, info) {\\n    var result = function() {\\n      var state = cx.state, indent = state.indented;\\n      if (state.lexical.type == \\\"stat\\\") indent = state.lexical.indented;\\n      else for (var outer = state.lexical; outer && outer.type == \\\")\\\" && outer.align; outer = outer.prev)\\n        indent = outer.indented;\\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\\n    };\\n    result.lex = true;\\n    return result;\\n  }\\n  function poplex() {\\n    var state = cx.state;\\n    if (state.lexical.prev) {\\n      if (state.lexical.type == \\\")\\\")\\n        state.indented = state.lexical.indented;\\n      state.lexical = state.lexical.prev;\\n    }\\n  }\\n  poplex.lex = true;\\n\\n  function expect(wanted) {\\n    function exp(type) {\\n      if (type == wanted) return cont();\\n      else if (wanted == \\\";\\\") return pass();\\n      else return cont(exp);\\n    };\\n    return exp;\\n  }\\n\\n  function statement(type, value) {\\n    if (type == \\\"var\\\") return cont(pushlex(\\\"vardef\\\", value.length), vardef, expect(\\\";\\\"), poplex);\\n    if (type == \\\"keyword a\\\") return cont(pushlex(\\\"form\\\"), parenExpr, statement, poplex);\\n    if (type == \\\"keyword b\\\") return cont(pushlex(\\\"form\\\"), statement, poplex);\\n    if (type == \\\"keyword d\\\") return cx.stream.match(\\u002F^\\\\s*$\\u002F, false) ? cont() : cont(pushlex(\\\"stat\\\"), maybeexpression, expect(\\\";\\\"), poplex);\\n    if (type == \\\"debugger\\\") return cont(expect(\\\";\\\"));\\n    if (type == \\\"{\\\") return cont(pushlex(\\\"}\\\"), block, poplex);\\n    if (type == \\\";\\\") return cont();\\n    if (type == \\\"if\\\") {\\n      if (cx.state.lexical.info == \\\"else\\\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\\n        cx.state.cc.pop()();\\n      return cont(pushlex(\\\"form\\\"), parenExpr, statement, poplex, maybeelse);\\n    }\\n    if (type == \\\"function\\\") return cont(functiondef);\\n    if (type == \\\"for\\\") return cont(pushlex(\\\"form\\\"), forspec, statement, poplex);\\n    if (type == \\\"class\\\" || (isTS && value == \\\"interface\\\")) { cx.marked = \\\"keyword\\\"; return cont(pushlex(\\\"form\\\"), className, poplex); }\\n    if (type == \\\"variable\\\") {\\n      if (isTS && value == \\\"declare\\\") {\\n        cx.marked = \\\"keyword\\\"\\n        return cont(statement)\\n      } else if (isTS && (value == \\\"module\\\" || value == \\\"enum\\\" || value == \\\"type\\\") && cx.stream.match(\\u002F^\\\\s*\\\\w\\u002F, false)) {\\n        cx.marked = \\\"keyword\\\"\\n        if (value == \\\"enum\\\") return cont(enumdef);\\n        else if (value == \\\"type\\\") return cont(typeexpr, expect(\\\"operator\\\"), typeexpr, expect(\\\";\\\"));\\n        else return cont(pushlex(\\\"form\\\"), pattern, expect(\\\"{\\\"), pushlex(\\\"}\\\"), block, poplex, poplex)\\n      } else if (isTS && value == \\\"namespace\\\") {\\n        cx.marked = \\\"keyword\\\"\\n        return cont(pushlex(\\\"form\\\"), expression, block, poplex)\\n      } else {\\n        return cont(pushlex(\\\"stat\\\"), maybelabel);\\n      }\\n    }\\n    if (type == \\\"switch\\\") return cont(pushlex(\\\"form\\\"), parenExpr, expect(\\\"{\\\"), pushlex(\\\"}\\\", \\\"switch\\\"),\\n                                      block, poplex, poplex);\\n    if (type == \\\"case\\\") return cont(expression, expect(\\\":\\\"));\\n    if (type == \\\"default\\\") return cont(expect(\\\":\\\"));\\n    if (type == \\\"catch\\\") return cont(pushlex(\\\"form\\\"), pushcontext, expect(\\\"(\\\"), funarg, expect(\\\")\\\"),\\n                                     statement, poplex, popcontext);\\n    if (type == \\\"export\\\") return cont(pushlex(\\\"stat\\\"), afterExport, poplex);\\n    if (type == \\\"import\\\") return cont(pushlex(\\\"stat\\\"), afterImport, poplex);\\n    if (type == \\\"async\\\") return cont(statement)\\n    if (value == \\\"@\\\") return cont(expression, statement)\\n    return pass(pushlex(\\\"stat\\\"), expression, expect(\\\";\\\"), poplex);\\n  }\\n  function expression(type, value) {\\n    return expressionInner(type, value, false);\\n  }\\n  function expressionNoComma(type, value) {\\n    return expressionInner(type, value, true);\\n  }\\n  function parenExpr(type) {\\n    if (type != \\\"(\\\") return pass()\\n    return cont(pushlex(\\\")\\\"), expression, expect(\\\")\\\"), poplex)\\n  }\\n  function expressionInner(type, value, noComma) {\\n    if (cx.state.fatArrowAt == cx.stream.start) {\\n      var body = noComma ? arrowBodyNoComma : arrowBody;\\n      if (type == \\\"(\\\") return cont(pushcontext, pushlex(\\\")\\\"), commasep(funarg, \\\")\\\"), poplex, expect(\\\"=\\u003E\\\"), body, popcontext);\\n      else if (type == \\\"variable\\\") return pass(pushcontext, pattern, expect(\\\"=\\u003E\\\"), body, popcontext);\\n    }\\n\\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\\n    if (type == \\\"function\\\") return cont(functiondef, maybeop);\\n    if (type == \\\"class\\\" || (isTS && value == \\\"interface\\\")) { cx.marked = \\\"keyword\\\"; return cont(pushlex(\\\"form\\\"), classExpression, poplex); }\\n    if (type == \\\"keyword c\\\" || type == \\\"async\\\") return cont(noComma ? expressionNoComma : expression);\\n    if (type == \\\"(\\\") return cont(pushlex(\\\")\\\"), maybeexpression, expect(\\\")\\\"), poplex, maybeop);\\n    if (type == \\\"operator\\\" || type == \\\"spread\\\") return cont(noComma ? expressionNoComma : expression);\\n    if (type == \\\"[\\\") return cont(pushlex(\\\"]\\\"), arrayLiteral, poplex, maybeop);\\n    if (type == \\\"{\\\") return contCommasep(objprop, \\\"}\\\", null, maybeop);\\n    if (type == \\\"quasi\\\") return pass(quasi, maybeop);\\n    if (type == \\\"new\\\") return cont(maybeTarget(noComma));\\n    if (type == \\\"import\\\") return cont(expression);\\n    return cont();\\n  }\\n  function maybeexpression(type) {\\n    if (type.match(\\u002F[;\\\\}\\\\)\\\\],]\\u002F)) return pass();\\n    return pass(expression);\\n  }\\n\\n  function maybeoperatorComma(type, value) {\\n    if (type == \\\",\\\") return cont(expression);\\n    return maybeoperatorNoComma(type, value, false);\\n  }\\n  function maybeoperatorNoComma(type, value, noComma) {\\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\\n    var expr = noComma == false ? expression : expressionNoComma;\\n    if (type == \\\"=\\u003E\\\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\\n    if (type == \\\"operator\\\") {\\n      if (\\u002F\\\\+\\\\+|--\\u002F.test(value) || isTS && value == \\\"!\\\") return cont(me);\\n      if (isTS && value == \\\"\\u003C\\\" && cx.stream.match(\\u002F^([^\\u003E]|\\u003C.*?\\u003E)*\\u003E\\\\s*\\\\(\\u002F, false))\\n        return cont(pushlex(\\\"\\u003E\\\"), commasep(typeexpr, \\\"\\u003E\\\"), poplex, me);\\n      if (value == \\\"?\\\") return cont(expression, expect(\\\":\\\"), expr);\\n      return cont(expr);\\n    }\\n    if (type == \\\"quasi\\\") { return pass(quasi, me); }\\n    if (type == \\\";\\\") return;\\n    if (type == \\\"(\\\") return contCommasep(expressionNoComma, \\\")\\\", \\\"call\\\", me);\\n    if (type == \\\".\\\") return cont(property, me);\\n    if (type == \\\"[\\\") return cont(pushlex(\\\"]\\\"), maybeexpression, expect(\\\"]\\\"), poplex, me);\\n    if (isTS && value == \\\"as\\\") { cx.marked = \\\"keyword\\\"; return cont(typeexpr, me) }\\n    if (type == \\\"regexp\\\") {\\n      cx.state.lastType = cx.marked = \\\"operator\\\"\\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\\n      return cont(expr)\\n    }\\n  }\\n  function quasi(type, value) {\\n    if (type != \\\"quasi\\\") return pass();\\n    if (value.slice(value.length - 2) != \\\"${\\\") return cont(quasi);\\n    return cont(expression, continueQuasi);\\n  }\\n  function continueQuasi(type) {\\n    if (type == \\\"}\\\") {\\n      cx.marked = \\\"string-2\\\";\\n      cx.state.tokenize = tokenQuasi;\\n      return cont(quasi);\\n    }\\n  }\\n  function arrowBody(type) {\\n    findFatArrow(cx.stream, cx.state);\\n    return pass(type == \\\"{\\\" ? statement : expression);\\n  }\\n  function arrowBodyNoComma(type) {\\n    findFatArrow(cx.stream, cx.state);\\n    return pass(type == \\\"{\\\" ? statement : expressionNoComma);\\n  }\\n  function maybeTarget(noComma) {\\n    return function(type) {\\n      if (type == \\\".\\\") return cont(noComma ? targetNoComma : target);\\n      else if (type == \\\"variable\\\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\\n      else return pass(noComma ? expressionNoComma : expression);\\n    };\\n  }\\n  function target(_, value) {\\n    if (value == \\\"target\\\") { cx.marked = \\\"keyword\\\"; return cont(maybeoperatorComma); }\\n  }\\n  function targetNoComma(_, value) {\\n    if (value == \\\"target\\\") { cx.marked = \\\"keyword\\\"; return cont(maybeoperatorNoComma); }\\n  }\\n  function maybelabel(type) {\\n    if (type == \\\":\\\") return cont(poplex, statement);\\n    return pass(maybeoperatorComma, expect(\\\";\\\"), poplex);\\n  }\\n  function property(type) {\\n    if (type == \\\"variable\\\") {cx.marked = \\\"property\\\"; return cont();}\\n  }\\n  function objprop(type, value) {\\n    if (type == \\\"async\\\") {\\n      cx.marked = \\\"property\\\";\\n      return cont(objprop);\\n    } else if (type == \\\"variable\\\" || cx.style == \\\"keyword\\\") {\\n      cx.marked = \\\"property\\\";\\n      if (value == \\\"get\\\" || value == \\\"set\\\") return cont(getterSetter);\\n      var m \\u002F\\u002F Work around fat-arrow-detection complication for detecting typescript typed arrow params\\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(\\u002F^\\\\s*:\\\\s*\\u002F, false)))\\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\\n      return cont(afterprop);\\n    } else if (type == \\\"number\\\" || type == \\\"string\\\") {\\n      cx.marked = jsonldMode ? \\\"property\\\" : (cx.style + \\\" property\\\");\\n      return cont(afterprop);\\n    } else if (type == \\\"jsonld-keyword\\\") {\\n      return cont(afterprop);\\n    } else if (isTS && isModifier(value)) {\\n      cx.marked = \\\"keyword\\\"\\n      return cont(objprop)\\n    } else if (type == \\\"[\\\") {\\n      return cont(expression, maybetype, expect(\\\"]\\\"), afterprop);\\n    } else if (type == \\\"spread\\\") {\\n      return cont(expressionNoComma, afterprop);\\n    } else if (value == \\\"*\\\") {\\n      cx.marked = \\\"keyword\\\";\\n      return cont(objprop);\\n    } else if (type == \\\":\\\") {\\n      return pass(afterprop)\\n    }\\n  }\\n  function getterSetter(type) {\\n    if (type != \\\"variable\\\") return pass(afterprop);\\n    cx.marked = \\\"property\\\";\\n    return cont(functiondef);\\n  }\\n  function afterprop(type) {\\n    if (type == \\\":\\\") return cont(expressionNoComma);\\n    if (type == \\\"(\\\") return pass(functiondef);\\n  }\\n  function commasep(what, end, sep) {\\n    function proceed(type, value) {\\n      if (sep ? sep.indexOf(type) \\u003E -1 : type == \\\",\\\") {\\n        var lex = cx.state.lexical;\\n        if (lex.info == \\\"call\\\") lex.pos = (lex.pos || 0) + 1;\\n        return cont(function(type, value) {\\n          if (type == end || value == end) return pass()\\n          return pass(what)\\n        }, proceed);\\n      }\\n      if (type == end || value == end) return cont();\\n      return cont(expect(end));\\n    }\\n    return function(type, value) {\\n      if (type == end || value == end) return cont();\\n      return pass(what, proceed);\\n    };\\n  }\\n  function contCommasep(what, end, info) {\\n    for (var i = 3; i \\u003C arguments.length; i++)\\n      cx.cc.push(arguments[i]);\\n    return cont(pushlex(end, info), commasep(what, end), poplex);\\n  }\\n  function block(type) {\\n    if (type == \\\"}\\\") return cont();\\n    return pass(statement, block);\\n  }\\n  function maybetype(type, value) {\\n    if (isTS) {\\n      if (type == \\\":\\\") return cont(typeexpr);\\n      if (value == \\\"?\\\") return cont(maybetype);\\n    }\\n  }\\n  function mayberettype(type) {\\n    if (isTS && type == \\\":\\\") {\\n      if (cx.stream.match(\\u002F^\\\\s*\\\\w+\\\\s+is\\\\b\\u002F, false)) return cont(expression, isKW, typeexpr)\\n      else return cont(typeexpr)\\n    }\\n  }\\n  function isKW(_, value) {\\n    if (value == \\\"is\\\") {\\n      cx.marked = \\\"keyword\\\"\\n      return cont()\\n    }\\n  }\\n  function typeexpr(type, value) {\\n    if (type == \\\"variable\\\" || value == \\\"void\\\") {\\n      if (value == \\\"keyof\\\") {\\n        cx.marked = \\\"keyword\\\"\\n        return cont(typeexpr)\\n      } else {\\n        cx.marked = \\\"type\\\"\\n        return cont(afterType)\\n      }\\n    }\\n    if (type == \\\"string\\\" || type == \\\"number\\\" || type == \\\"atom\\\") return cont(afterType);\\n    if (type == \\\"[\\\") return cont(pushlex(\\\"]\\\"), commasep(typeexpr, \\\"]\\\", \\\",\\\"), poplex, afterType)\\n    if (type == \\\"{\\\") return cont(pushlex(\\\"}\\\"), commasep(typeprop, \\\"}\\\", \\\",;\\\"), poplex, afterType)\\n    if (type == \\\"(\\\") return cont(commasep(typearg, \\\")\\\"), maybeReturnType)\\n  }\\n  function maybeReturnType(type) {\\n    if (type == \\\"=\\u003E\\\") return cont(typeexpr)\\n  }\\n  function typeprop(type, value) {\\n    if (type == \\\"variable\\\" || cx.style == \\\"keyword\\\") {\\n      cx.marked = \\\"property\\\"\\n      return cont(typeprop)\\n    } else if (value == \\\"?\\\") {\\n      return cont(typeprop)\\n    } else if (type == \\\":\\\") {\\n      return cont(typeexpr)\\n    } else if (type == \\\"[\\\") {\\n      return cont(expression, maybetype, expect(\\\"]\\\"), typeprop)\\n    }\\n  }\\n  function typearg(type) {\\n    if (type == \\\"variable\\\") return cont(typearg)\\n    else if (type == \\\":\\\") return cont(typeexpr)\\n  }\\n  function afterType(type, value) {\\n    if (value == \\\"\\u003C\\\") return cont(pushlex(\\\"\\u003E\\\"), commasep(typeexpr, \\\"\\u003E\\\"), poplex, afterType)\\n    if (value == \\\"|\\\" || type == \\\".\\\" || value == \\\"&\\\") return cont(typeexpr)\\n    if (type == \\\"[\\\") return cont(expect(\\\"]\\\"), afterType)\\n    if (value == \\\"extends\\\" || value == \\\"implements\\\") { cx.marked = \\\"keyword\\\"; return cont(typeexpr) }\\n  }\\n  function maybeTypeArgs(_, value) {\\n    if (value == \\\"\\u003C\\\") return cont(pushlex(\\\"\\u003E\\\"), commasep(typeexpr, \\\"\\u003E\\\"), poplex, afterType)\\n  }\\n  function typeparam() {\\n    return pass(typeexpr, maybeTypeDefault)\\n  }\\n  function maybeTypeDefault(_, value) {\\n    if (value == \\\"=\\\") return cont(typeexpr)\\n  }\\n  function vardef(_, value) {\\n    if (value == \\\"enum\\\") {cx.marked = \\\"keyword\\\"; return cont(enumdef)}\\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\\n  }\\n  function pattern(type, value) {\\n    if (isTS && isModifier(value)) { cx.marked = \\\"keyword\\\"; return cont(pattern) }\\n    if (type == \\\"variable\\\") { register(value); return cont(); }\\n    if (type == \\\"spread\\\") return cont(pattern);\\n    if (type == \\\"[\\\") return contCommasep(pattern, \\\"]\\\");\\n    if (type == \\\"{\\\") return contCommasep(proppattern, \\\"}\\\");\\n  }\\n  function proppattern(type, value) {\\n    if (type == \\\"variable\\\" && !cx.stream.match(\\u002F^\\\\s*:\\u002F, false)) {\\n      register(value);\\n      return cont(maybeAssign);\\n    }\\n    if (type == \\\"variable\\\") cx.marked = \\\"property\\\";\\n    if (type == \\\"spread\\\") return cont(pattern);\\n    if (type == \\\"}\\\") return pass();\\n    return cont(expect(\\\":\\\"), pattern, maybeAssign);\\n  }\\n  function maybeAssign(_type, value) {\\n    if (value == \\\"=\\\") return cont(expressionNoComma);\\n  }\\n  function vardefCont(type) {\\n    if (type == \\\",\\\") return cont(vardef);\\n  }\\n  function maybeelse(type, value) {\\n    if (type == \\\"keyword b\\\" && value == \\\"else\\\") return cont(pushlex(\\\"form\\\", \\\"else\\\"), statement, poplex);\\n  }\\n  function forspec(type, value) {\\n    if (value == \\\"await\\\") return cont(forspec);\\n    if (type == \\\"(\\\") return cont(pushlex(\\\")\\\"), forspec1, expect(\\\")\\\"), poplex);\\n  }\\n  function forspec1(type) {\\n    if (type == \\\"var\\\") return cont(vardef, expect(\\\";\\\"), forspec2);\\n    if (type == \\\";\\\") return cont(forspec2);\\n    if (type == \\\"variable\\\") return cont(formaybeinof);\\n    return pass(expression, expect(\\\";\\\"), forspec2);\\n  }\\n  function formaybeinof(_type, value) {\\n    if (value == \\\"in\\\" || value == \\\"of\\\") { cx.marked = \\\"keyword\\\"; return cont(expression); }\\n    return cont(maybeoperatorComma, forspec2);\\n  }\\n  function forspec2(type, value) {\\n    if (type == \\\";\\\") return cont(forspec3);\\n    if (value == \\\"in\\\" || value == \\\"of\\\") { cx.marked = \\\"keyword\\\"; return cont(expression); }\\n    return pass(expression, expect(\\\";\\\"), forspec3);\\n  }\\n  function forspec3(type) {\\n    if (type != \\\")\\\") cont(expression);\\n  }\\n  function functiondef(type, value) {\\n    if (value == \\\"*\\\") {cx.marked = \\\"keyword\\\"; return cont(functiondef);}\\n    if (type == \\\"variable\\\") {register(value); return cont(functiondef);}\\n    if (type == \\\"(\\\") return cont(pushcontext, pushlex(\\\")\\\"), commasep(funarg, \\\")\\\"), poplex, mayberettype, statement, popcontext);\\n    if (isTS && value == \\\"\\u003C\\\") return cont(pushlex(\\\"\\u003E\\\"), commasep(typeparam, \\\"\\u003E\\\"), poplex, functiondef)\\n  }\\n  function funarg(type, value) {\\n    if (value == \\\"@\\\") cont(expression, funarg)\\n    if (type == \\\"spread\\\") return cont(funarg);\\n    if (isTS && isModifier(value)) { cx.marked = \\\"keyword\\\"; return cont(funarg); }\\n    return pass(pattern, maybetype, maybeAssign);\\n  }\\n  function classExpression(type, value) {\\n    \\u002F\\u002F Class expressions may have an optional name.\\n    if (type == \\\"variable\\\") return className(type, value);\\n    return classNameAfter(type, value);\\n  }\\n  function className(type, value) {\\n    if (type == \\\"variable\\\") {register(value); return cont(classNameAfter);}\\n  }\\n  function classNameAfter(type, value) {\\n    if (value == \\\"\\u003C\\\") return cont(pushlex(\\\"\\u003E\\\"), commasep(typeparam, \\\"\\u003E\\\"), poplex, classNameAfter)\\n    if (value == \\\"extends\\\" || value == \\\"implements\\\" || (isTS && type == \\\",\\\")) {\\n      if (value == \\\"implements\\\") cx.marked = \\\"keyword\\\";\\n      return cont(isTS ? typeexpr : expression, classNameAfter);\\n    }\\n    if (type == \\\"{\\\") return cont(pushlex(\\\"}\\\"), classBody, poplex);\\n  }\\n  function classBody(type, value) {\\n    if (type == \\\"async\\\" ||\\n        (type == \\\"variable\\\" &&\\n         (value == \\\"static\\\" || value == \\\"get\\\" || value == \\\"set\\\" || (isTS && isModifier(value))) &&\\n         cx.stream.match(\\u002F^\\\\s+[\\\\w$\\\\xa1-\\\\uffff]\\u002F, false))) {\\n      cx.marked = \\\"keyword\\\";\\n      return cont(classBody);\\n    }\\n    if (type == \\\"variable\\\" || cx.style == \\\"keyword\\\") {\\n      cx.marked = \\\"property\\\";\\n      return cont(isTS ? classfield : functiondef, classBody);\\n    }\\n    if (type == \\\"[\\\")\\n      return cont(expression, maybetype, expect(\\\"]\\\"), isTS ? classfield : functiondef, classBody)\\n    if (value == \\\"*\\\") {\\n      cx.marked = \\\"keyword\\\";\\n      return cont(classBody);\\n    }\\n    if (type == \\\";\\\") return cont(classBody);\\n    if (type == \\\"}\\\") return cont();\\n    if (value == \\\"@\\\") return cont(expression, classBody)\\n  }\\n  function classfield(type, value) {\\n    if (value == \\\"?\\\") return cont(classfield)\\n    if (type == \\\":\\\") return cont(typeexpr, maybeAssign)\\n    if (value == \\\"=\\\") return cont(expressionNoComma)\\n    return pass(functiondef)\\n  }\\n  function afterExport(type, value) {\\n    if (value == \\\"*\\\") { cx.marked = \\\"keyword\\\"; return cont(maybeFrom, expect(\\\";\\\")); }\\n    if (value == \\\"default\\\") { cx.marked = \\\"keyword\\\"; return cont(expression, expect(\\\";\\\")); }\\n    if (type == \\\"{\\\") return cont(commasep(exportField, \\\"}\\\"), maybeFrom, expect(\\\";\\\"));\\n    return pass(statement);\\n  }\\n  function exportField(type, value) {\\n    if (value == \\\"as\\\") { cx.marked = \\\"keyword\\\"; return cont(expect(\\\"variable\\\")); }\\n    if (type == \\\"variable\\\") return pass(expressionNoComma, exportField);\\n  }\\n  function afterImport(type) {\\n    if (type == \\\"string\\\") return cont();\\n    if (type == \\\"(\\\") return pass(expression);\\n    return pass(importSpec, maybeMoreImports, maybeFrom);\\n  }\\n  function importSpec(type, value) {\\n    if (type == \\\"{\\\") return contCommasep(importSpec, \\\"}\\\");\\n    if (type == \\\"variable\\\") register(value);\\n    if (value == \\\"*\\\") cx.marked = \\\"keyword\\\";\\n    return cont(maybeAs);\\n  }\\n  function maybeMoreImports(type) {\\n    if (type == \\\",\\\") return cont(importSpec, maybeMoreImports)\\n  }\\n  function maybeAs(_type, value) {\\n    if (value == \\\"as\\\") { cx.marked = \\\"keyword\\\"; return cont(importSpec); }\\n  }\\n  function maybeFrom(_type, value) {\\n    if (value == \\\"from\\\") { cx.marked = \\\"keyword\\\"; return cont(expression); }\\n  }\\n  function arrayLiteral(type) {\\n    if (type == \\\"]\\\") return cont();\\n    return pass(commasep(expressionNoComma, \\\"]\\\"));\\n  }\\n  function enumdef() {\\n    return pass(pushlex(\\\"form\\\"), pattern, expect(\\\"{\\\"), pushlex(\\\"}\\\"), commasep(enummember, \\\"}\\\"), poplex, poplex)\\n  }\\n  function enummember() {\\n    return pass(pattern, maybeAssign);\\n  }\\n\\n  function isContinuedStatement(state, textAfter) {\\n    return state.lastType == \\\"operator\\\" || state.lastType == \\\",\\\" ||\\n      isOperatorChar.test(textAfter.charAt(0)) ||\\n      \\u002F[,.]\\u002F.test(textAfter.charAt(0));\\n  }\\n\\n  function expressionAllowed(stream, state, backUp) {\\n    return state.tokenize == tokenBase &&\\n      \\u002F^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\\\[{}\\\\(,;:]|=\\u003E)$\\u002F.test(state.lastType) ||\\n      (state.lastType == \\\"quasi\\\" && \\u002F\\\\{\\\\s*$\\u002F.test(stream.string.slice(0, stream.pos - (backUp || 0))))\\n  }\\n\\n  \\u002F\\u002F Interface\\n\\n  return {\\n    startState: function(basecolumn) {\\n      var state = {\\n        tokenize: tokenBase,\\n        lastType: \\\"sof\\\",\\n        cc: [],\\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \\\"block\\\", false),\\n        localVars: parserConfig.localVars,\\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\\n        indented: basecolumn || 0\\n      };\\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \\\"object\\\")\\n        state.globalVars = parserConfig.globalVars;\\n      return state;\\n    },\\n\\n    token: function(stream, state) {\\n      if (stream.sol()) {\\n        if (!state.lexical.hasOwnProperty(\\\"align\\\"))\\n          state.lexical.align = false;\\n        state.indented = stream.indentation();\\n        findFatArrow(stream, state);\\n      }\\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\\n      var style = state.tokenize(stream, state);\\n      if (type == \\\"comment\\\") return style;\\n      state.lastType = type == \\\"operator\\\" && (content == \\\"++\\\" || content == \\\"--\\\") ? \\\"incdec\\\" : type;\\n      return parseJS(state, style, type, content, stream);\\n    },\\n\\n    indent: function(state, textAfter) {\\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\\n      if (state.tokenize != tokenBase) return 0;\\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\\n      \\u002F\\u002F Kludge to prevent 'maybelse' from blocking lexical scope pops\\n      if (!\\u002F^\\\\s*else\\\\b\\u002F.test(textAfter)) for (var i = state.cc.length - 1; i \\u003E= 0; --i) {\\n        var c = state.cc[i];\\n        if (c == poplex) lexical = lexical.prev;\\n        else if (c != maybeelse) break;\\n      }\\n      while ((lexical.type == \\\"stat\\\" || lexical.type == \\\"form\\\") &&\\n             (firstChar == \\\"}\\\" || ((top = state.cc[state.cc.length - 1]) &&\\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\\n                                   !\\u002F^[,\\\\.=+\\\\-*:?[\\\\(]\\u002F.test(textAfter))))\\n        lexical = lexical.prev;\\n      if (statementIndent && lexical.type == \\\")\\\" && lexical.prev.type == \\\"stat\\\")\\n        lexical = lexical.prev;\\n      var type = lexical.type, closing = firstChar == type;\\n\\n      if (type == \\\"vardef\\\") return lexical.indented + (state.lastType == \\\"operator\\\" || state.lastType == \\\",\\\" ? lexical.info + 1 : 0);\\n      else if (type == \\\"form\\\" && firstChar == \\\"{\\\") return lexical.indented;\\n      else if (type == \\\"form\\\") return lexical.indented + indentUnit;\\n      else if (type == \\\"stat\\\")\\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\\n      else if (lexical.info == \\\"switch\\\" && !closing && parserConfig.doubleIndentSwitch != false)\\n        return lexical.indented + (\\u002F^(?:case|default)\\\\b\\u002F.test(textAfter) ? indentUnit : 2 * indentUnit);\\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\\n      else return lexical.indented + (closing ? 0 : indentUnit);\\n    },\\n\\n    electricInput: \\u002F^\\\\s*(?:case .*?:|default:|\\\\{|\\\\})$\\u002F,\\n    blockCommentStart: jsonMode ? null : \\\"\\u002F*\\\",\\n    blockCommentEnd: jsonMode ? null : \\\"*\\u002F\\\",\\n    blockCommentContinue: jsonMode ? null : \\\" * \\\",\\n    lineComment: jsonMode ? null : \\\"\\u002F\\u002F\\\",\\n    fold: \\\"brace\\\",\\n    closeBrackets: \\\"()[]{}''\\\\\\\"\\\\\\\"``\\\",\\n\\n    helperType: jsonMode ? \\\"json\\\" : \\\"javascript\\\",\\n    jsonldMode: jsonldMode,\\n    jsonMode: jsonMode,\\n\\n    expressionAllowed: expressionAllowed,\\n\\n    skipExpression: function(state) {\\n      var top = state.cc[state.cc.length - 1]\\n      if (top == expression || top == expressionNoComma) state.cc.pop()\\n    }\\n  };\\n});\\n\\nCodeMirror.registerHelper(\\\"wordChars\\\", \\\"javascript\\\", \\u002F[\\\\w$]\\u002F);\\n\\nCodeMirror.defineMIME(\\\"text\\u002Fjavascript\\\", \\\"javascript\\\");\\nCodeMirror.defineMIME(\\\"text\\u002Fecmascript\\\", \\\"javascript\\\");\\nCodeMirror.defineMIME(\\\"application\\u002Fjavascript\\\", \\\"javascript\\\");\\nCodeMirror.defineMIME(\\\"application\\u002Fx-javascript\\\", \\\"javascript\\\");\\nCodeMirror.defineMIME(\\\"application\\u002Fecmascript\\\", \\\"javascript\\\");\\nCodeMirror.defineMIME(\\\"application\\u002Fjson\\\", {name: \\\"javascript\\\", json: true});\\nCodeMirror.defineMIME(\\\"application\\u002Fx-json\\\", {name: \\\"javascript\\\", json: true});\\nCodeMirror.defineMIME(\\\"application\\u002Fld+json\\\", {name: \\\"javascript\\\", jsonld: true});\\nCodeMirror.defineMIME(\\\"text\\u002Ftypescript\\\", { name: \\\"javascript\\\", typescript: true });\\nCodeMirror.defineMIME(\\\"application\\u002Ftypescript\\\", { name: \\\"javascript\\\", typescript: true });\\n\\n});\\n\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Fmode\\u002Fjsx\\u002Fjsx.js\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F CodeMirror, copyright (c) by Marijn Haverbeke and others\\n\\u002F\\u002F Distributed under an MIT license: http:\\u002F\\u002Fcodemirror.net\\u002FLICENSE\\n\\n(function(mod) {\\n  if (true) \\u002F\\u002F CommonJS\\n    mod(__webpack_require__(\\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.js\\\"), __webpack_require__(\\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Fmode\\u002Fxml\\u002Fxml.js\\\"), __webpack_require__(\\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Fmode\\u002Fjavascript\\u002Fjavascript.js\\\"))\\n  else if (typeof define == \\\"function\\\" && define.amd) \\u002F\\u002F AMD\\n    define([\\\"..\\u002F..\\u002Flib\\u002Fcodemirror\\\", \\\"..\\u002Fxml\\u002Fxml\\\", \\\"..\\u002Fjavascript\\u002Fjavascript\\\"], mod)\\n  else \\u002F\\u002F Plain browser env\\n    mod(CodeMirror)\\n})(function(CodeMirror) {\\n  \\\"use strict\\\"\\n\\n  \\u002F\\u002F Depth means the amount of open braces in JS context, in XML\\n  \\u002F\\u002F context 0 means not in tag, 1 means in tag, and 2 means in tag\\n  \\u002F\\u002F and js block comment.\\n  function Context(state, mode, depth, prev) {\\n    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev\\n  }\\n\\n  function copyContext(context) {\\n    return new Context(CodeMirror.copyState(context.mode, context.state),\\n                       context.mode,\\n                       context.depth,\\n                       context.prev && copyContext(context.prev))\\n  }\\n\\n  CodeMirror.defineMode(\\\"jsx\\\", function(config, modeConfig) {\\n    var xmlMode = CodeMirror.getMode(config, {name: \\\"xml\\\", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true})\\n    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || \\\"javascript\\\")\\n\\n    function flatXMLIndent(state) {\\n      var tagName = state.tagName\\n      state.tagName = null\\n      var result = xmlMode.indent(state, \\\"\\\")\\n      state.tagName = tagName\\n      return result\\n    }\\n\\n    function token(stream, state) {\\n      if (state.context.mode == xmlMode)\\n        return xmlToken(stream, state, state.context)\\n      else\\n        return jsToken(stream, state, state.context)\\n    }\\n\\n    function xmlToken(stream, state, cx) {\\n      if (cx.depth == 2) { \\u002F\\u002F Inside a JS \\u002F* *\\u002F comment\\n        if (stream.match(\\u002F^.*?\\\\*\\\\\\u002F\\u002F)) cx.depth = 1\\n        else stream.skipToEnd()\\n        return \\\"comment\\\"\\n      }\\n\\n      if (stream.peek() == \\\"{\\\") {\\n        xmlMode.skipAttribute(cx.state)\\n\\n        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context\\n        \\u002F\\u002F If JS starts on same line as tag\\n        if (xmlContext && stream.match(\\u002F^[^\\u003E]*\\u003E\\\\s*$\\u002F, false)) {\\n          while (xmlContext.prev && !xmlContext.startOfLine)\\n            xmlContext = xmlContext.prev\\n          \\u002F\\u002F If tag starts the line, use XML indentation level\\n          if (xmlContext.startOfLine) indent -= config.indentUnit\\n          \\u002F\\u002F Else use JS indentation level\\n          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented\\n        \\u002F\\u002F Else if inside of tag\\n        } else if (cx.depth == 1) {\\n          indent += config.indentUnit\\n        }\\n\\n        state.context = new Context(CodeMirror.startState(jsMode, indent),\\n                                    jsMode, 0, state.context)\\n        return null\\n      }\\n\\n      if (cx.depth == 1) { \\u002F\\u002F Inside of tag\\n        if (stream.peek() == \\\"\\u003C\\\") { \\u002F\\u002F Tag inside of tag\\n          xmlMode.skipAttribute(cx.state)\\n          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),\\n                                      xmlMode, 0, state.context)\\n          return null\\n        } else if (stream.match(\\\"\\u002F\\u002F\\\")) {\\n          stream.skipToEnd()\\n          return \\\"comment\\\"\\n        } else if (stream.match(\\\"\\u002F*\\\")) {\\n          cx.depth = 2\\n          return token(stream, state)\\n        }\\n      }\\n\\n      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop\\n      if (\\u002F\\\\btag\\\\b\\u002F.test(style)) {\\n        if (\\u002F\\u003E$\\u002F.test(cur)) {\\n          if (cx.state.context) cx.depth = 0\\n          else state.context = state.context.prev\\n        } else if (\\u002F^\\u003C\\u002F.test(cur)) {\\n          cx.depth = 1\\n        }\\n      } else if (!style && (stop = cur.indexOf(\\\"{\\\")) \\u003E -1) {\\n        stream.backUp(cur.length - stop)\\n      }\\n      return style\\n    }\\n\\n    function jsToken(stream, state, cx) {\\n      if (stream.peek() == \\\"\\u003C\\\" && jsMode.expressionAllowed(stream, cx.state)) {\\n        jsMode.skipExpression(cx.state)\\n        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, \\\"\\\")),\\n                                    xmlMode, 0, state.context)\\n        return null\\n      }\\n\\n      var style = jsMode.token(stream, cx.state)\\n      if (!style && cx.depth != null) {\\n        var cur = stream.current()\\n        if (cur == \\\"{\\\") {\\n          cx.depth++\\n        } else if (cur == \\\"}\\\") {\\n          if (--cx.depth == 0) state.context = state.context.prev\\n        }\\n      }\\n      return style\\n    }\\n\\n    return {\\n      startState: function() {\\n        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}\\n      },\\n\\n      copyState: function(state) {\\n        return {context: copyContext(state.context)}\\n      },\\n\\n      token: token,\\n\\n      indent: function(state, textAfter, fullLine) {\\n        return state.context.mode.indent(state.context.state, textAfter, fullLine)\\n      },\\n\\n      innerMode: function(state) {\\n        return state.context\\n      }\\n    }\\n  }, \\\"xml\\\", \\\"javascript\\\")\\n\\n  CodeMirror.defineMIME(\\\"text\\u002Fjsx\\\", \\\"jsx\\\")\\n  CodeMirror.defineMIME(\\\"text\\u002Ftypescript-jsx\\\", {name: \\\"jsx\\\", base: {name: \\\"javascript\\\", typescript: true}})\\n});\\n\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Fmode\\u002Fxml\\u002Fxml.js\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F CodeMirror, copyright (c) by Marijn Haverbeke and others\\n\\u002F\\u002F Distributed under an MIT license: http:\\u002F\\u002Fcodemirror.net\\u002FLICENSE\\n\\n(function(mod) {\\n  if (true) \\u002F\\u002F CommonJS\\n    mod(__webpack_require__(\\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.js\\\"));\\n  else if (typeof define == \\\"function\\\" && define.amd) \\u002F\\u002F AMD\\n    define([\\\"..\\u002F..\\u002Flib\\u002Fcodemirror\\\"], mod);\\n  else \\u002F\\u002F Plain browser env\\n    mod(CodeMirror);\\n})(function(CodeMirror) {\\n\\\"use strict\\\";\\n\\nvar htmlConfig = {\\n  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\\n                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\\n                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\\n                    'track': true, 'wbr': true, 'menuitem': true},\\n  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\\n                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\\n                     'th': true, 'tr': true},\\n  contextGrabbers: {\\n    'dd': {'dd': true, 'dt': true},\\n    'dt': {'dd': true, 'dt': true},\\n    'li': {'li': true},\\n    'option': {'option': true, 'optgroup': true},\\n    'optgroup': {'optgroup': true},\\n    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\\n          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\\n          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\\n          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\\n          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\\n    'rp': {'rp': true, 'rt': true},\\n    'rt': {'rp': true, 'rt': true},\\n    'tbody': {'tbody': true, 'tfoot': true},\\n    'td': {'td': true, 'th': true},\\n    'tfoot': {'tbody': true},\\n    'th': {'td': true, 'th': true},\\n    'thead': {'tbody': true, 'tfoot': true},\\n    'tr': {'tr': true}\\n  },\\n  doNotIndent: {\\\"pre\\\": true},\\n  allowUnquoted: true,\\n  allowMissing: true,\\n  caseFold: true\\n}\\n\\nvar xmlConfig = {\\n  autoSelfClosers: {},\\n  implicitlyClosed: {},\\n  contextGrabbers: {},\\n  doNotIndent: {},\\n  allowUnquoted: false,\\n  allowMissing: false,\\n  allowMissingTagName: false,\\n  caseFold: false\\n}\\n\\nCodeMirror.defineMode(\\\"xml\\\", function(editorConf, config_) {\\n  var indentUnit = editorConf.indentUnit\\n  var config = {}\\n  var defaults = config_.htmlMode ? htmlConfig : xmlConfig\\n  for (var prop in defaults) config[prop] = defaults[prop]\\n  for (var prop in config_) config[prop] = config_[prop]\\n\\n  \\u002F\\u002F Return variables for tokenizers\\n  var type, setStyle;\\n\\n  function inText(stream, state) {\\n    function chain(parser) {\\n      state.tokenize = parser;\\n      return parser(stream, state);\\n    }\\n\\n    var ch = stream.next();\\n    if (ch == \\\"\\u003C\\\") {\\n      if (stream.eat(\\\"!\\\")) {\\n        if (stream.eat(\\\"[\\\")) {\\n          if (stream.match(\\\"CDATA[\\\")) return chain(inBlock(\\\"atom\\\", \\\"]]\\u003E\\\"));\\n          else return null;\\n        } else if (stream.match(\\\"--\\\")) {\\n          return chain(inBlock(\\\"comment\\\", \\\"--\\u003E\\\"));\\n        } else if (stream.match(\\\"DOCTYPE\\\", true, true)) {\\n          stream.eatWhile(\\u002F[\\\\w\\\\._\\\\-]\\u002F);\\n          return chain(doctype(1));\\n        } else {\\n          return null;\\n        }\\n      } else if (stream.eat(\\\"?\\\")) {\\n        stream.eatWhile(\\u002F[\\\\w\\\\._\\\\-]\\u002F);\\n        state.tokenize = inBlock(\\\"meta\\\", \\\"?\\u003E\\\");\\n        return \\\"meta\\\";\\n      } else {\\n        type = stream.eat(\\\"\\u002F\\\") ? \\\"closeTag\\\" : \\\"openTag\\\";\\n        state.tokenize = inTag;\\n        return \\\"tag bracket\\\";\\n      }\\n    } else if (ch == \\\"&\\\") {\\n      var ok;\\n      if (stream.eat(\\\"#\\\")) {\\n        if (stream.eat(\\\"x\\\")) {\\n          ok = stream.eatWhile(\\u002F[a-fA-F\\\\d]\\u002F) && stream.eat(\\\";\\\");\\n        } else {\\n          ok = stream.eatWhile(\\u002F[\\\\d]\\u002F) && stream.eat(\\\";\\\");\\n        }\\n      } else {\\n        ok = stream.eatWhile(\\u002F[\\\\w\\\\.\\\\-:]\\u002F) && stream.eat(\\\";\\\");\\n      }\\n      return ok ? \\\"atom\\\" : \\\"error\\\";\\n    } else {\\n      stream.eatWhile(\\u002F[^&\\u003C]\\u002F);\\n      return null;\\n    }\\n  }\\n  inText.isInText = true;\\n\\n  function inTag(stream, state) {\\n    var ch = stream.next();\\n    if (ch == \\\"\\u003E\\\" || (ch == \\\"\\u002F\\\" && stream.eat(\\\"\\u003E\\\"))) {\\n      state.tokenize = inText;\\n      type = ch == \\\"\\u003E\\\" ? \\\"endTag\\\" : \\\"selfcloseTag\\\";\\n      return \\\"tag bracket\\\";\\n    } else if (ch == \\\"=\\\") {\\n      type = \\\"equals\\\";\\n      return null;\\n    } else if (ch == \\\"\\u003C\\\") {\\n      state.tokenize = inText;\\n      state.state = baseState;\\n      state.tagName = state.tagStart = null;\\n      var next = state.tokenize(stream, state);\\n      return next ? next + \\\" tag error\\\" : \\\"tag error\\\";\\n    } else if (\\u002F[\\\\'\\\\\\\"]\\u002F.test(ch)) {\\n      state.tokenize = inAttribute(ch);\\n      state.stringStartCol = stream.column();\\n      return state.tokenize(stream, state);\\n    } else {\\n      stream.match(\\u002F^[^\\\\s\\\\u00a0=\\u003C\\u003E\\\\\\\"\\\\']*[^\\\\s\\\\u00a0=\\u003C\\u003E\\\\\\\"\\\\'\\\\\\u002F]\\u002F);\\n      return \\\"word\\\";\\n    }\\n  }\\n\\n  function inAttribute(quote) {\\n    var closure = function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.next() == quote) {\\n          state.tokenize = inTag;\\n          break;\\n        }\\n      }\\n      return \\\"string\\\";\\n    };\\n    closure.isInAttribute = true;\\n    return closure;\\n  }\\n\\n  function inBlock(style, terminator) {\\n    return function(stream, state) {\\n      while (!stream.eol()) {\\n        if (stream.match(terminator)) {\\n          state.tokenize = inText;\\n          break;\\n        }\\n        stream.next();\\n      }\\n      return style;\\n    };\\n  }\\n  function doctype(depth) {\\n    return function(stream, state) {\\n      var ch;\\n      while ((ch = stream.next()) != null) {\\n        if (ch == \\\"\\u003C\\\") {\\n          state.tokenize = doctype(depth + 1);\\n          return state.tokenize(stream, state);\\n        } else if (ch == \\\"\\u003E\\\") {\\n          if (depth == 1) {\\n            state.tokenize = inText;\\n            break;\\n          } else {\\n            state.tokenize = doctype(depth - 1);\\n            return state.tokenize(stream, state);\\n          }\\n        }\\n      }\\n      return \\\"meta\\\";\\n    };\\n  }\\n\\n  function Context(state, tagName, startOfLine) {\\n    this.prev = state.context;\\n    this.tagName = tagName;\\n    this.indent = state.indented;\\n    this.startOfLine = startOfLine;\\n    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\\n      this.noIndent = true;\\n  }\\n  function popContext(state) {\\n    if (state.context) state.context = state.context.prev;\\n  }\\n  function maybePopContext(state, nextTagName) {\\n    var parentTagName;\\n    while (true) {\\n      if (!state.context) {\\n        return;\\n      }\\n      parentTagName = state.context.tagName;\\n      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||\\n          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\\n        return;\\n      }\\n      popContext(state);\\n    }\\n  }\\n\\n  function baseState(type, stream, state) {\\n    if (type == \\\"openTag\\\") {\\n      state.tagStart = stream.column();\\n      return tagNameState;\\n    } else if (type == \\\"closeTag\\\") {\\n      return closeTagNameState;\\n    } else {\\n      return baseState;\\n    }\\n  }\\n  function tagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      state.tagName = stream.current();\\n      setStyle = \\\"tag\\\";\\n      return attrState;\\n    } else if (config.allowMissingTagName && type == \\\"endTag\\\") {\\n      setStyle = \\\"tag bracket\\\";\\n      return attrState(type, stream, state);\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return tagNameState;\\n    }\\n  }\\n  function closeTagNameState(type, stream, state) {\\n    if (type == \\\"word\\\") {\\n      var tagName = stream.current();\\n      if (state.context && state.context.tagName != tagName &&\\n          config.implicitlyClosed.hasOwnProperty(state.context.tagName))\\n        popContext(state);\\n      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {\\n        setStyle = \\\"tag\\\";\\n        return closeState;\\n      } else {\\n        setStyle = \\\"tag error\\\";\\n        return closeStateErr;\\n      }\\n    } else if (config.allowMissingTagName && type == \\\"endTag\\\") {\\n      setStyle = \\\"tag bracket\\\";\\n      return closeState(type, stream, state);\\n    } else {\\n      setStyle = \\\"error\\\";\\n      return closeStateErr;\\n    }\\n  }\\n\\n  function closeState(type, _stream, state) {\\n    if (type != \\\"endTag\\\") {\\n      setStyle = \\\"error\\\";\\n      return closeState;\\n    }\\n    popContext(state);\\n    return baseState;\\n  }\\n  function closeStateErr(type, stream, state) {\\n    setStyle = \\\"error\\\";\\n    return closeState(type, stream, state);\\n  }\\n\\n  function attrState(type, _stream, state) {\\n    if (type == \\\"word\\\") {\\n      setStyle = \\\"attribute\\\";\\n      return attrEqState;\\n    } else if (type == \\\"endTag\\\" || type == \\\"selfcloseTag\\\") {\\n      var tagName = state.tagName, tagStart = state.tagStart;\\n      state.tagName = state.tagStart = null;\\n      if (type == \\\"selfcloseTag\\\" ||\\n          config.autoSelfClosers.hasOwnProperty(tagName)) {\\n        maybePopContext(state, tagName);\\n      } else {\\n        maybePopContext(state, tagName);\\n        state.context = new Context(state, tagName, tagStart == state.indented);\\n      }\\n      return baseState;\\n    }\\n    setStyle = \\\"error\\\";\\n    return attrState;\\n  }\\n  function attrEqState(type, stream, state) {\\n    if (type == \\\"equals\\\") return attrValueState;\\n    if (!config.allowMissing) setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrValueState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    if (type == \\\"word\\\" && config.allowUnquoted) {setStyle = \\\"string\\\"; return attrState;}\\n    setStyle = \\\"error\\\";\\n    return attrState(type, stream, state);\\n  }\\n  function attrContinuedState(type, stream, state) {\\n    if (type == \\\"string\\\") return attrContinuedState;\\n    return attrState(type, stream, state);\\n  }\\n\\n  return {\\n    startState: function(baseIndent) {\\n      var state = {tokenize: inText,\\n                   state: baseState,\\n                   indented: baseIndent || 0,\\n                   tagName: null, tagStart: null,\\n                   context: null}\\n      if (baseIndent != null) state.baseIndent = baseIndent\\n      return state\\n    },\\n\\n    token: function(stream, state) {\\n      if (!state.tagName && stream.sol())\\n        state.indented = stream.indentation();\\n\\n      if (stream.eatSpace()) return null;\\n      type = null;\\n      var style = state.tokenize(stream, state);\\n      if ((style || type) && style != \\\"comment\\\") {\\n        setStyle = null;\\n        state.state = state.state(type || style, stream, state);\\n        if (setStyle)\\n          style = setStyle == \\\"error\\\" ? style + \\\" error\\\" : setStyle;\\n      }\\n      return style;\\n    },\\n\\n    indent: function(state, textAfter, fullLine) {\\n      var context = state.context;\\n      \\u002F\\u002F Indent multi-line strings (e.g. css).\\n      if (state.tokenize.isInAttribute) {\\n        if (state.tagStart == state.indented)\\n          return state.stringStartCol + 1;\\n        else\\n          return state.indented + indentUnit;\\n      }\\n      if (context && context.noIndent) return CodeMirror.Pass;\\n      if (state.tokenize != inTag && state.tokenize != inText)\\n        return fullLine ? fullLine.match(\\u002F^(\\\\s*)\\u002F)[0].length : 0;\\n      \\u002F\\u002F Indent the starts of attribute names.\\n      if (state.tagName) {\\n        if (config.multilineTagIndentPastTag !== false)\\n          return state.tagStart + state.tagName.length + 2;\\n        else\\n          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);\\n      }\\n      if (config.alignCDATA && \\u002F\\u003C!\\\\[CDATA\\\\[\\u002F.test(textAfter)) return 0;\\n      var tagAfter = textAfter && \\u002F^\\u003C(\\\\\\u002F)?([\\\\w_:\\\\.-]*)\\u002F.exec(textAfter);\\n      if (tagAfter && tagAfter[1]) { \\u002F\\u002F Closing tag spotted\\n        while (context) {\\n          if (context.tagName == tagAfter[2]) {\\n            context = context.prev;\\n            break;\\n          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {\\n            context = context.prev;\\n          } else {\\n            break;\\n          }\\n        }\\n      } else if (tagAfter) { \\u002F\\u002F Opening tag spotted\\n        while (context) {\\n          var grabbers = config.contextGrabbers[context.tagName];\\n          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))\\n            context = context.prev;\\n          else\\n            break;\\n        }\\n      }\\n      while (context && context.prev && !context.startOfLine)\\n        context = context.prev;\\n      if (context) return context.indent + indentUnit;\\n      else return state.baseIndent || 0;\\n    },\\n\\n    electricInput: \\u002F\\u003C\\\\\\u002F[\\\\s\\\\w:]+\\u003E$\\u002F,\\n    blockCommentStart: \\\"\\u003C!--\\\",\\n    blockCommentEnd: \\\"--\\u003E\\\",\\n\\n    configuration: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n    helperType: config.htmlMode ? \\\"html\\\" : \\\"xml\\\",\\n\\n    skipAttribute: function(state) {\\n      if (state.state == attrValueState)\\n        state.state = attrState\\n    }\\n  };\\n});\\n\\nCodeMirror.defineMIME(\\\"text\\u002Fxml\\\", \\\"xml\\\");\\nCodeMirror.defineMIME(\\\"application\\u002Fxml\\\", \\\"xml\\\");\\nif (!CodeMirror.mimeModes.hasOwnProperty(\\\"text\\u002Fhtml\\\"))\\n  CodeMirror.defineMIME(\\\"text\\u002Fhtml\\\", {name: \\\"xml\\\", htmlMode: true});\\n\\n});\\n\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Freact-codemirror2\\u002Findex.js\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\n\\r\\nvar __extends = (this && this.__extends) || (function () {\\r\\n    var extendStatics = Object.setPrototypeOf ||\\r\\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\\r\\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\\r\\n    return function (d, b) {\\r\\n        extendStatics(d, b);\\r\\n        function __() { this.constructor = d; }\\r\\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\\r\\n    };\\r\\n})();\\r\\nObject.defineProperty(exports, '__esModule', { value: true });\\r\\nvar React = __webpack_require__(\\\".\\u002Fnode_modules\\u002Freact\\u002Findex.js\\\");\\r\\nvar cm;\\r\\nvar SERVER_RENDERED = typeof navigator === 'undefined';\\r\\nif (!SERVER_RENDERED) {\\r\\n    cm = __webpack_require__(\\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.js\\\");\\r\\n}\\r\\nvar Shared = (function () {\\r\\n    function Shared(editor, props) {\\r\\n        this.editor = editor;\\r\\n        this.props = props;\\r\\n        this.notifyOfDeprecation();\\r\\n    }\\r\\n    Shared.prototype.notifyOfDeprecation = function () {\\r\\n        if (this.props.autoScrollCursorOnSet !== undefined) {\\r\\n            console.warn('`autoScrollCursorOnSet` has been deprecated. Use `autoScroll` instead\\\\n\\\\nSee https:\\u002F\\u002Fgithub.com\\u002Fscniro\\u002Freact-codemirror2#props');\\r\\n        }\\r\\n        if (this.props.resetCursorOnSet !== undefined) {\\r\\n            console.warn('`resetCursorOnSet` has been deprecated. Use `autoCursor` instead\\\\n\\\\nSee https:\\u002F\\u002Fgithub.com\\u002Fscniro\\u002Freact-codemirror2#props');\\r\\n        }\\r\\n        if (this.props.onSet !== undefined) {\\r\\n            console.warn('`onSet` has been deprecated. User `editorDidMount` instead. See https:\\u002F\\u002Fgithub.com\\u002Fscniro\\u002Freact-codemirror2#events');\\r\\n        }\\r\\n        if (this.props.onBeforeSet !== undefined) {\\r\\n            console.warn('`onBeforeSet` has been deprecated. User `onBeforeChange` for `Controlled`. instead. See https:\\u002F\\u002Fgithub.com\\u002Fscniro\\u002Freact-codemirror2#events');\\r\\n        }\\r\\n    };\\r\\n    Shared.prototype.wire = function (name) {\\r\\n        var _this = this;\\r\\n        switch (name) {\\r\\n            case 'onBlur':\\r\\n                {\\r\\n                    this.editor.on('blur', function (cm, event) {\\r\\n                        _this.props.onBlur(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onCursor':\\r\\n                {\\r\\n                    this.editor.on('cursorActivity', function (cm) {\\r\\n                        _this.props.onCursor(_this.editor, _this.editor.getCursor());\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onCursorActivity':\\r\\n                {\\r\\n                    this.editor.on('cursorActivity', function (cm) {\\r\\n                        _this.props.onCursorActivity(_this.editor);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onDragEnter':\\r\\n                {\\r\\n                    this.editor.on('dragenter', function (cm, event) {\\r\\n                        _this.props.onDragEnter(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onDragOver':\\r\\n                {\\r\\n                    this.editor.on('dragover', function (cm, event) {\\r\\n                        _this.props.onDragOver(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onDrop':\\r\\n                {\\r\\n                    this.editor.on('drop', function (cm, event) {\\r\\n                        _this.props.onDrop(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onFocus':\\r\\n                {\\r\\n                    this.editor.on('focus', function (cm, event) {\\r\\n                        _this.props.onFocus(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onGutterClick':\\r\\n                {\\r\\n                    this.editor.on('gutterClick', function (cm, lineNumber, gutter, event) {\\r\\n                        _this.props.onGutterClick(_this.editor, lineNumber, gutter, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onKeyDown':\\r\\n                {\\r\\n                    this.editor.on('keydown', function (cm, event) {\\r\\n                        _this.props.onKeyDown(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onKeyPress':\\r\\n                {\\r\\n                    this.editor.on('keypress', function (cm, event) {\\r\\n                        _this.props.onKeyPress(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onKeyUp':\\r\\n                {\\r\\n                    this.editor.on('keyup', function (cm, event) {\\r\\n                        _this.props.onKeyUp(_this.editor, event);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onScroll':\\r\\n                {\\r\\n                    this.editor.on('scroll', function (cm) {\\r\\n                        _this.props.onScroll(_this.editor, _this.editor.getScrollInfo());\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onSelection':\\r\\n                {\\r\\n                    this.editor.on('beforeSelectionChange', function (cm, data) {\\r\\n                        _this.props.onSelection(_this.editor, data);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onUpdate':\\r\\n                {\\r\\n                    this.editor.on('update', function (cm) {\\r\\n                        _this.props.onUpdate(_this.editor);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n            case 'onViewportChange':\\r\\n                {\\r\\n                    this.editor.on('viewportChange', function (cm, from, to) {\\r\\n                        _this.props.onViewportChange(_this.editor, from, to);\\r\\n                    });\\r\\n                }\\r\\n                break;\\r\\n        }\\r\\n    };\\r\\n    return Shared;\\r\\n}());\\r\\nvar Controlled = (function (_super) {\\r\\n    __extends(Controlled, _super);\\r\\n    function Controlled(props) {\\r\\n        var _this = _super.call(this, props) || this;\\r\\n        if (SERVER_RENDERED)\\r\\n            return _this;\\r\\n        _this.deferred = null;\\r\\n        _this.emulating = false;\\r\\n        _this.hydrated = false;\\r\\n        _this.initCb = function () {\\r\\n            if (_this.props.editorDidConfigure) {\\r\\n                _this.props.editorDidConfigure(_this.editor);\\r\\n            }\\r\\n        };\\r\\n        _this.mounted = false;\\r\\n        return _this;\\r\\n    }\\r\\n    Controlled.prototype.setCursor = function (cursorPos, scroll, focus) {\\r\\n        var doc = this.editor.getDoc();\\r\\n        if (focus) {\\r\\n            this.editor.focus();\\r\\n        }\\r\\n        if (scroll) {\\r\\n            doc.setCursor(cursorPos);\\r\\n        }\\r\\n        else {\\r\\n            doc.setCursor(cursorPos, null, { scroll: false });\\r\\n        }\\r\\n    };\\r\\n    Controlled.prototype.moveCursor = function (cursorPos, scroll) {\\r\\n        var doc = this.editor.getDoc();\\r\\n        if (scroll) {\\r\\n            doc.setCursor(cursorPos);\\r\\n        }\\r\\n        else {\\r\\n            doc.setCursor(cursorPos, null, { scroll: false });\\r\\n        }\\r\\n    };\\r\\n    Controlled.prototype.hydrate = function (props) {\\r\\n        var _this = this;\\r\\n        Object.keys(props.options || {}).forEach(function (key) {\\r\\n            _this.editor.setOption(key, props.options[key]);\\r\\n            _this.mirror.setOption(key, props.options[key]);\\r\\n        });\\r\\n        if (!this.hydrated) {\\r\\n            if (!this.mounted) {\\r\\n                this.initChange(props.value || '');\\r\\n            }\\r\\n            else {\\r\\n                if (this.deferred) {\\r\\n                    this.resolveChange();\\r\\n                }\\r\\n                else {\\r\\n                    this.initChange(props.value || '');\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        this.hydrated = true;\\r\\n    };\\r\\n    Controlled.prototype.initChange = function (value) {\\r\\n        this.emulating = true;\\r\\n        var lastLine = this.editor.lastLine();\\r\\n        var lastChar = this.editor.getLine(this.editor.lastLine()).length;\\r\\n        this.editor.replaceRange(value || '', { line: 0, ch: 0 }, { line: lastLine, ch: lastChar });\\r\\n        this.mirror.setValue(value);\\r\\n        this.editor.clearHistory();\\r\\n        this.mirror.clearHistory();\\r\\n        this.emulating = false;\\r\\n    };\\r\\n    Controlled.prototype.resolveChange = function () {\\r\\n        this.emulating = true;\\r\\n        if (this.deferred.origin === 'undo') {\\r\\n            this.editor.undo();\\r\\n        }\\r\\n        else if (this.deferred.origin === 'redo') {\\r\\n            this.editor.redo();\\r\\n        }\\r\\n        else {\\r\\n            this.editor.replaceRange(this.deferred.text, this.deferred.from, this.deferred.to, this.deferred.origin);\\r\\n        }\\r\\n        this.emulating = false;\\r\\n        this.deferred = null;\\r\\n    };\\r\\n    Controlled.prototype.mirrorChange = function (deferred) {\\r\\n        if (deferred.origin === 'undo') {\\r\\n            this.editor.setHistory(this.mirror.getHistory());\\r\\n            this.mirror.undo();\\r\\n        }\\r\\n        else if (deferred.origin === 'redo') {\\r\\n            this.editor.setHistory(this.mirror.getHistory());\\r\\n            this.mirror.redo();\\r\\n        }\\r\\n        else {\\r\\n            this.mirror.replaceRange(deferred.text, deferred.from, deferred.to, deferred.origin);\\r\\n        }\\r\\n        return this.mirror.getValue();\\r\\n    };\\r\\n    Controlled.prototype.componentWillMount = function () {\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        if (this.props.editorWillMount) {\\r\\n            this.props.editorWillMount();\\r\\n        }\\r\\n    };\\r\\n    Controlled.prototype.componentDidMount = function () {\\r\\n        var _this = this;\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        if (this.props.defineMode) {\\r\\n            if (this.props.defineMode.name && this.props.defineMode.fn) {\\r\\n                cm.defineMode(this.props.defineMode.name, this.props.defineMode.fn);\\r\\n            }\\r\\n        }\\r\\n        this.editor = cm(this.ref);\\r\\n        this.shared = new Shared(this.editor, this.props);\\r\\n        this.mirror = cm(function () {\\r\\n        });\\r\\n        this.editor.on('electricInput', function () {\\r\\n            _this.mirror.setHistory(_this.editor.getHistory());\\r\\n        });\\r\\n        this.editor.on('cursorActivity', function () {\\r\\n            _this.mirror.setCursor(_this.editor.getCursor());\\r\\n        });\\r\\n        this.editor.on('beforeChange', function (cm, data) {\\r\\n            if (_this.emulating) {\\r\\n                return;\\r\\n            }\\r\\n            data.cancel();\\r\\n            _this.deferred = data;\\r\\n            var phantomChange = _this.mirrorChange(_this.deferred);\\r\\n            if (_this.props.onBeforeChange)\\r\\n                _this.props.onBeforeChange(_this.editor, _this.deferred, phantomChange);\\r\\n        });\\r\\n        this.editor.on('change', function (cm, data) {\\r\\n            if (!_this.mounted) {\\r\\n                return;\\r\\n            }\\r\\n            if (_this.props.onChange) {\\r\\n                _this.props.onChange(_this.editor, data, _this.editor.getValue());\\r\\n            }\\r\\n        });\\r\\n        if (this.props.onBlur)\\r\\n            this.shared.wire('onBlur');\\r\\n        if (this.props.onCursor)\\r\\n            this.shared.wire('onCursor');\\r\\n        if (this.props.onCursorActivity)\\r\\n            this.shared.wire('onCursorActivity');\\r\\n        if (this.props.onDragEnter)\\r\\n            this.shared.wire('onDragEnter');\\r\\n        if (this.props.onDragOver)\\r\\n            this.shared.wire('onDragOver');\\r\\n        if (this.props.onDrop)\\r\\n            this.shared.wire('onDrop');\\r\\n        if (this.props.onFocus)\\r\\n            this.shared.wire('onFocus');\\r\\n        if (this.props.onGutterClick)\\r\\n            this.shared.wire('onGutterClick');\\r\\n        if (this.props.onKeyDown)\\r\\n            this.shared.wire('onKeyDown');\\r\\n        if (this.props.onKeyPress)\\r\\n            this.shared.wire('onKeyPress');\\r\\n        if (this.props.onKeyUp)\\r\\n            this.shared.wire('onKeyUp');\\r\\n        if (this.props.onScroll)\\r\\n            this.shared.wire('onScroll');\\r\\n        if (this.props.onSelection)\\r\\n            this.shared.wire('onSelection');\\r\\n        if (this.props.onUpdate)\\r\\n            this.shared.wire('onUpdate');\\r\\n        if (this.props.onViewportChange)\\r\\n            this.shared.wire('onViewportChange');\\r\\n        this.hydrate(this.props);\\r\\n        if (this.props.selection) {\\r\\n            var doc = this.editor.getDoc();\\r\\n            doc.setSelections(this.props.selection);\\r\\n        }\\r\\n        if (this.props.cursor) {\\r\\n            this.setCursor(this.props.cursor, this.props.autoScroll || false, this.props.autoFocus || false);\\r\\n        }\\r\\n        if (this.props.scroll) {\\r\\n            this.editor.scrollTo(this.props.scroll.x, this.props.scroll.y);\\r\\n        }\\r\\n        this.mounted = true;\\r\\n        if (this.props.editorDidMount) {\\r\\n            this.props.editorDidMount(this.editor, this.editor.getValue(), this.initCb);\\r\\n        }\\r\\n    };\\r\\n    Controlled.prototype.componentWillReceiveProps = function (nextProps) {\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        var cursorPos;\\r\\n        if (nextProps.value !== this.props.value) {\\r\\n            this.hydrated = false;\\r\\n        }\\r\\n        if (!this.props.autoCursor && this.props.autoCursor !== undefined) {\\r\\n            cursorPos = this.editor.getCursor();\\r\\n        }\\r\\n        this.hydrate(nextProps);\\r\\n        if (!this.props.autoCursor && this.props.autoCursor !== undefined) {\\r\\n            this.moveCursor(cursorPos, this.props.autoScroll || false);\\r\\n        }\\r\\n    };\\r\\n    Controlled.prototype.componentWillUnmount = function () {\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        if (this.props.editorWillUnmount) {\\r\\n            this.props.editorWillUnmount(cm);\\r\\n        }\\r\\n    };\\r\\n    Controlled.prototype.shouldComponentUpdate = function (nextProps, nextState) {\\r\\n        return !SERVER_RENDERED;\\r\\n    };\\r\\n    Controlled.prototype.render = function () {\\r\\n        var _this = this;\\r\\n        if (SERVER_RENDERED)\\r\\n            return null;\\r\\n        var className = this.props.className ? 'react-codemirror2 ' + this.props.className : 'react-codemirror2';\\r\\n        return (React.createElement('div', { className: className, ref: function (self) { return _this.ref = self; } }));\\r\\n    };\\r\\n    return Controlled;\\r\\n}(React.Component));\\r\\nexports.Controlled = Controlled;\\r\\nvar UnControlled = (function (_super) {\\r\\n    __extends(UnControlled, _super);\\r\\n    function UnControlled(props) {\\r\\n        var _this = _super.call(this, props) || this;\\r\\n        if (SERVER_RENDERED)\\r\\n            return _this;\\r\\n        _this.continueChange = false;\\r\\n        _this.hydrated = false;\\r\\n        _this.initCb = function () {\\r\\n            if (_this.props.editorDidConfigure) {\\r\\n                _this.props.editorDidConfigure(_this.editor);\\r\\n            }\\r\\n        };\\r\\n        _this.mounted = false;\\r\\n        _this.onBeforeChangeCb = function () {\\r\\n            _this.continueChange = true;\\r\\n        };\\r\\n        return _this;\\r\\n    }\\r\\n    UnControlled.prototype.setCursor = function (cursorPos, scroll, focus) {\\r\\n        var doc = this.editor.getDoc();\\r\\n        if (focus) {\\r\\n            this.editor.focus();\\r\\n        }\\r\\n        if (scroll) {\\r\\n            doc.setCursor(cursorPos);\\r\\n        }\\r\\n        else {\\r\\n            doc.setCursor(cursorPos, null, { scroll: false });\\r\\n        }\\r\\n    };\\r\\n    UnControlled.prototype.moveCursor = function (cursorPos, scroll) {\\r\\n        var doc = this.editor.getDoc();\\r\\n        if (scroll) {\\r\\n            doc.setCursor(cursorPos);\\r\\n        }\\r\\n        else {\\r\\n            doc.setCursor(cursorPos, null, { scroll: false });\\r\\n        }\\r\\n    };\\r\\n    UnControlled.prototype.hydrate = function (props) {\\r\\n        var _this = this;\\r\\n        Object.keys(props.options || {}).forEach(function (key) { return _this.editor.setOption(key, props.options[key]); });\\r\\n        if (!this.hydrated) {\\r\\n            var lastLine = this.editor.lastLine();\\r\\n            var lastChar = this.editor.getLine(this.editor.lastLine()).length;\\r\\n            this.editor.replaceRange(props.value || '', { line: 0, ch: 0 }, { line: lastLine, ch: lastChar });\\r\\n        }\\r\\n        this.hydrated = true;\\r\\n    };\\r\\n    UnControlled.prototype.componentWillMount = function () {\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        if (this.props.editorWillMount) {\\r\\n            this.props.editorWillMount();\\r\\n        }\\r\\n    };\\r\\n    UnControlled.prototype.componentDidMount = function () {\\r\\n        var _this = this;\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        if (this.props.defineMode) {\\r\\n            if (this.props.defineMode.name && this.props.defineMode.fn) {\\r\\n                cm.defineMode(this.props.defineMode.name, this.props.defineMode.fn);\\r\\n            }\\r\\n        }\\r\\n        this.editor = cm(this.ref);\\r\\n        this.shared = new Shared(this.editor, this.props);\\r\\n        this.editor.on('beforeChange', function (cm, data) {\\r\\n            if (_this.props.onBeforeChange) {\\r\\n                _this.props.onBeforeChange(_this.editor, data, null, _this.onBeforeChangeCb);\\r\\n            }\\r\\n        });\\r\\n        this.editor.on('change', function (cm, data) {\\r\\n            if (!_this.mounted) {\\r\\n                return;\\r\\n            }\\r\\n            if (_this.props.onBeforeChange) {\\r\\n                if (_this.continueChange) {\\r\\n                    _this.props.onChange(_this.editor, data, _this.editor.getValue());\\r\\n                }\\r\\n                else {\\r\\n                    return;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                _this.props.onChange(_this.editor, data, _this.editor.getValue());\\r\\n            }\\r\\n        });\\r\\n        if (this.props.onBlur)\\r\\n            this.shared.wire('onBlur');\\r\\n        if (this.props.onCursor)\\r\\n            this.shared.wire('onCursor');\\r\\n        if (this.props.onCursorActivity)\\r\\n            this.shared.wire('onCursorActivity');\\r\\n        if (this.props.onDragEnter)\\r\\n            this.shared.wire('onDragEnter');\\r\\n        if (this.props.onDragOver)\\r\\n            this.shared.wire('onDragOver');\\r\\n        if (this.props.onDrop)\\r\\n            this.shared.wire('onDrop');\\r\\n        if (this.props.onFocus)\\r\\n            this.shared.wire('onFocus');\\r\\n        if (this.props.onGutterClick)\\r\\n            this.shared.wire('onGutterClick');\\r\\n        if (this.props.onKeyDown)\\r\\n            this.shared.wire('onKeyDown');\\r\\n        if (this.props.onKeyPress)\\r\\n            this.shared.wire('onKeyPress');\\r\\n        if (this.props.onKeyUp)\\r\\n            this.shared.wire('onKeyUp');\\r\\n        if (this.props.onScroll)\\r\\n            this.shared.wire('onScroll');\\r\\n        if (this.props.onSelection)\\r\\n            this.shared.wire('onSelection');\\r\\n        if (this.props.onUpdate)\\r\\n            this.shared.wire('onUpdate');\\r\\n        if (this.props.onViewportChange)\\r\\n            this.shared.wire('onViewportChange');\\r\\n        this.hydrate(this.props);\\r\\n        if (this.props.selection) {\\r\\n            var doc = this.editor.getDoc();\\r\\n            doc.setSelections(this.props.selection);\\r\\n        }\\r\\n        if (this.props.cursor) {\\r\\n            this.setCursor(this.props.cursor, this.props.autoScroll || false, this.props.autoFocus || false);\\r\\n        }\\r\\n        if (this.props.scroll) {\\r\\n            this.editor.scrollTo(this.props.scroll.x, this.props.scroll.y);\\r\\n        }\\r\\n        this.mounted = true;\\r\\n        this.editor.clearHistory();\\r\\n        if (this.props.editorDidMount) {\\r\\n            this.props.editorDidMount(this.editor, this.editor.getValue(), this.initCb);\\r\\n        }\\r\\n    };\\r\\n    UnControlled.prototype.componentWillReceiveProps = function (nextProps) {\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        var cursorPos;\\r\\n        if (nextProps.value !== this.props.value) {\\r\\n            this.hydrated = false;\\r\\n        }\\r\\n        if (!this.props.autoCursor && this.props.autoCursor !== undefined) {\\r\\n            cursorPos = this.editor.getCursor();\\r\\n        }\\r\\n        this.hydrate(nextProps);\\r\\n        if (!this.props.autoCursor && this.props.autoCursor !== undefined) {\\r\\n            this.moveCursor(cursorPos, this.props.autoScroll || false);\\r\\n        }\\r\\n    };\\r\\n    UnControlled.prototype.componentWillUnmount = function () {\\r\\n        if (SERVER_RENDERED)\\r\\n            return;\\r\\n        if (this.props.editorWillUnmount) {\\r\\n            this.props.editorWillUnmount(cm);\\r\\n        }\\r\\n    };\\r\\n    UnControlled.prototype.shouldComponentUpdate = function (nextProps, nextState) {\\r\\n        return !SERVER_RENDERED;\\r\\n    };\\r\\n    UnControlled.prototype.render = function () {\\r\\n        var _this = this;\\r\\n        if (SERVER_RENDERED)\\r\\n            return null;\\r\\n        var className = this.props.className ? 'react-codemirror2 ' + this.props.className : 'react-codemirror2';\\r\\n        return (React.createElement('div', { className: className, ref: function (self) { return _this.ref = self; } }));\\r\\n    };\\r\\n    return UnControlled;\\r\\n}(React.Component));\\r\\nexports.UnControlled = UnControlled;\\r\\n\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Flib\\u002Frsg-components\\u002FEditor\\u002FEditor.js\\\":\\n\\u002F***\\u002F (function(module, __webpack_exports__, __webpack_require__) {\\n\\n\\\"use strict\\\";\\nObject.defineProperty(__webpack_exports__, \\\"__esModule\\\", { value: true });\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(\\\".\\u002Fnode_modules\\u002Freact\\u002Findex.js\\\");\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_1_prop_types__ = __webpack_require__(\\\".\\u002Fnode_modules\\u002Fprop-types\\u002Findex.js\\\");\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_1_prop_types___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_prop_types__);\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_2_lodash_debounce__ = __webpack_require__(\\\".\\u002Fnode_modules\\u002Flodash\\u002Fdebounce.js\\\");\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_2_lodash_debounce___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash_debounce__);\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_3_react_codemirror2__ = __webpack_require__(\\\".\\u002Fnode_modules\\u002Freact-codemirror2\\u002Findex.js\\\");\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_3_react_codemirror2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_react_codemirror2__);\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_4_codemirror_mode_jsx_jsx__ = __webpack_require__(\\\".\\u002Fnode_modules\\u002Fcodemirror\\u002Fmode\\u002Fjsx\\u002Fjsx.js\\\");\\n\\u002F* harmony import *\\u002F var __WEBPACK_IMPORTED_MODULE_4_codemirror_mode_jsx_jsx___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_codemirror_mode_jsx_jsx__);\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i \\u003C props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\"); } return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self; }\\n\\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \\\"function\\\" && superClass !== null) { throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\\n\\n\\n\\n\\n\\n\\n\\n\\u002F\\u002F Were explicitly specifying Webpack loaders here so we could skip specifying them in Webpack configuration.\\n\\u002F\\u002F That way we could avoid clashes between our loaders and user loaders.\\n\\u002F\\u002F eslint-disable-next-line import\\u002Fno-unresolved\\n__webpack_require__(\\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fstyle-loader.js!.\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.css\\\");\\n\\u002F\\u002F eslint-disable-next-line import\\u002Fno-unresolved\\n__webpack_require__(\\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fstyle-loader.js!.\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Ftheme\\u002Fbase16-light.css\\\");\\n\\nvar UPDATE_DELAY = 10;\\n\\nvar Editor = function (_Component) {\\n\\t_inherits(Editor, _Component);\\n\\n\\tfunction Editor() {\\n\\t\\t_classCallCheck(this, Editor);\\n\\n\\t\\tvar _this = _possibleConstructorReturn(this, (Editor.__proto__ || Object.getPrototypeOf(Editor)).call(this));\\n\\n\\t\\t_this.handleChange = __WEBPACK_IMPORTED_MODULE_2_lodash_debounce___default()(_this.handleChange.bind(_this), UPDATE_DELAY);\\n\\t\\treturn _this;\\n\\t}\\n\\n\\t_createClass(Editor, [{\\n\\t\\tkey: 'shouldComponentUpdate',\\n\\t\\tvalue: function shouldComponentUpdate() {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}, {\\n\\t\\tkey: 'handleChange',\\n\\t\\tvalue: function handleChange(editor, metadata, newCode) {\\n\\t\\t\\tthis.props.onChange(newCode);\\n\\t\\t}\\n\\t}, {\\n\\t\\tkey: 'render',\\n\\t\\tvalue: function render() {\\n\\t\\t\\tvar code = this.props.code;\\n\\t\\t\\tvar editorConfig = this.context.config.editorConfig;\\n\\n\\t\\t\\treturn __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_3_react_codemirror2__[\\\"UnControlled\\\"], { value: code, onChange: this.handleChange, options: editorConfig });\\n\\t\\t}\\n\\t}]);\\n\\n\\treturn Editor;\\n}(__WEBPACK_IMPORTED_MODULE_0_react__[\\\"Component\\\"]);\\n\\nEditor.propTypes = {\\n\\tcode: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.string.isRequired,\\n\\tonChange: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.func.isRequired\\n};\\nEditor.contextTypes = {\\n\\tconfig: __WEBPACK_IMPORTED_MODULE_1_prop_types___default.a.object.isRequired\\n};\\n\\u002F* harmony default export *\\u002F __webpack_exports__[\\\"default\\\"] = (Editor);\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.css\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nexports = module.exports = __webpack_require__(\\\".\\u002Fnode_modules\\u002Fcss-loader\\u002Flib\\u002Fcss-base.js\\\")(undefined);\\n\\u002F\\u002F imports\\n\\n\\n\\u002F\\u002F module\\nexports.push([module.i, \\\"\\u002F* BASICS *\\u002F\\\\n\\\\n.CodeMirror {\\\\n  \\u002F* Set height, width, borders, and global font properties here *\\u002F\\\\n  font-family: monospace;\\\\n  height: 300px;\\\\n  color: black;\\\\n  direction: ltr;\\\\n}\\\\n\\\\n\\u002F* PADDING *\\u002F\\\\n\\\\n.CodeMirror-lines {\\\\n  padding: 4px 0; \\u002F* Vertical padding around content *\\u002F\\\\n}\\\\n.CodeMirror pre {\\\\n  padding: 0 4px; \\u002F* Horizontal padding of content *\\u002F\\\\n}\\\\n\\\\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\\\n  background-color: white; \\u002F* The little square between H and V scrollbars *\\u002F\\\\n}\\\\n\\\\n\\u002F* GUTTER *\\u002F\\\\n\\\\n.CodeMirror-gutters {\\\\n  border-right: 1px solid #ddd;\\\\n  background-color: #f7f7f7;\\\\n  white-space: nowrap;\\\\n}\\\\n.CodeMirror-linenumbers {}\\\\n.CodeMirror-linenumber {\\\\n  padding: 0 3px 0 5px;\\\\n  min-width: 20px;\\\\n  text-align: right;\\\\n  color: #999;\\\\n  white-space: nowrap;\\\\n}\\\\n\\\\n.CodeMirror-guttermarker { color: black; }\\\\n.CodeMirror-guttermarker-subtle { color: #999; }\\\\n\\\\n\\u002F* CURSOR *\\u002F\\\\n\\\\n.CodeMirror-cursor {\\\\n  border-left: 1px solid black;\\\\n  border-right: none;\\\\n  width: 0;\\\\n}\\\\n\\u002F* Shown when moving in bi-directional text *\\u002F\\\\n.CodeMirror div.CodeMirror-secondarycursor {\\\\n  border-left: 1px solid silver;\\\\n}\\\\n.cm-fat-cursor .CodeMirror-cursor {\\\\n  width: auto;\\\\n  border: 0 !important;\\\\n  background: #7e7;\\\\n}\\\\n.cm-fat-cursor div.CodeMirror-cursors {\\\\n  z-index: 1;\\\\n}\\\\n.cm-fat-cursor-mark {\\\\n  background-color: rgba(20, 255, 20, 0.5);\\\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\\\n  -moz-animation: blink 1.06s steps(1) infinite;\\\\n  animation: blink 1.06s steps(1) infinite;\\\\n}\\\\n.cm-animate-fat-cursor {\\\\n  width: auto;\\\\n  border: 0;\\\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\\\n  -moz-animation: blink 1.06s steps(1) infinite;\\\\n  animation: blink 1.06s steps(1) infinite;\\\\n  background-color: #7e7;\\\\n}\\\\n@-moz-keyframes blink {\\\\n  0% {}\\\\n  50% { background-color: transparent; }\\\\n  100% {}\\\\n}\\\\n@-webkit-keyframes blink {\\\\n  0% {}\\\\n  50% { background-color: transparent; }\\\\n  100% {}\\\\n}\\\\n@keyframes blink {\\\\n  0% {}\\\\n  50% { background-color: transparent; }\\\\n  100% {}\\\\n}\\\\n\\\\n\\u002F* Can style cursor different in overwrite (non-insert) mode *\\u002F\\\\n.CodeMirror-overwrite .CodeMirror-cursor {}\\\\n\\\\n.cm-tab { display: inline-block; text-decoration: inherit; }\\\\n\\\\n.CodeMirror-rulers {\\\\n  position: absolute;\\\\n  left: 0; right: 0; top: -50px; bottom: -20px;\\\\n  overflow: hidden;\\\\n}\\\\n.CodeMirror-ruler {\\\\n  border-left: 1px solid #ccc;\\\\n  top: 0; bottom: 0;\\\\n  position: absolute;\\\\n}\\\\n\\\\n\\u002F* DEFAULT THEME *\\u002F\\\\n\\\\n.cm-s-default .cm-header {color: blue;}\\\\n.cm-s-default .cm-quote {color: #090;}\\\\n.cm-negative {color: #d44;}\\\\n.cm-positive {color: #292;}\\\\n.cm-header, .cm-strong {font-weight: bold;}\\\\n.cm-em {font-style: italic;}\\\\n.cm-link {text-decoration: underline;}\\\\n.cm-strikethrough {text-decoration: line-through;}\\\\n\\\\n.cm-s-default .cm-keyword {color: #708;}\\\\n.cm-s-default .cm-atom {color: #219;}\\\\n.cm-s-default .cm-number {color: #164;}\\\\n.cm-s-default .cm-def {color: #00f;}\\\\n.cm-s-default .cm-variable,\\\\n.cm-s-default .cm-punctuation,\\\\n.cm-s-default .cm-property,\\\\n.cm-s-default .cm-operator {}\\\\n.cm-s-default .cm-variable-2 {color: #05a;}\\\\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\\\\n.cm-s-default .cm-comment {color: #a50;}\\\\n.cm-s-default .cm-string {color: #a11;}\\\\n.cm-s-default .cm-string-2 {color: #f50;}\\\\n.cm-s-default .cm-meta {color: #555;}\\\\n.cm-s-default .cm-qualifier {color: #555;}\\\\n.cm-s-default .cm-builtin {color: #30a;}\\\\n.cm-s-default .cm-bracket {color: #997;}\\\\n.cm-s-default .cm-tag {color: #170;}\\\\n.cm-s-default .cm-attribute {color: #00c;}\\\\n.cm-s-default .cm-hr {color: #999;}\\\\n.cm-s-default .cm-link {color: #00c;}\\\\n\\\\n.cm-s-default .cm-error {color: #f00;}\\\\n.cm-invalidchar {color: #f00;}\\\\n\\\\n.CodeMirror-composing { border-bottom: 2px solid; }\\\\n\\\\n\\u002F* Default styles for common addons *\\u002F\\\\n\\\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\\\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\\\\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\\\\n.CodeMirror-activeline-background {background: #e8f2ff;}\\\\n\\\\n\\u002F* STOP *\\u002F\\\\n\\\\n\\u002F* The rest of this file contains styles related to the mechanics of\\\\n   the editor. You probably shouldn't touch them. *\\u002F\\\\n\\\\n.CodeMirror {\\\\n  position: relative;\\\\n  overflow: hidden;\\\\n  background: white;\\\\n}\\\\n\\\\n.CodeMirror-scroll {\\\\n  overflow: scroll !important; \\u002F* Things will break if this is overridden *\\u002F\\\\n  \\u002F* 30px is the magic margin used to hide the element's real scrollbars *\\u002F\\\\n  \\u002F* See overflow: hidden in .CodeMirror *\\u002F\\\\n  margin-bottom: -30px; margin-right: -30px;\\\\n  padding-bottom: 30px;\\\\n  height: 100%;\\\\n  outline: none; \\u002F* Prevent dragging from highlighting the element *\\u002F\\\\n  position: relative;\\\\n}\\\\n.CodeMirror-sizer {\\\\n  position: relative;\\\\n  border-right: 30px solid transparent;\\\\n}\\\\n\\\\n\\u002F* The fake, visible scrollbars. Used to force redraw during scrolling\\\\n   before actual scrolling happens, thus preventing shaking and\\\\n   flickering artifacts. *\\u002F\\\\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\\\n  position: absolute;\\\\n  z-index: 6;\\\\n  display: none;\\\\n}\\\\n.CodeMirror-vscrollbar {\\\\n  right: 0; top: 0;\\\\n  overflow-x: hidden;\\\\n  overflow-y: scroll;\\\\n}\\\\n.CodeMirror-hscrollbar {\\\\n  bottom: 0; left: 0;\\\\n  overflow-y: hidden;\\\\n  overflow-x: scroll;\\\\n}\\\\n.CodeMirror-scrollbar-filler {\\\\n  right: 0; bottom: 0;\\\\n}\\\\n.CodeMirror-gutter-filler {\\\\n  left: 0; bottom: 0;\\\\n}\\\\n\\\\n.CodeMirror-gutters {\\\\n  position: absolute; left: 0; top: 0;\\\\n  min-height: 100%;\\\\n  z-index: 3;\\\\n}\\\\n.CodeMirror-gutter {\\\\n  white-space: normal;\\\\n  height: 100%;\\\\n  display: inline-block;\\\\n  vertical-align: top;\\\\n  margin-bottom: -30px;\\\\n}\\\\n.CodeMirror-gutter-wrapper {\\\\n  position: absolute;\\\\n  z-index: 4;\\\\n  background: none !important;\\\\n  border: none !important;\\\\n}\\\\n.CodeMirror-gutter-background {\\\\n  position: absolute;\\\\n  top: 0; bottom: 0;\\\\n  z-index: 4;\\\\n}\\\\n.CodeMirror-gutter-elt {\\\\n  position: absolute;\\\\n  cursor: default;\\\\n  z-index: 4;\\\\n}\\\\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\\\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\\\n\\\\n.CodeMirror-lines {\\\\n  cursor: text;\\\\n  min-height: 1px; \\u002F* prevents collapsing before first draw *\\u002F\\\\n}\\\\n.CodeMirror pre {\\\\n  \\u002F* Reset some styles that the rest of the page might have set *\\u002F\\\\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\\\\n  border-width: 0;\\\\n  background: transparent;\\\\n  font-family: inherit;\\\\n  font-size: inherit;\\\\n  margin: 0;\\\\n  white-space: pre;\\\\n  word-wrap: normal;\\\\n  line-height: inherit;\\\\n  color: inherit;\\\\n  z-index: 2;\\\\n  position: relative;\\\\n  overflow: visible;\\\\n  -webkit-tap-highlight-color: transparent;\\\\n  -webkit-font-variant-ligatures: contextual;\\\\n  font-variant-ligatures: contextual;\\\\n}\\\\n.CodeMirror-wrap pre {\\\\n  word-wrap: break-word;\\\\n  white-space: pre-wrap;\\\\n  word-break: normal;\\\\n}\\\\n\\\\n.CodeMirror-linebackground {\\\\n  position: absolute;\\\\n  left: 0; right: 0; top: 0; bottom: 0;\\\\n  z-index: 0;\\\\n}\\\\n\\\\n.CodeMirror-linewidget {\\\\n  position: relative;\\\\n  z-index: 2;\\\\n  padding: 0.1px; \\u002F* Force widget margins to stay inside of the container *\\u002F\\\\n}\\\\n\\\\n.CodeMirror-widget {}\\\\n\\\\n.CodeMirror-rtl pre { direction: rtl; }\\\\n\\\\n.CodeMirror-code {\\\\n  outline: none;\\\\n}\\\\n\\\\n\\u002F* Force content-box sizing for the elements where we expect it *\\u002F\\\\n.CodeMirror-scroll,\\\\n.CodeMirror-sizer,\\\\n.CodeMirror-gutter,\\\\n.CodeMirror-gutters,\\\\n.CodeMirror-linenumber {\\\\n  -moz-box-sizing: content-box;\\\\n  box-sizing: content-box;\\\\n}\\\\n\\\\n.CodeMirror-measure {\\\\n  position: absolute;\\\\n  width: 100%;\\\\n  height: 0;\\\\n  overflow: hidden;\\\\n  visibility: hidden;\\\\n}\\\\n\\\\n.CodeMirror-cursor {\\\\n  position: absolute;\\\\n  pointer-events: none;\\\\n}\\\\n.CodeMirror-measure pre { position: static; }\\\\n\\\\ndiv.CodeMirror-cursors {\\\\n  visibility: hidden;\\\\n  position: relative;\\\\n  z-index: 3;\\\\n}\\\\ndiv.CodeMirror-dragcursors {\\\\n  visibility: visible;\\\\n}\\\\n\\\\n.CodeMirror-focused div.CodeMirror-cursors {\\\\n  visibility: visible;\\\\n}\\\\n\\\\n.CodeMirror-selected { background: #d9d9d9; }\\\\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\\\\n.CodeMirror-crosshair { cursor: crosshair; }\\\\n.CodeMirror-line::selection, .CodeMirror-line \\u003E span::selection, .CodeMirror-line \\u003E span \\u003E span::selection { background: #d7d4f0; }\\\\n.CodeMirror-line::-moz-selection, .CodeMirror-line \\u003E span::-moz-selection, .CodeMirror-line \\u003E span \\u003E span::-moz-selection { background: #d7d4f0; }\\\\n\\\\n.cm-searching {\\\\n  background-color: #ffa;\\\\n  background-color: rgba(255, 255, 0, .4);\\\\n}\\\\n\\\\n\\u002F* Used to force a border model for a node *\\u002F\\\\n.cm-force-border { padding-right: .1px; }\\\\n\\\\n@media print {\\\\n  \\u002F* Hide the cursor when printing *\\u002F\\\\n  .CodeMirror div.CodeMirror-cursors {\\\\n    visibility: hidden;\\\\n  }\\\\n}\\\\n\\\\n\\u002F* See issue #2901 *\\u002F\\\\n.cm-tab-wrap-hack:after { content: ''; }\\\\n\\\\n\\u002F* Help users use markselection to safely style text background *\\u002F\\\\nspan.CodeMirror-selectedtext { background: none; }\\\\n\\\", \\\"\\\"]);\\n\\n\\u002F\\u002F exports\\n\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Ftheme\\u002Fbase16-light.css\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\nexports = module.exports = __webpack_require__(\\\".\\u002Fnode_modules\\u002Fcss-loader\\u002Flib\\u002Fcss-base.js\\\")(undefined);\\n\\u002F\\u002F imports\\n\\n\\n\\u002F\\u002F module\\nexports.push([module.i, \\\"\\u002F*\\\\n\\\\n    Name:       Base16 Default Light\\\\n    Author:     Chris Kempson (http:\\u002F\\u002Fchriskempson.com)\\\\n\\\\n    CodeMirror template by Jan T. Sott (https:\\u002F\\u002Fgithub.com\\u002Fidleberg\\u002Fbase16-codemirror)\\\\n    Original Base16 color scheme by Chris Kempson (https:\\u002F\\u002Fgithub.com\\u002Fchriskempson\\u002Fbase16)\\\\n\\\\n*\\u002F\\\\n\\\\n.cm-s-base16-light.CodeMirror { background: #f5f5f5; color: #202020; }\\\\n.cm-s-base16-light div.CodeMirror-selected { background: #e0e0e0; }\\\\n.cm-s-base16-light .CodeMirror-line::selection, .cm-s-base16-light .CodeMirror-line \\u003E span::selection, .cm-s-base16-light .CodeMirror-line \\u003E span \\u003E span::selection { background: #e0e0e0; }\\\\n.cm-s-base16-light .CodeMirror-line::-moz-selection, .cm-s-base16-light .CodeMirror-line \\u003E span::-moz-selection, .cm-s-base16-light .CodeMirror-line \\u003E span \\u003E span::-moz-selection { background: #e0e0e0; }\\\\n.cm-s-base16-light .CodeMirror-gutters { background: #f5f5f5; border-right: 0px; }\\\\n.cm-s-base16-light .CodeMirror-guttermarker { color: #ac4142; }\\\\n.cm-s-base16-light .CodeMirror-guttermarker-subtle { color: #b0b0b0; }\\\\n.cm-s-base16-light .CodeMirror-linenumber { color: #b0b0b0; }\\\\n.cm-s-base16-light .CodeMirror-cursor { border-left: 1px solid #505050; }\\\\n\\\\n.cm-s-base16-light span.cm-comment { color: #8f5536; }\\\\n.cm-s-base16-light span.cm-atom { color: #aa759f; }\\\\n.cm-s-base16-light span.cm-number { color: #aa759f; }\\\\n\\\\n.cm-s-base16-light span.cm-property, .cm-s-base16-light span.cm-attribute { color: #90a959; }\\\\n.cm-s-base16-light span.cm-keyword { color: #ac4142; }\\\\n.cm-s-base16-light span.cm-string { color: #f4bf75; }\\\\n\\\\n.cm-s-base16-light span.cm-variable { color: #90a959; }\\\\n.cm-s-base16-light span.cm-variable-2 { color: #6a9fb5; }\\\\n.cm-s-base16-light span.cm-def { color: #d28445; }\\\\n.cm-s-base16-light span.cm-bracket { color: #202020; }\\\\n.cm-s-base16-light span.cm-tag { color: #ac4142; }\\\\n.cm-s-base16-light span.cm-link { color: #aa759f; }\\\\n.cm-s-base16-light span.cm-error { background: #ac4142; color: #505050; }\\\\n\\\\n.cm-s-base16-light .CodeMirror-activeline-background { background: #DDDCDC; }\\\\n.cm-s-base16-light .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }\\\\n\\\", \\\"\\\"]);\\n\\n\\u002F\\u002F exports\\n\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fstyle-loader.js!.\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.css\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F style-loader: Adds some css to the DOM by adding a \\u003Cstyle\\u003E tag\\n\\n\\u002F\\u002F load the styles\\nvar content = __webpack_require__(\\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Flib\\u002Fcodemirror.css\\\");\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n\\u002F\\u002F Prepare cssTransformation\\nvar transform;\\n\\nvar options = {\\\"hmr\\\":true}\\noptions.transform = transform\\n\\u002F\\u002F add the styles to the DOM\\nvar update = __webpack_require__(\\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Fnode_modules\\u002Fstyle-loader\\u002Flib\\u002FaddStyles.js\\\")(content, options);\\nif(content.locals) module.exports = content.locals;\\n\\u002F\\u002F Hot Module Replacement\\nif(false) {\\n\\t\\u002F\\u002F When the styles change, update the \\u003Cstyle\\u003E tags\\n\\tif(!content.locals) {\\n\\t\\tmodule.hot.accept(\\\"!!..\\u002F..\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fcodemirror.css\\\", function() {\\n\\t\\t\\tvar newContent = require(\\\"!!..\\u002F..\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fcodemirror.css\\\");\\n\\t\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\t\\t\\tupdate(newContent);\\n\\t\\t});\\n\\t}\\n\\t\\u002F\\u002F When the module is disposed, remove the \\u003Cstyle\\u003E tags\\n\\tmodule.hot.dispose(function() { update(); });\\n}\\n\\n\\u002F***\\u002F }),\\n\\n\\u002F***\\u002F \\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fstyle-loader.js!.\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Ftheme\\u002Fbase16-light.css\\\":\\n\\u002F***\\u002F (function(module, exports, __webpack_require__) {\\n\\n\\u002F\\u002F style-loader: Adds some css to the DOM by adding a \\u003Cstyle\\u003E tag\\n\\n\\u002F\\u002F load the styles\\nvar content = __webpack_require__(\\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fnode_modules\\u002Fcodemirror\\u002Ftheme\\u002Fbase16-light.css\\\");\\nif(typeof content === 'string') content = [[module.i, content, '']];\\n\\u002F\\u002F Prepare cssTransformation\\nvar transform;\\n\\nvar options = {\\\"hmr\\\":true}\\noptions.transform = transform\\n\\u002F\\u002F add the styles to the DOM\\nvar update = __webpack_require__(\\\".\\u002Fnode_modules\\u002Freact-styleguidist\\u002Fnode_modules\\u002Fstyle-loader\\u002Flib\\u002FaddStyles.js\\\")(content, options);\\nif(content.locals) module.exports = content.locals;\\n\\u002F\\u002F Hot Module Replacement\\nif(false) {\\n\\t\\u002F\\u002F When the styles change, update the \\u003Cstyle\\u003E tags\\n\\tif(!content.locals) {\\n\\t\\tmodule.hot.accept(\\\"!!..\\u002F..\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fbase16-light.css\\\", function() {\\n\\t\\t\\tvar newContent = require(\\\"!!..\\u002F..\\u002Freact-styleguidist\\u002Floaders\\u002Fcss-loader.js!.\\u002Fbase16-light.css\\\");\\n\\t\\t\\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\\n\\t\\t\\tupdate(newContent);\\n\\t\\t});\\n\\t}\\n\\t\\u002F\\u002F When the module is disposed, remove the \\u003Cstyle\\u003E tags\\n\\tmodule.hot.dispose(function() { update(); });\\n}\\n\\n\\u002F***\\u002F })\\n\\n});\"}","integrity":"sha512-sDbTRIiI/m66Ben6QrXNJJbm04w6NehQsC2JAvrh00nvjHZ5Hx/DdBr/skHeLaA0FjMbq199LynRBK5f58Br6w==","time":1519919824072,"size":246767}